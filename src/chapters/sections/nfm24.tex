%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}


In this chapter, we present a quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define three different quantitative measures for the impact of the input variables on the program outcome, and we formalize a static analysis for verifying the resulting quantitative impact property of a program.
At the end, we present abstract versions of the quantitative measures and show how they can be used to verify the corresponding quantitative property.
This chapter is based on work published at NASA Formal Methods Symposium (NFM) 2024 \cite{Mazzucato2024b}.
In the next chapters, we will apply this quantitative framework in the context of neural network and timing side-channel attacks.

\emph{Dans ce chapitre, nous présentons une notion quantitative de l'utilisation des données d'entrée, en prolongeant la définition introduite dans le chapitre précédent. Nous définissons trois mesures quantitatives différentes pour l'impact des variables d'entrée sur le résultat du programme et nous formalisons une analyse statique pour vérifier la propriété d'impact quantitatif résultante d'un programme. À la fin, nous présentons des versions abstraites des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier la propriété quantitative correspondante. Ce chapitre est basé sur des travaux publiés au NASA Formal Methods Symposium (NFM) 2024 \sidecite{Mazzucato2024b}. Dans les prochains chapitres, nous appliquerons ce cadre quantitatif dans le contexte des réseaux de neurones et des attaques par canaux auxiliaires temporels.
}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}


\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as quantifying how much the input data influences the program outcomes.
To this end, we define the \emph{$\defbound$-bounded impact property} $\genbounded$ as the set of program semantics such that the input variables $\definputvariables\in\setof\inputvariables$ have an impact on the program outcome bounded by $\defbound\in\valuesposplus$.
\marginnote{
  The set $\setof\inputvariables$ contains the input variables of a program.
}
\marginnote{
The set $\valuesposplus$ contains non-negative numerical values as well as with $+\infty$.
}
Depending on the comparison operator $\comparison\in\{\le,\ge\}$, the impact quantity is bounded by $\defbound$ either from above or below.
We employ the \emph{impact notion}:
\[\impactwrapper\in\tracetype\to\valuesposplus\]
to quantify the impact of the input variables $\definputvariables$ on the outcome of program computations.

\marginnote[*2]{
  As a comparison, here is the definition of the qualitative counterpart $\unused$:
  \begin{named}[\nrefdef{unused}]%
    \input{src/propositions/unused-short}%
  \end{named}%
}
\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariables\in\setof\inputvariables$ be the set of input variables of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact notion, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where the comparison operator $\comparison$ is either $\le$ or $\ge$.
\end{definition}

We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow further abstractions of computable semantics to return an always greater or, respectively, an always smaller impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$, formally:
  \begin{align*}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align*}
\end{remark}

Next, we instantiate $\impactwrappername$ with the impact notions of \outcomesname{}, \rangename{}, and \qusedname{}. Each of these notions differently characterizes the impact of the input variables: \outcomesname{} counts the number of different outcomes, \rangename{} measures the range of outcome values, and \qusedname{} counts the number of input values that are \emph{not} used to produce the outcomes.
To this end, these notions employ the concept of output abstraction, \cf{} \refdef*{output-observer}[*-10].
% We expect the output observer $\outputobs$ (\refdef*{output-observer}[*-2]) to return a quantifiable element, \ie{}, a value in $\valuesinf$.
% An output observer $\outputobs$ that returns a quantifiable element is called an \emph{output observer}.

% \begin{definition}[Output Descriptor]
%   \labdef{output-descriptor}
%   An \textup{output observer} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
% \end{definition}

% The above output observer $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
% We leverage this output observer to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.

\begin{example}\labexample{output-observer-landing}
  Consider the \refprog*{landing-alarm-system}[*-8] for a landing alarm system with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and use $\state$ as only values of variables, without considering program locations.
  The output observer is instantiated with
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  As a result, the output observer $\outputobs$ focuses on the value of the variable $\texttt{risk}$ when the last state of the trace is $\langle a, b, c, d \rangle$. Otherwise, in case of an infinite-length trace, the output observer maps to the state with all variables at $\top$.
  In other words, the output observer abstracts away the value of variables but $\texttt{risk}$, our output variable.
  Note that, even though \refprog{landing-alarm-system} always terminates, we need to take into account that the input parameter of the output observer $\outputobs$ is either the final state or $\statebottom$.
  \reffig{output-observer-landing} shows the traces generated by \refprog{landing-alarm-system} where the output values are abstracted by $\outputobs$.
\end{example}
\begin{marginfigure}[*-16]
  \centering
  \begin{tikzpicture}
    \node (linit) at (0,3) {$\locinit$};
    \node (lend) at (2,3) {$\loc{10}$};
    \draw[->] (linit) -- (lend);

    % Define the positions of the nodes
    \node (-41) at (0,2.5) {${\tuple{-4}{1}}$};
    \node (-42) at (0,2) {${\tuple{-4}{2}}$};
    \node (-43) at (0,1.5) {${\tuple{-4}{3}}$};
    \node (11) at (0,1) {${\tuple{1}{1}}$};
    \node (12) at (0,0.5) {${\tuple{1}{2}}$};
    \node (13) at (0,0) {${\tuple{1}{3}}$};

    \node (3) at (2,2) {${\langle 3 \rangle}$};
    \node (2) at (2,1.5) {${\langle 2 \rangle}$};
    \node (1) at (2,1) {${\langle 1 \rangle}$};
    \node (0) at (2,0.5) {${\langle 0 \rangle}$};

    % Draw the edges
    \draw[->] (-41) -- (3);
    \draw[->] (-42) -- (3);
    \draw[->] (-43) -- (3);

    \draw[->] (11) -- (0);
    \draw[->] (12) -- (1);
    \draw[->] (13) -- (2);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.7) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\outputsemanticsnoparam\semanticsof{\texttt{landing\_alarm\_system}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of the \refprog{landing-alarm-system}.}
\labfig{output-observer-landing}
\end{marginfigure}

\begin{example}
  Originally introduced by \sidetextcite[*-4.5]{Giacobazzi2018}, the output observer $\outputobs$ should deal with any possible abstraction an end-user of the framework might want to use.
  For example, one could be interested in the parity of the output value.
  In this case, the output observer $\outputobs$ could be defined as:
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \mod 2 \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  \begin{marginfigure}[*-11]
    \centering
    \begin{tikzpicture}
      \node (linit) at (0,3) {$\locinit$};
      \node (lend) at (2,3) {$\loc{10}$};
      \draw[->] (linit) -- (lend);

      % Define the positions of the nodes
      \node (-41) at (0,2.5) {${\tuple{-4}{1}}$};
      \node (-42) at (0,2) {${\tuple{-4}{2}}$};
      \node (-43) at (0,1.5) {${\tuple{-4}{3}}$};
      \node (11) at (0,1) {${\tuple{1}{1}}$};
      \node (12) at (0,0.5) {${\tuple{1}{2}}$};
      \node (13) at (0,0) {${\tuple{1}{3}}$};

      \node (odd) at (2,1.5) {${\langle 1 \rangle}$};
      \node (even) at (2,1) {${\langle 0 \rangle}$};

      % Draw the edges
      \draw[->] (-41) -- (odd);
      \draw[->] (-42) -- (odd);
      \draw[->] (-43) -- (odd);

      \draw[->] (11) -- (even);
      \draw[->] (12) -- (odd);
      \draw[->] (13) -- (even);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.7) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\outputsemanticsnoparam\semanticsof{\texttt{landing\_alarm\_system}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of the \refprog{landing-alarm-system} with the parity abstraction.}
  \labfig{parity-landing}
  \end{marginfigure}
  The parity of the value of $\texttt{risk}$ is mapped to the value $0$ if even and $1$ if odd.
  As a result, in our framework we would quantify the impact of the input variables on the parity of the output values.
  \reffig{parity-landing} shows the traces generated by \refprog{landing-alarm-system} where the output values are abstracted by their parity.
\end{example}



Next, we define the impact notions of \outcomesname{}, \rangename{}, and \qusedname{}.

\subsection{The \outcomesname{} Impact Notion}[\outcomesname]
\labsec{outcomes}

Formally $\outcomes\in\tracetype\to\Nplus$ counts the number of different output values reachable by varying the input variables $\definputvariables\in\setof\inputvariables$.
% First, we define step-by-step the quantity $\outcomes$,
% followed by the formal definition.
% We instantiate of this quantity in the context of \refprog*{landing-alarm-system}[*-5] at the end, alongside with some properties of $\outcomesname$.


Intuitively, $\outcomes$ collects,
for any possible input configuration $\definput\in\reducedstate$, all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariables$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, it gathers the output values of this set of traces by means of the output observer $\outputobs$, \ie, $\setdef{
  \outputobs(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
}$. Specifically, this set contains all the output abstractions performed by $\outputobs$.
%
Afterwards, it yields the number of these output values via the cardinality operator $\cardinality{\cdot}$.
Finally, through the supremum operator: $\sup$, it returns the maximum value to ensure that the greatest impact is preserved.
\marginnote[*-13]{
  The supremum operator $\sup$ yields the least upper bound of the given set, that is, the smallest $q$ such that $q$ is greater than or equal to all elements of the set.
}

Formally, the $\outcomesname$ impact notion is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariables\in\setof\inputvariables$ and output observer $\outputobs\in\stateandbottom\to\stateandbottom$,
  the impact notion $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }}
  \end{align*}
\end{definition}


\begin{margintable}[*-9]
  \caption{Overview of the $\outcomesname$ impact notion for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*5]
  \caption{Overview of the $\outcomesname$ impact notion for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{example}
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  Let us revisit the example of the landing alarm system, \cf{} \refprog*{landing-alarm-system}[*-23], with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  For brevity, we refer to such program as program $\landingprogram$.
  The input variables are $\setof\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input space is the set of program states reduced to the input variables, \ie{}
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariables=\texttt{angle}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace (with the intermediate states and the value of all the 4 variables) of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinality{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  \reftab{overview-outcomes-angle} illustrate the steps for $\outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-outcomes-speed} for $\outcomesname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

The notion presented above is monotone in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is based on the observation that, fixed an input state $\retrieveinput\defstate \in \state$, the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ is a subset of $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the cardinality of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')$.
\end{proof}

Let $\boundedoutcomes$ be the $\defbound$-bounded impact property when instantiated with the $\outcomesname$ impact notion.
The output semantics $\outputsemantics$ is sound and complete for validating $\boundedoutcomes$.

\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{right-left-adjoints-for-the-dependency-semantics}
\siderefbox{def}{right-left-adjoints-for-the-output-abstraction-semantics}
\begin{lemma}[$\boundedoutcomes$ Validation]\lablemma{outcomes-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDOUTCOMES \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDOUTCOMES))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\boundedoutcomes$:
  \begin{eqnarray*}
    \lefteqn{\outputabstraction(\dependencyabstraction(\boundedoutcomes)) =} \\
    & \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{
      \sup_{\definput\in\state}
      \cardinality{\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }} \le \defbound
    }
  \end{eqnarray*}
  Note that, all the intermediate states from the trace semantics are abstracted to input-output dependencies.
  The $\outcomesname$ impact notion does not consider the intermediate states, thus the abstraction to dependencies does not affect the validation of the property.
  Furthermore, even handling the output abstraction at the semantic level, by abstracting output states to abstract output states, does not affect the validation of the property as the $\outcomesname$ impact notion already abstracts the output values before counting them.
\end{proof}

\reflemma{outcomes-monotonic} and \reflemma{outcomes-validation} show that the $\outcomesname$ impact notion can be used to certify that a program has impact of \emph{at most} $\defbound$. Moreover, whenever the given program semantics is deterministic, an impact quantity of zero implies that the input variables of interest have no impact on the program outcomes, \ie, the set of input variables is unused.
On the other hand, non-deterministic statements in the program may mislead $\outcomesname$ to account for differences in the program output as a result of variations in the input variables.

\begin{example}\labexample{outcomes-nondeterminism}
Consider the \refprog*{syntactic-vs-semantic-usage}[*-2] used in \refsec{input-data-usage} to illustrate the differences between syntactic and semantic input data usage. Notably: it contains a non-deterministic statement.
Assuming input values are $\N$, the $\outcomesname_{\texttt{x}}$ impact notion (for the variable $\texttt{x}$) is $+\infty$ as for any possible input value, the program can output any value in $\N$.
Due to the non-deterministic statement, the variable \texttt{x} has an infinite impact on the output values, even though the program does not use the input variable \texttt{x}.
\end{example}

Notably, the property $\boundedoutcomes$ is subset-closed, \ie, if a program semantics satisfies the property, then all its subsets also satisfy the property.

\begin{lemma}[$\boundedoutcomes$ is subset-closed]\lablemma{outcomes-subset-closed}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces' \in \BOUNDEDOUTCOMES \ImplieS \defsetoftraces \in \BOUNDEDOUTCOMES
  \end{align*}
\end{lemma}
\begin{proof}
  This proof follows directly from the monotonicity of the $\outcomes$ impact notion, \cf{} \reflemma{outcomes-monotonic}.
\end{proof}

\subsection{The \rangename{} Impact Notion}[\rangename]
\labsec{range}

The quantity $\range\in\tracetype\to\Rposplus$ determines the
size of the range of the output values for all the possible variations in the input variable $\definputvariables\in\setof\inputvariables$.
Let $\defoutputvariables$ be the set of output variables on which the impact is measured.
We are interested in the difference between the extreme values of the variable $\defoutputvariable$.
The difference of extreme values is computed by a distance measure $\distance$ computing the maximum distance between the set of given values. For instance, $\distance$ could be the Euclidean distance.

\begin{margintable}[*-10]
  \caption{Overview of the $\rangename$ impact notion for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 1 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*5]
  \caption{Overview of the $\rangename$ impact notion for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}

\begin{example}
  \labexample{range}
  We revisit again the example of the landing alarm system, program $\landingprogram$.
  Assuming $\definputvariables=\{\texttt{angle}\}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$ as the set of output values for the output variable \texttt{risk}.
%
  Here, we are interested in the difference between the extreme values of the outcomes. Hence, we apply the size function: $\distance(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  Respectively, \reftab{overview-range-angle} illustrates the steps for $\rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-range-speed} for $\rangename_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ impact notion is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given the set of input variables of interest $\definputvariables\in\setof\inputvariables$ and the output variables $\defoutputvariables$,
  the impact notion $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \distance(\setdef{
        \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      })
  \end{align*}
\end{definition}

The above notion employs the auxiliary function $\distance$. For instance, such distance could be instantiated as the Euclidean distance: $\distance(X) \defeq \max_{x, x' \in X} \sqrt{\sum_k (x - x')^2}$ if $X$ is non-empty, otherwise $\distance(X) \defeq 0$. From here, we consider the Euclidean distance as the default distance measure.

We note that also $\rangename$ is monotonic in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\rangename{} is Monotonic]
  \lablemma{range-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \range(\defsetoftraces) \le \range(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{outcomes-monotonic}, the proof is based on the observation that the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ is a subset of the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the size of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\range(\defsetoftraces) \le \range(\defsetoftraces')$.
\end{proof}


Let $\boundedrange$ be the $\defbound$-bounded impact property when instantiated with the $\rangename$ impact notion.
The output semantics $\outputsemantics$ is sound and complete for validating $\boundedrange$.
\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{right-left-adjoints-for-the-dependency-semantics}
\siderefbox{def}{right-left-adjoints-for-the-output-abstraction-semantics}
\begin{lemma}[$\boundedrange$ Validation]\lablemma{range-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDRANGE \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDRANGE))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\boundedrange$:
  \begin{align*}
    & \outputabstraction(\dependencyabstraction(\boundedrange)) = \\
    &\quad
    \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{ \\ & \qquad
      \sup_{\definput\in\state}
      \distance({\setdef{
        \retrieveoutput{\defstate}(\defoutputvariables)
      }{
        \inputoutputtuple{\defstate} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }}) \le \defbound
    }
  \end{align*}
  As noticed before, the $\rangename$ impact notion does not consider the intermediate states and abstracts the output states before applying the size function.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

\reflemma{outcomes-monotonic} and \reflemma{outcomes-validation} show that the $\outcomesname$ impact notion can be used to certify that a program has impact of \emph{at most} $\defbound$. In the present of deterministic systems, an impact quantity of zero implies that the input variable is unused.
Otherwise, similarly to $\outcomesname$, the input variable may have an impact on the program computation even if not used\sidenote{See \refexample{outcomes-nondeterminism} for a similar discussion of the \outcomesname{} impact notion when applied to programs containing nondeterministic statements.}.

Notably, the property $\boundedrange$ is subset-closed, \ie, if a program semantics satisfies the property, then all its subsets also satisfy the property.

\begin{lemma}[$\boundedrange$ is subset-closed]\lablemma{range-subset-closed}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces' \in \BOUNDEDRANGE \ImplieS \defsetoftraces \in \BOUNDEDRANGE
  \end{align*}
\end{lemma}
\begin{proof}
  This proof follows directly from the monotonicity of the $\range$ impact notion, \cf{} \reflemma{range-monotonic}.
\end{proof}

\subsection{The \qusedname{} Impact Notion}[\qusedname]
\labsec{qused}

The quantity $\qused\in\tracetype\to\Nplus$ counts the number of input values for the variables in $\definputvariables\in\setof\inputvariables$ of $\definputvariables$ that are \emph{not} used to produce the outcomes.
Unlike \outcomesname{} and \rangename{} the impact of an input variable is zero \wrt{} \qusedname{} if and only if the input variable is not used to produce any outcome, even in the presence of non-deterministic statements.

Given a set of traces $\defsetoftraces$, for each possible outcome of a trace $\deftrace\in\defsetoftraces$, \qusedname{} collects the traces $\deftrace'\in\defsetoftraces$ that share the same output abstraction, \ie, $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)$. Then, it gathers the set of input values of the variables in $\definputvariables$ that correspond to these traces.
The number of missing input values is obtained by subtracting the set of input values that can produce the outcome $\retrieveoutput\defstate$ from the set of all input values for the variables in $\definputvariables$.
Finally, $\qused$ yields the maximum number of input values that are not used to produce the outcomes.


Formally, the $\qusedname$ impact notion is defined as follows:

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariables\in\setof\inputvariables$,
  the impact notion $\qused\in\tracetype\to\Nplus$ is defined as
  %
  % \begin{eqnarray*}
  %   \qused(\defsetoftraces) \DefeQ
  %   \sup_{\deftrace \in \defsetoftraces}
  %     \spacer\left|
  %       \begin{array}{l}
  %         \setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state} \setminus \\
  %         \quad \setdef{
  %           \retrieveinput{\defseq'}(\definputvariables)
  %           }{
  %             \deftrace' \in \defsetoftraces \LanD
  %                 \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput{\deftrace'})
  %           }
  %       \end{array}
  %     \right|
  % \end{eqnarray*}
  \begin{align*}
    \qused(\defsetoftraces) &\DefeQ \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      } \\
      I_{\deftrace}(\defsetoftraces) &\spacearound= \setdef{
        \retrieveinput{\defseq'}
      }{
        \defseq' \in \defsetoftraces \land
        \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput{\defseq'})
      } \\
      Q_\definputvariables(\defsetofstates) &\spacearound= \setdef{
        \defstate' \in \state
      }{
        \defstate \in \defsetofstates \land
          \defstate' \stateeq{\inputvariableswithoutw} \defstate
      }
  \end{align*}
  where $I_{\deftrace}(\defsetoftraces)$ is the set of input states of traces in $\defsetoftraces$ that share the same output abstraction as $\deftrace$ and $Q_\definputvariables(\defsetofstates)$ is the set of states that are variations from states in $\defsetofstates$ only in the variables $\definputvariables$.
\end{definition}


\begin{example}
  To demonstrate the $\qusedname$ impact notion, we employ four simple programs.
  The first program we consider, \refprog{id}, returns the value of the only input variable $\texttt{x}$ without any modification.
  The second program, \refprog{random}, returns a random value.
  The last two, \refprog{mix1} and \refprog{mix2}, combine together non-deterministic and deterministic statements.
  For simplicity, variables are assumed to range in $\{0, 1, 2\}$.

  \begin{marginlisting}
    \caption{The identity program.}
    \labprog{id}
    \vspace{15pt}
  \begin{lstlisting}[language=customPython]
id(x):
  return x;
 \end{lstlisting}
  \end{marginlisting}
  The trace semantics of \refprog{id} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{id}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\rightarrow\tracetuple{\loc{3}}{\langle 0\rangle},\\
        \tracetuple{\locinit}{\langle 1\rangle}\rightarrow\tracetuple{\loc{3}}{\langle 1\rangle},\\
        \tracetuple{\locinit}{\langle 2\rangle}\rightarrow\tracetuple{\loc{3}}{\langle 2\rangle}
      \end{array}
    \right\}
  \end{align*}
  \begin{marginfigure}[*-1.5]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{3}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{id}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{id}.}
  \labfig{id-traces}
  \end{marginfigure}
  As explained above, for any $\deftrace\in \tracesemanticsnoparam\semanticsof{\texttt{id}}$ we collect the set of input states that belong to traces $\deftrace'\in\tracesemanticsnoparam\semanticsof{\texttt{id}}$ that share the same output abstraction as $\deftrace$, \cf{} $I_{\deftrace}(\tracesemanticsnoparam\semanticsof{\texttt{id}})$.
  In this case, the set of input states that can produce the outcome $0$ is $\{\tracetuple{\locinit}{\langle 0\rangle}\}$, for the outcome $1$ is $\{\tracetuple{\locinit}{\langle 1\rangle}\}$, and for the outcome $2$ is $\{\tracetuple{\locinit}{\langle 2\rangle}\}$, all singletons.
  Hence, the set of states that are variations, \cf{} $Q_{\{\texttt{x}\}}(I_{\deftrace}(\tracesemanticsnoparam\semanticsof{\texttt{id}}))$, is the complement of each singleton.
  Hence, for the three set of input states, we obtain the values $2, 2, 2$, respectively.
  Thus, $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{id}})=2$, meaning that the input variable $\texttt{x}$ is used.

\begin{marginlisting}[*-3]
  \caption{The random program.}
  \labprog{random}
  \vspace{15pt}
\begin{lstlisting}[language=customPython]
random(x):
  return rand();
  \end{lstlisting}
\end{marginlisting}
  The trace semantics of \refprog{random} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{random}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 1\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 2\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}
      \end{array}
    \right\}
  \end{align*}

  \begin{marginfigure}[*-5]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{3}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (0) -> (out1);
      \draw[->] (0) -> (out2);
      \draw[->] (1) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (1) -> (out2);
      \draw[->] (2) -> (out0);
      \draw[->] (2) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{random}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{random}.}
  \labfig{random-traces}
  \end{marginfigure}
  In this case, any outcome can be produced by any input value, thus the set of input states is $\{\tracetuple{\locinit}{\langle 0\rangle}, \tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$ for all outcomes.
  Since all possible permutations of the variable \texttt{x} are already in each set of input states from outcomes, we obtain the value $0$.
  Thus, $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{random}})=0$, meaning that the input variable $\texttt{x}$ is not used.

  \begin{marginlisting}[*-4]
    \caption{First example combining random and constant value.}
    \labprog{mix1}
    \vspace{25pt}
  \begin{lstlisting}[language=customPython]
mix1(x):
  if x > 0:
    return rand();
  else:
    return 0;
  \end{lstlisting}
\end{marginlisting}
  The trace semantics of \refprog{mix1} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix1}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\rightarrow\tracetuple{\loc{6}}{\langle 0\rangle}, \\
        \tracetuple{\locinit}{\langle 1\rangle}\rightarrow\tracetuple{\loc{6}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 2\rangle}\rightarrow\tracetuple{\loc{6}}{\langle \anyvalue\rangle}
      \end{array}
      \right\}
  \end{align*}
  \begin{marginfigure}[*-2]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{6}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (1) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (1) -> (out2);
      \draw[->] (2) -> (out0);
      \draw[->] (2) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{mix1}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{mix1}.}
  \labfig{mix1-traces}
  \end{marginfigure}
  In this case, the set of input states that can produce the outcome $0$ is $\{\tracetuple{\locinit}{\langle 0\rangle}, \tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$, for the outcome $1$ is $\{\tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$, and for the outcome $2$ is $\{\tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$.
  Respectively, the input state $\tracetuple{\locinit}{\langle 0 \rangle}$ is missing from both sets of input states that can produce the outcomes $1$ and $2$.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix1}})=1$.


  \begin{marginlisting}
    \caption{Second example combining random and constant value.}
    \labprog{mix2}
    \vspace{25pt}
  \begin{lstlisting}[language=customPython]
mix2(x, y):
  if x and y:
    return True
  elif not x and y:
    return rand()
  else:
    return False
 \end{lstlisting}
  \end{marginlisting}
  For this last program we introduce another variable \texttt{y}, we simplify even further the variable to boolean values $\{\true, \false\}$.
  The trace semantics of \refprog{mix2} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix2}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle \true, \true\rangle}\rightarrow\tracetuple{\loc{8}}{\langle \true\rangle}, \\
        \tracetuple{\locinit}{\langle \true, \false\rangle}\rightarrow\tracetuple{\loc{8}}{\langle \false\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{8}}{\langle \true\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{8}}{\langle \false\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \false\rangle}\rightarrow\tracetuple{\loc{8}}{\langle \false\rangle}
      \end{array}
      \right\}
  \end{align*}
  \begin{marginfigure}
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{8}:$};

      % Define the positions of the nodes
      \node (TT) at (0,2) {${\tuple\true\true}$};
      \node (TF) at (1,2) {${\tuple\true\false}$};
      \node (FT) at (2,2) {${\tuple\false\true}$};
      \node (FF) at (3,2) {${\tuple\false\false}$};

      \node (T) at (0.5,0) {${\langle \true \rangle}$};
      \node (F) at (2.5,0) {${\langle \false \rangle}$};

      % Draw the edges
      \draw[->] (TT) -> (T);
      \draw[->] (TF) -> (F);
      \draw[->] (FT) -> (T);
      \draw[->] (FT) -> (F);
      \draw[->] (FF) -> (F);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{mix2}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{mix2}.}
  \labfig{mix2-traces}
  \end{marginfigure}
  In this case, the set of input states that can produce the outcome $\true$ is $\{\tracetuple{\locinit}{\langle \true, \true\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}\}$, for the other outcome $\false$ the set of input states is $\{\tracetuple{\locinit}{\langle \true, \false\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}, \tracetuple{\locinit}{\langle \false, \false\rangle}\}$.
  In case $\definputvariables=\{\texttt{x}\}$, the state $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is missing from the set of input states that can produce the outcome $\false$, obtained by permuting the variable \texttt{x} on the input state $\tracetuple{\locinit}{\langle \false, \true\rangle}$.
  Instead, the set of states $\{\tracetuple{\locinit}{\langle \true, \true\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}\}$ already contains all the possible permutations of the variable \texttt{x}.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix2}})=1$.
  On the other hand, if $\definputvariables=\{\texttt{y}\}$, the states $\tracetuple{\locinit}{\langle \false, \false\rangle}$ and $\tracetuple{\locinit}{\langle \true, \false\rangle}$ are missing from the set of input states that can produce the outcome $\true$. No state is missing from the set of input states that can produce the outcome $\false$.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{y}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix2}})=2$.

  From these examples we notice that the $\qusedname$ impact notion is able to capture that a variable is not used in a program, even in the presence of non-deterministic statements, \cf{} \refprog{random}.
  Moreover, $\qusedname$ also discriminates between different amount of impact from \refprog{id}, \refprog{mix1}, and \refprog{mix2}.
  Indeed, \refprog{id} is, intuitively, the program where the input variable has the highest impact possible as the output is exactly its value, while \refprog{random} the lowest as the output is random.
\end{example}

Next, we show the validation of the $\defbound$-bounded impact property when instantiated with the $\qusedname$ impact notion.
Note the use of the $\ge$ operator\sidenote{Previously, for the \outcomesname{} and \rangename{} impact notions, the $\defbound$-bounded impact property employed the $\le$ comparison operator.} in our property $\boundedqused$. This design choice is due to the fact that the $\qusedname$ impact notion is neither monotonic nor anti-monotonic in the amount of traces in $\defsetoftraces$. Thus, the same way the syntactic dependency analysis consider an under-approximation of dependencies among variables to return a sound result, the static analysis for $\qusedname$ considers an under-approximation of the ``missing'' input values. In detail, it considers an under-approximation of the set of input values $Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)$ for the given set of traces $\defsetoftraces$. This under-approximation may lead to a lower value of $\qusedname$ than the actual value, hence the use of the $\ge$ operator as the concrete bound is always higher.

\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{right-left-adjoints-for-the-dependency-semantics}
\siderefbox{def}{right-left-adjoints-for-the-output-abstraction-semantics}
\begin{lemma}[$\boundedqused$ Validation]\lablemma{qused-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDQUSED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDQUSED))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\boundedqused$:
  \marginnote{
    \begin{align*}
      &I_{\retrieveoutput{\defstate}}(\defsetofdependencies) \spacearound= \\
      &\quad \seTDef{
        \retrieveinput{\defstate'}
      }{
        \inputoutputtuple{\defstate'} \in \defsetofdependencies \land
        \outputobs(\retrieveoutput{\defstate}) = \outputobs(\retrieveoutput{\defstate'})
      } \\
      &Q_\definputvariables(\defsetofstates) \spacearound= \\
      &\quad\setdef{
        \defstate' \in \state
      }{
        \defstate \in \defsetofstates \land
          \defstate' \stateeq{\inputvariableswithoutw} \defstate
      }
    \end{align*}
  }
  \begin{eqnarray*}
    \lefteqn{\outputabstraction(\dependencyabstraction(\boundedqused)) =} \\
    &
    \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{
      \sup_{\inputoutputtuple{\defstate} \in \defsetofdependencies}
    \cardinality*{
        Q_\definputvariables(I_{\retrieveoutput{\defstate}}(\defsetofdependencies)) \setminus I_{\retrieveoutput{\defstate}}(\defsetofdependencies)
      } \le \defbound
    }
  \end{eqnarray*}
  As noticed before, the $\qusedname$ impact notion does not consider the intermediate states and abstracts the output states before any computation.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

The next example shows that $\qusedname$ is neither monotonic nor anti-monotonic in the amount of traces, meaning that, by adding or removing traces from a given set $\defsetoftraces\in\tracetype$ the quantity $\qused(\defsetoftraces)$ may increase or decrease.
Notably, the major consequence is that $\boundedqused$ is not subset-closed. Thus, not all the subsets of a potential over-approximation of the trace semantics satisfy the $\boundedqused$ property. Indeed, there is no guarantee that even the trace semantics itself satisfies the property.
To address this issue, from the result of the abstract analysis we compute an under-approximation of the input values that are definitely missing from the set of input values that can produce the outcomes. This under-approximation provides a lower bound on the $\qusedname$ impact notion, hence the use of the $\ge$ operator in the $\defbound$-bounded impact property.

\begin{example}\labexample{qused-not-monotonic}
In this example, with the identity function on the second component, \cf{} \refprog{id2}, we show that the $\qusedname$ impact notion is neither monotonic nor anti-monotonic in the amount of traces.
Specifically, we consider two input variables with boolean values $\{\true, \false\}$, the \refprog{id2} returns the second component of the input without any modification.
\begin{marginlisting}
  \caption{Identity function on the second component.}
  \labprog{id2}
  \vspace{25pt}
\begin{lstlisting}[language=customPython]
id2(x, y):
  return y
 \end{lstlisting}
\end{marginlisting}
The trace semantics of \refprog{id2} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{id2}}
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}
  \begin{tikzpicture}[scale=0.8]
    \node (linit) at (-0.9,2) {$\locinit:$};
    \node (lend) at (-0.9,0) {$\loc{3}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{id2}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of \refprog{id2}.}
\labfig{id2-traces}
\end{marginfigure}
For the set of traces $\tracesemanticsnoparam\semanticsof{\texttt{id2}}$, we have that $\qusedname_{\{\texttt{x} \}}(\tracesemanticsnoparam\semanticsof{\texttt{id2}})=0$ as no input value is missing from both the sets of input values that can produce the outcomes $\true$ and $\false$. In fact, the variable \texttt{x} is \emph{not used} in the program.
Let us consider the bigger set of traces $\defsetoftraces \supseteq \tracesemanticsnoparam\semanticsof{\texttt{id2}}$:
\begin{align*}
  \defsetoftraces
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}
  \begin{tikzpicture}[scale=0.8]
    % \node (linit) at (-0.9,2) {$\locinit:$};
    % \node (lend) at (-0.9,0) {$\loc{3}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FT) -> (F);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.2) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm] {$\defsetoftraces$};
\end{tikzpicture}
\caption{Graphical representation of $\defsetoftraces$.}
\labfig{defsetoftraces-traces}
\end{marginfigure}
This set of traces could be obtained by the \refprog{mix2}.
In this case, $\qusedname_{\{\texttt{x} \}}(\defsetoftraces)=1$ as the input value $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is missing from the set of input values that can produce the outcome $\false$, \cf, the set $\{ \tracetuple{\locinit}{\langle \true, \false\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}, \tracetuple{\locinit}{\langle \false, \false\rangle} \}$.
Note that, in this case, the variable \texttt{x} is \emph{used} in the program.
Lastly, let us increase again the set of traces to $\defsetoftraces' \supseteq \defsetoftraces$:
\begin{align*}
  \defsetoftraces'
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\rightarrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}[*-6]
  \begin{tikzpicture}[scale=0.8]
    \node (linit) at (-0.9,2) {$\locinit:$};
    \node (lend) at (-0.9,0) {$\loc{6}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TT) -> (F);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FT) -> (F);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{false\_or\_rand}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of \refprog{false-or-rand}.}
\labfig{false-or-rand-traces}
\end{marginfigure}
In this case, $\qusedname_{\{\texttt{x} \}}(\defsetoftraces')=0$ as the input $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is not missing anymore in the set of input values that can produce the outcomes $\false$.
For instance, a program that may generate such a set of traces is the \refprog{false-or-rand}.
\begin{marginlisting}
  \caption{False or random program.}
  \labprog{false-or-rand}
  \vspace{15pt}
\begin{lstlisting}[language=customPython]
false_or_rand(x, y):
  if not y:
    return False
  else:
    return rand()
 \end{lstlisting}
\end{marginlisting}
This example shows that \[\qusedname_{\{\texttt{x} \}}(\tracesemanticsnoparam\semanticsof{\texttt{id2}}) \LE \qusedname_{\{\texttt{x} \}}(\defsetoftraces) \GE \qusedname_{\{\texttt{x} \}}(\defsetoftraces')\] where $\tracesemanticsnoparam\semanticsof{\texttt{id2}} \subseteq \defsetoftraces \subseteq \defsetoftraces'$.
Thus, the $\qusedname$ impact notion is neither monotonic nor anti-monotonic in the amount of traces, as the quantity $\qusedname$ may increase or decrease by adding or removing traces from a given set.
\end{example}





Unlike for the previous impact notions, it holds that, whenever the quantity $\qused(\tracesemantics)$ is 0, the program $\defprogram$ does not use the input variable $\definputvariables$, even in the presence of non-determinism.
Thus, we can establish the following equivalence:

\siderefbox{def}{abstract-unused}
\siderefbox{def}{qused}
\begin{lemma}[Unused Equivalence]\lablemma{qualitative-quantitative-equivalence}
  For all program $\defprogram$, it holds that:
  \begin{gather*}
    \unusediowrapper(\tracesemantics) \IfF \qused(\tracesemantics) = 0
  \end{gather*}
\end{lemma}
\begin{proof}
  To show ($\Rightarrow$) we assume that $\unusediowrapper(\tracesemantics)$.
  As a consequence, we have that any outcome either is not reachable or is reachable from every input value of the variables $\definputvariables$.
  Thus, for any $\deftrace\in\defsetoftraces$, the set of input values that can produce that outcome is the set of all input values, \ie{}, $I_{\deftrace}(\defsetoftraces) = \values$.
  Since we remove from $Q_{\definputvariables}(I_{\deftrace}(\defsetoftraces))$ the set of input values, we obtain a value of 0 for all traces, hence $\qused(\tracesemantics) = 0$.

  To show ($\Leftarrow$) we assume that $\qused(\tracesemanticsnoparam) = 0$.
  By definition, for all $\retrieveoutput\defstate$, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values, otherwise $\qused(\tracesemanticsnoparam)$ would not be 0.
  Thus, for all traces $\deftrace\in\tracesemantics$ and input values $\defvalue\in\values$ such that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, we have that it exists a trace $\deftrace'$ such that $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput{\deftrace})$ and $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, otherwise it would not be possible that the set of input values that can produce any outcome is the set of all input values. Hence, $\unusediowrapper(\tracesemantics)$.
\end{proof}


As a consequence of \reflemma{qualitative-quantitative-equivalence}, we obtain an equivalence between the (un)used property (\refdef*{unused}) and the $\defbound$-bounded impact property (\refdef*{bounded}) instantiated with the $\qusedname$ impact notion:
\[
\neg\unused \spacearound{=} \mathscr{B}_{\qused}^{\ge 1}
\]
meaning that if a program semantics utilizes the variables $\definputvariables$, then it has an impact of at least $1$, and vice versa.

In the rest of this chapter, we present the static analysis to verify the $\defbound$-bounded impact property of a program and show the abstract version of the quantitative measures introduced in this chapter.

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

In this section, we introduce a sound and computable static analysis to verify the $\defbound$-bounded impact property of a program.
The soundness of the approach leverages two elements: (1) a backward abstract semantics, and (2) sound and computable implementations of the quantitative measures \outcomesname{}, \rangename{}, and \qusedname{} (written as $\abstractoutcomesname$, $\abstractrangename$, and $\abstractqusedname$ respectively).


To quantify the usage of the input variables $\definputvariables$, we mostly need to determine the input configurations leading to specific output values.
As our impact notions measure over the reachable output values (more precisely, over their abstraction by $\outputobs$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is a parameter of the analysis and a \emph{good} choice is essential for obtaining a precise and meaningful analysis result.

For each output bucket $\bucket\in\abstractdomain$, where $1 \le j \le n$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
% More formally, the reduction of the output-abstraction semantics $\outputsemanticsnoparam$ to the dependencies with abstraction of a final state in $X$ is defined as:
% \[
%   \reduce[\outputsemanticsnoparam]{X} \DefeQ \setdef{
%     \setdef{
%       \tuple{\retrieveinput\defstate}{\outputobs(\retrieveoutput{\defstate})}\in\defsetofdependencies
%     }{
%       \retrieveoutput{\defstate} \in X
%       }
%   }{
%     \defsetofdependencies\in \outputsemanticsnoparam
%   }
% \]
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote[][*-2]{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemanticsnoparam\in\backwardtype$ which computes the backward semantics $\backwardsemanticsnoparam(\bucket)$ from a given output bucket $\bucket\in\abstractdomain$.
For instance, we could use the backward semantics of \refdef*{backward-semantics} to compute $\backwardsemanticsnoparam(\bucket)$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\outputtype$ employs the concretization of the abstract domain, \cf{} $\abstractdomainconcretization$, to restore all possible dependencies from input states to output values, formally:
\[
  \backwardconcretization(\backwardsemanticsnoparam)\bucket \DefeQ
  \setof{\setdef{
    \inputoutputtuple{\defstate}
  }{
    \retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)
    }
  }
  \]
In words, $\backwardconcretization$ collects all the input-output dependencies from the application of the backward semantics to each output bucket $\bucket$.
Since the abstract semantics may discover more dependencies than the concrete ones, the concretization returns all combination of dependencies.
In such a way, we ensure that the (restriction of the) output-abstraction semantics is a subset of the abstract one.
%
We can thus define the soundness condition for the backward semantics with respect to the reduction of the output-abstraction semantics.

\siderefbox{def}{output-reduction}

\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reducedoutputsemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$ as follows:

\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
\end{definition}


The concretization function $\multiconcretization$ maps the multi-bucket semantics $\multisemanticsnoparam$ from a given set of output buckets $\buckets$ to a set of sets of dependencies in $\outputtype$.
Specifically, for each output bucket $\bucket\in\buckets$, $\multiconcretization$ concretizes the output from $\abstractdomainconcretization(\bucket)$ and the input states from the application of the backward semantics to $\bucket$, \ie, $\abstractdomainconcretization((\multisemantics\buckets)_j)$.
Hence, all the possible input-output dependencies are collected for all buckets.
Lastly, to account for the fact that the abstract semantics may discover more dependencies than the concrete ones, the concretization returns all combinations of dependencies.
\begin{definition}[Multi-Bucket Concretization \texorpdfstring{$\multiconcretization$}{}]\labdef{multi-concretization}
  We define the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\outputtype$ as:
\begin{gather*}
  \multiconcretization(\multisemantics)\buckets \DefeQ
  \setof*{\bigsetjoin_{j\le n} \bigsetdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j) \land{} \\ \retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}}
\end{gather*}
\end{definition}

Next, we show the soundness of the multi-bucket semantics with respect to the output-abstraction semantics.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin\limits_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}
\begin{proof}
  \begin{align*}
    &\vphantom{=} \multiconcretization(\multisemanticsnoparam)\buckets
      && \text{by $\multiconcretization$} \\
    &= \bigsetjoin_{j \le n}\setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemanticsnoparam(\buckets))_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\multisemanticsnoparam$} \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(((\backwardsemanticsnoparam(\bucket[t]))_{t\le n})_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \text{by $\backwardconcretization$} \\
    &= \bigsetjoin_{j \le n} \backwardconcretization(\backwardsemanticsnoparam)\bucket
  \end{align*}
  From \refdef{sound-over-approximation}, we obtain that $\foralldef{j \le n}{\reducedoutputsemanticsnoparam \subseteq \backwardconcretization(\backwardsemanticsnoparam(\bucket))}$.
  Thus, by monotonicity of the union operator over set inclusion, it holds that $\bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam \subseteq \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$. We conclude by:
  \begin{align*}
    \bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam &= \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$} \\
    &= \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by set definition} \\
    &= \reducenoparam{\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$}
  \end{align*}
  \end{proof}

We introduce the concept of \emph{covering} for output buckets to ensure that no potential final state is missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  Let $\outputobs\in\stateandbottom\to\stateandbottom$ be the output observer, we say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[
    \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput{\defstate} \in \stateandbottom} \SubseteQ \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}
  \]
\end{definition}


Whenever the output buckets \textit{cover} the subset of outcomes abstracted by $\outputobs$, $\multisemanticsnoparam$ is a sound over-approximation of $\outputsemanticsnoparam$.

\begin{lemma}\lablemma{sound-approximation-covering}
  Let $\buckets\in\vectorbuckets$ be the set of output buckets such that it covers the subset of potential outcomes of a program $\defprogram$.Then, it holds that the semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$:
  \[
    \outputsemantics \SubseteQ \multiconcretization(\multisemantics)\buckets
  \]
\end{lemma}
\begin{proof}
  Follows directly from \reflemma{sound-over-approximation-multi-bucket} and \refdef{covering}. The covering of the output buckets ensures that no potential final state is missed and thus let the reduction of the output-abstraction semantics unnecessary, as it holds that $\outputsemantics = \reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}$.
\end{proof}



% Additionally, the output buckets needs to be compatible with the concrete outcomes of the program, meaning that two output states cannot map to the same output abstraction if they belong to different output buckets.

% \begin{definition}[Compatibility]\labdef{compatibility}
%   Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
%   \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
% \end{definition}

So far, we presented the semantics $\multisemanticsnoparam$ as an abstraction of the output-abstraction semantics $\outputsemanticsnoparam$ via \reflemma{sound-approximation-covering}.
Next, this section shows the concept of sound implementation of the impact notions.
We expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher (or always lower depending on the ordering operator $\comparison$ of $\genbounded$) than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  For all output buckets $\buckets$ and family of semantics $\multisemanticsnoparam$,
  whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-12], and
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-8],
  \end{enumerate}
  we say that $\impactinstance$ is a \textup{sound implementation} of $\impactwrapper$ if and only if:
  \begin{eqnarray*}
  \impactwrapper(
    \tracesemantics
    ) \ComparisoN \impactinstance(\multisemantics\buckets, \buckets)
  \end{eqnarray*}
\end{definition}

\refdef{sound-implementation} is of importance to ensure that the soundness of the static analysis is preserved when computing the quantity $\defbound$.
We define the concretization of the bound measured by the abstract impact $\impactinstance(\multisemantics\buckets, \buckets)$ via $\boundconcretization \in \valuesinf \to \collectingtype$. It concretizes the set of trace semantics that yield an impact lower (respectively bigger depending on the comparison operator $\comparison$) than the computed bound.
\marginnote[*7]{The operator $\singletonelimination \in \setof A \to \setof A$ removes the set around a singleton set, \ie, $\singletonelimination(\{a\}) = a$.}
\begin{definition}[Concretization of the Measured Quantity]\labdef{concretization-quantitative}
  The concretization of a measured quantity $\defbound$ is $\boundconcretization\in\valuesinf\to\collectingtype$, defined as:
  \begin{eqnarray*}
    \boundconcretization(\defbound) \DefeQ
    \setdef{\defsetofdependencies \in \multiconcretization(\multisemantics)\buckets}{
      \impactwrapper(\defsetoftraces) \ComparisoN \defbound
    }
  \end{eqnarray*}
  where $\defsetoftraces\in\tracetype$ is the set of traces concretized from the dependencies $\defsetofdependencies$:
  \[\defsetoftraces = \singletonelimination(\dependencyconcretization \circ \outputconcretization(\{\defsetofdependencies\}))\]
\end{definition}

% Note that, it holds an equivalence with the $\defbound$-bounded impact property:
% \[
%   \boundconcretization(\defbound) = \genbounded
% \]

% Additionally, we note that the concretization $\boundconcretization$ is monotonically increasing, respectively decreasing, depending on comparison operator $\comparison$.

% \begin{lemma}[Monotonicity of $\boundconcretization$]\lablemma{monotonicity-bound-concretization}
%   Depending on the comparison operator $\comparison$, for all quantities $\defbound',\defbound\in\valuesposplus$ measured by the abstract impact $\impactinstance$ it holds that:
%   \begin{enumerate}[label=(\roman*)]
%     \item $\defbound' \le \defbound \ImplieS \leconcretization(\defbound') \subseteq \leconcretization(\defbound)$
%     \item $\defbound' \ge \defbound \ImplieS \geconcretization(\defbound') \supseteq \geconcretization(\defbound)$
%   \end{enumerate}
% \end{lemma}
% \begin{proof}
%   The proof follows directly from the definition of the concretization $\boundconcretization$. By increasing the bound $\defbound'$, the set of traces in $\leconcretization(\defbound')$ can only increase as we weaken the condition. On the other hand, $\geconcretization(\defbound')$ can only decrease as we strengthen the condition.
% \end{proof}

The concretization $\boundconcretization$ maintains the set of dependencies concretized in turns by $\multiconcretization$ that yield an impact lower (respectively bigger depending on the comparison operator $\comparison$) than the bound computed in the abstract, \cf, $\impactinstance(\multisemantics\buckets, \buckets)$.
Note that, based on the impact notion $\impactwrappername$, the $\defbound$-bounded impact property $\genbounded$ can be subset-closed, meaning that whenever a set of dependencies satisfies the property, all its subsets also satisfy the property.
In this case, it would hold that
\begin{align*}
  \multiconcretization(\multisemantics)\buckets
  \SubseteQ \boundconcretization(\impactinstance(\multisemantics\buckets, \buckets))
\end{align*}
However, this is not always the case.
Indeed, some subsets of dependencies may not satisfy the property $\genbounded$.

\begin{example}
  We are interested in the validation of the property $\boundedqused$, where the impact notion is $\qusedname$ and the comparison operator for quantity bounds is $\ge$.
  Consider an abstract semantics $\multisemanticsnoparam$ that concretize to the following sets of dependencies:
  \begin{align*}
    \multiconcretization(\multisemanticsnoparam) =
    \setof*{\left\{
    \begin{array}{l}
      \tuple{\tracetuple{\locinit}{\langle \true, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \true, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \true\rangle}}{\tracetuple{\loc{3}}{\langle \anyvalue\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}
    \end{array}
    \right\}}
  \end{align*}
  As noted in \refexample{qused-not-monotonic}, the $\qusedname_{\{\texttt{x}\}}$ applied to the biggest set of the concretized dependencies above is 1.
  We assume the abstract impact returns the bound 1.
  In this case, we filter from $\multiconcretization(\multisemantics)$ the set of dependencies that yield an impact lower than the bound 1 as the validation of the property $\boundedqused$ employs the $\ge$ operator.
  For instance, the following set of dependencies is removed:
  \begin{align*}
    \left\{
    \begin{array}{l}
      \tuple{\tracetuple{\locinit}{\langle \true, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \true, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}
    \end{array}
    \right\}
  \end{align*}
  as $\qusedname_{\{\texttt{x}\}}$ is 0 in such case (\cf{} \refexample{qused-not-monotonic}).
\end{example}

The concretization $\boundconcretization$ is used to prove that the abstract semantics $\multisemanticsnoparam$ is sound for proving the property $\genbounded$.


\siderefbox{def}{concretization-quantitative}
\siderefbox{def}{bounded}
\begin{lemma}\lablemma{soundness-boundconcretization}
  A program $\defprogram$ has an impact of at most $\defbound$ (respectively, at least $\defbound$ depending on the comparison operator $\comparison$) only if the set of dependencies concretized from the quantity $\impactwrapper(\tracesemantics)$
  are a subset of the semantics in $\genbounded$.
  \begin{align*}
    &\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(
      \impactwrapper(\tracesemantics)
    ) \SubseteQ \GENBOUNDED \\
    &\qquad\ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}
\begin{proof}
  By hypothesis, we assume that $\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(
    \defbound'
  ) \subseteq \genbounded$ where $\defbound' = \impactwrapper(\tracesemantics)$.
  We have that $\outputsemantics \subseteq \boundconcretization(\defbound')$ by definition of $\boundconcretization$, \cf{} \refdef{concretization-quantitative}.
  Then, by monotonicity of $\outputconcretization$ and $\dependencyconcretization$, \cf{} \refdef{right-left-adjoints-for-the-output-abstraction-semantics} and \refdef{right-left-adjoints-for-the-dependency-semantics} respectively, we have that $\dependencyconcretization(\outputconcretization(\outputsemantics)) \subseteq \dependencyconcretization(\boundconcretization(\defbound'))$.
  Thus, since $\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(
    \defbound'
  ) \subseteq \genbounded$, we have that $\dependencyconcretization(\outputconcretization(\outputsemantics)) \subseteq \genbounded$.
  Depending on the instantiation of the impact notion, we conclude the proof by \reflemma{outcomes-validation} for the $\outcomesname$ impact notion, \reflemma{range-validation} for the $\rangename$ impact notion, and \reflemma{qused-validation} for the $\qusedname$ impact notion.
\end{proof}

Finally, the next result shows that our static analysis is sound when employed to verify the property of interest $\genbounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\comparison\defbound$, then the program $\defprogram$ satisfies the property $\genbounded$, \cf{} $\defprogram \satisfies \genbounded$.

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\genbounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-5], and
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-1.5], and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef*{sound-implementation}[*3],
\end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \comparison \defbound \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{theorem}
\begin{proof}
  From \ref{p:first}, \ref{p:second}, and \ref{p:third}, we have that:
  \begin{align*}
    \impactwrapper(\tracesemantics) \ComparisoN \impactinstance(\multisemantics\buckets, \buckets) \ComparisoN \defbound'
  \end{align*}
  From the hypothesis $\defbound' \comparison \defbound$, we obtain $\impactwrapper(\tracesemantics)\comparison \defbound$.
  By definition of the concretization functions, \cf{} \refdef{right-left-adjoints-for-the-dependency-semantics}, \refdef{right-left-adjoints-for-the-output-abstraction-semantics}, and \refdef{concretization-quantitative} respectively, we have that $\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(\impactwrapper(\tracesemantics)) \subseteq \genbounded$.
  We conclude by \reflemma{soundness-boundconcretization}.
\end{proof}


Next,
we define $\abstractrangename$, $\abstractoutcomesname$, and $\abstractqusedname$
as possible implementations for $\rangename$, $\outcomesname$, and $\qusedname$, respectively.

%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variables $\definputvariables$, that is, the reduction in dimensionality of the abstract element by projecting its image to the reduced variable space.
\begin{example}
In the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainprojecti(\langle\definputvariable \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariable \mapsto [-\infty, +\infty], j \mapsto [2, 4] \rangle$
  removes the constraints related to the variables in $\{\definputvariable\}$.
  Often, whenever a variable maps to $\abstractdomaintop$, or equivalently $[-\infty, +\infty]$, we hide it from the abstract element, \eg, instead of $\langle \definputvariable \mapsto [-\infty, +\infty], j \mapsto [2, 4] \rangle$ we often write $\langle j \mapsto [2, 4] \rangle$.
\end{example}
%
% We define the soundness condition on the project operator to ensure that $\abstractdomainproject(\defstate^\natural)$ represents all the concrete states result of perturbations on the variable $\definputvariables$ from a state represented by an abstract value $\defstate^\natural$.
We define the condition a sound projection operator $\abstractdomainproject$ must satisfy to ensure that no concrete state is missed by the projection.

The projection operator is sound whenever the projection of the variables $\definputvariables$ from the abstract value $\defstate^\natural$ contains all the concrete states that can be obtained by perturbing the variables $\definputvariables$ from a concrete state represented by $\defstate^\natural$.
In fact, we could define the \emph{concrete} project operator $\project\in\setof\state\to\setof\state$ as it follows:
\[
  \project(\defsetofstates) \DefeQ \setdef{\defstate'}{\defstate\in\defsetofstates \land \defstate \stateeq{\definputvariables} \defstate'}
\]

It follows the classic definition of soundness.
\begin{definition}[Sound Projection Operator]\labdef{soundness-project}
  For all abstract states $\defstate^\natural$, the projection of the abstract state $\abstractdomainproject(\defstate^\natural)$ is sound whenever it holds that:
  \[
    \project(\abstractdomainconcretization(\defstate^\natural)) \subseteq \abstractdomainproject(\defstate^\natural)
    \]
\end{definition}

\subsection{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}


The definition of $\abstractoutcomes$ first projects away the input variables $\definputvariables$ from all the given abstract values, then it collects all possible abstract values resulting from the meet operation over any two resulting abstract domain elements.
These intersections represent concrete input configurations where variations on the values of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersect after projections:
\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(\presfrombuckets, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\prefrombucket))_{j\le\numberofbuckets})}
  \end{equation*}
  where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$.
\end{definition}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refdef*{outcomes}[*-5]) since the number of intersecting abstract values is finite and bounded by $n$, the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:

\begin{definition}[\texorpdfstring{$\intersectallfunction$}{Intersect Function}]\labdef{intersect-all-function}
  Given a vector of $\numberofbuckets$ abstract elements $\presfrombuckets\in\vectorbuckets$, we define $\intersectallfunction\in\vectorbuckets\to\setof\N$ as:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction(\presfrombuckets) \DefeQ} \\
    & \setdef{J \subseteq \N}{\forall j\le n, p\le n.~ j\in J \land p\in J \LanD \prefrombucket \abstractdomainmeet \prefrombucket[p]}
  \end{eqnarray*}
\end{definition}


Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidetextcite{Bron1973}.
All together, the abstract implementation $\abstractoutcomes$ returns the value of the maximum among all the sizes of the maximum cliques for each projection.
%

\begin{example}\labexample{abstract-outcomes}
  Consider \refprog*{landing-alarm-system}[*-3] with program states defined as $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$. The output buckets represent the four levels of landing risk: low, medium-low, medium-high, and high. Using the interval domain: $\buckets \in \vectorbuckets[4]$ such that $\bucket[\textup{low}] = \langle \texttt{risk} \mapsto 0 \rangle$, $\bucket[\textup{mid\-/low}] = \langle \texttt{risk} \mapsto 1 \rangle$, $\bucket[\textup{mid\-/high}] = \langle \texttt{risk} \mapsto 2 \rangle$, and $\bucket[\textup{high}] = \langle \texttt{risk} \mapsto 3 \rangle$.
  \nrefdef{covering} is satisfied as the output buckets cover all the possible outcomes of the program for the variable \texttt{risk}.
  We assume the backward analysis to return the following intervals:
  \begin{align*}
    \backwardsemanticsnoparam(\bucket[\textup{low}]) \spacearound{&=} \prefrombucket[\textup{low}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [1, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/low}]) \spacearound{&=} \prefrombucket[\textup{mid\-/low}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [2, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/high}]) \spacearound{&=} \prefrombucket[\textup{mid\-/high}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [2, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{high}]) \spacearound{&=} \prefrombucket[\textup{high}] \spacearound{=} \langle \texttt{angle} \mapsto -4, \texttt{speed} \mapsto [1, 3] \rangle \\
  \end{align*}
  Indeed, the backward analysis over-approximates the concrete semantics as, for example, the input configuration $\texttt{angle} = 1$ and $\texttt{speed} = 3$ does not lead to a low risk of approach.
  We are interested in the input variable \texttt{angle}, thus the projections are:
  \begin{align*}
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]) \spacearound{&=} \langle \texttt{speed} \mapsto [1, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{mid\-/low}]) \spacearound{&=} \langle \texttt{speed} \mapsto [2, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{mid\-/high}]) \spacearound{&=} \langle \texttt{speed} \mapsto [2, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]) \spacearound{&=} \langle \texttt{speed} \mapsto [1, 3] \rangle \\
  \end{align*}
  It is easy to notice that the abstract elements resulting from the projection intersect between each other. Therefore, we obtain that the set of indices of buckets that intersect is:
  \begin{eqnarray*}
  \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]))) ={}} \\
& \setof{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}
\end{eqnarray*}
  The maximum size is $4$ at $\cardinalitynospaces{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}$.
  Therefore, $\abstractoutcomesname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 4$, meaning that variations of the input variable \texttt{angle} may lead to changes of program outcome from four different buckets.
  On the other hand, projecting away the variable \texttt{speed} from the abstract intervals results in:
  \begin{align*}
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{mid\-/low}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{mid\-/high}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]) \spacearound{&=} \langle \texttt{angle} \mapsto -4 \rangle \\
  \end{align*}
  In this case, only a few abstract elements intersect, specifically:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]))) ={}} \\
  & \left\{
    \begin{array}{l}
    \{\textup{low}\}, \{\textup{mid\-/low}\}, \{\textup{mid\-/high}\}, \{\textup{high}\}, \\
    \{\textup{low}, \textup{mid\-/low}\}, \{\textup{low}, \textup{mid\-/high}\},
    \{\textup{mid\-/low}, \textup{mid\-/high}\}\\
    \{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}
    \end{array}
    \right\}
  \end{eqnarray*}
  The maximum clique is of size $3$, \cf{} \cardinalitynospaces{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}}, hence $\abstractoutcomesname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 3$. This means that variations of the input variable \texttt{speed} may lead to changes of program outcome in three different buckets.
\end{example}

In order to prove that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$, we require the output buckets $\buckets$ to be \textit{compatible} with the output observer $\outputobs$.
That is, any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) $, $ \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) $, and $ \bucket \neq \bucket[p]$.
Intuitively, compatibility ensures that the counting intersecting buckets in the abstract does not miss any concrete outcome.
%
\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\stateandbottom$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}
%
Note that, $\outcomes$ is bounded by the number of buckets when the conditions of covering and compatibility hold for the output buckets.
\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the $\numberofbuckets$ output buckets $\buckets\in\vectorbuckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef*{covering}, it holds that
  $\outcomes(\tracesemanticsnoparam) \le n$.
\end{lemma}
\begin{proof}
  We notice that $\outcomes(\tracesemanticsnoparam) \le \cardinalitynospaces{\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\stateandbottom}}$ as the set of outputs for the trace semantics is always bigger than any set of outputs.
  It is easy to note that the cardinality of $\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\stateandbottom}$ is bounded from above by $n$ since any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different outputs, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$ (by compatibility, \cf{} \refdef{compatibility}).
  Where the existence of the two buckets is guaranteed by covering (\cf{} \refdef{covering}).
  Therefore, there are at most $n$ different outputs.
\end{proof}

The next result shows that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$.

\refdef@{outcomes}[*-4]
\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    % \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-3.5],
    \item \label{proof:b1} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*1], and
    \item \label{proof:d} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*5];
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}
\begin{proof}
  We need to prove that
  \begin{gather*}
    \outcomes(\tracesemanticsnoparam) = \sup_{\definput\in\reducedstate}
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput}} \\
    \LE \\
    \abstractoutcomes(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \\
    \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}
  \end{gather*}
  Let $\overline{\definput}\in\reducedstate$ be such that:
  \begin{gather*}
    \sup_{\definput\in\reducedstate}
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput}}
    \spacearound{=} \\
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}}
  \end{gather*}
  Let $\overline{J} \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})$ be such that:
  \begin{gather*}
    \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}
    \spacearound{=}
    \cardinalitynospaces{\overline{J}}
  \end{gather*}
  We need to show that $\cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}} \le \cardinalitynospaces{\overline{J}}$.
  By contradiction, we assume that $\cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}} > \cardinalitynospaces{\overline{J}}$, meaning that the number of distinct output abstraction from states in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ is higher than the number of indices in the abstract. Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{dsa1} there exist output abstractions that are not matched by any output bucket,
    \item \label{dsa2} some output abstractions are matched by the same output bucket, or
    \item \label{dsa3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract.
  \end{enumerate}
  By \ref{proof:b1}, the first case \ref{dsa1} is not possible as covering, \cf{} \refdef{covering}, ensures that all the output abstractions are matched by the output buckets.
  By \ref{proof:b2}, the second case \ref{dsa2} is not possible as compatibility, \cf{} \refdef{compatibility}, ensures that any two output abstractions that produce different outputs belong to different output buckets.
  The third case \ref{dsa3} is not possible by \ref{proof:d} as the soundness of the projection operator ensures that all the concrete states result of perturbations on the variable $\definputvariables$ from a state represented by an abstract value $\defstate^\natural$ are considered in the abstract.
  Therefore, the assumption is false, and we conclude that $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{proof}

\begin{example}
  We show that the result of the abstract implementation $\abstractoutcomes$ in \refexample{abstract-outcomes} is a sound over-approximation of the concrete implementation $\outcomes$.
  \marginnote{
    \[
  \outputobs(\defstate) \DefeQ \left\{\begin{array}{l}
    \langle \top, \top, \top, d \rangle \\
    \qquad \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle \\
    \qquad \text{otherwise}
  \end{array}\right.
  \]
  }
  We assume the output observer $\outputobs$ is defined as in \refexample{output-observer-landing}, where the fourth component of the state represents the value of the output variable \texttt{risk}.
  Indeed, the output buckets of \refexample{abstract-outcomes} are compatible with the output observer $\outputobs$ as any two output states are mapped to different output buckets.
  \marginnote{
    \begin{align*}
      \bucket[\textup{low}] \spacearound{&=} \langle \texttt{risk} \mapsto 0 \rangle \\
      \bucket[\textup{mid\-/low}] \spacearound{&=} \langle \texttt{risk} \mapsto 1 \rangle \\
      \bucket[\textup{mid\-/high}] \spacearound{&=} \langle \texttt{risk} \mapsto 2 \rangle \\
      \bucket[\textup{high}] \spacearound{&=} \langle \texttt{risk} \mapsto 3 \rangle
    \end{align*}}
  As expected by \refthm*{soundness}[*6], the bound computed by the abstract implementation $\abstractoutcomes$ is always greater or equal to the concrete one:
  \begin{align*}
    & \outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 2 \\
    &\qquad\LE \abstractoutcomesname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 4
  \end{align*}
  \begin{align*}
    & \outcomesname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 3 \\
    &\qquad\LE \abstractoutcomesname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 3 \\
  \end{align*}
  where $\landingprogram$ is the program of the landing alarm system, \cf{} \refprog{landing-alarm-system}.
\end{example}


\subsection{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

We define $\abstractrange$ as the maximum distance of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomaindistance\in\abstractdomain\to\valuesposplus$, which returns the size of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.

\begin{example}
  In the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomaindistance(\langle \defvariable \mapsto [2, 4]\rangle) = 2$.
  On the other hand, whenever the input abstract element is unbounded, the size is $+\infty$, \eg, $\abstractdomaindistance(\langle \defvariable \mapsto [0, +\infty]\rangle) = +\infty$.
  % The function $\abstractdomaindistance$ expects only a single variable to be constrained in the abstract domain, or in other words, only one variable is allowed to be not $\top$.
\end{example}

The abstract range $\abstractrange$ first projects away the input variables $\definputvariables$ from all the given abstract values.
Then, it collects all the possible intersections among the projected abstract values.
These intersections represent concrete input configurations where variations on the values of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
All the possible combination of intersections are joined together to find the maximum range of the extreme values of the buckets.

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  Let $\defoutputvariables$ be the output variables of interest.
We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
\begin{align*}
\abstractrange(\presfrombuckets, \buckets) \DefeQ& \max~\seTDef{\abstractdomaindistance(\abstractdomainproject[\defoutputvariables](K))}{K \in I} \\
\text{where}~
I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(\prefrombucket))_{j\le\numberofbuckets})}
\end{align*}
where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$.
\end{definition}

\begin{example}\labexample{abstract-range}
  Similarly to \refexample{abstract-outcomes}, we show the computation of $\abstractrange$ for the program \refprog*{landing-alarm-system}.
  The computation of $\abstractrange$ works as for $\abstractoutcomes$ until the computation of the intersections.
  Hence, we obtain the same projections for the variable \texttt{angle}:
  \begin{align*}
    &\intersectallfunction((\abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]))) ={} \\
  &\quad \setof{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}
  \end{align*}
  Next, $\abstractrangename_{\{\texttt{angle}\}}$ computes the size of the output buckets joined together for any combination of bucket indices.
  The maximum is achieved whenever both the low and high buckets, respectively buckets $\bucket[\textup{low}]$ and $\bucket[\textup{high}]$, are joined together, as they yield the minimum and maximum value for the variable \texttt{risk}. The size of bucket $\bucket[\textup{low}]$ joined with $\bucket[\textup{high}]$ is $3$, \ie, $\abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{high}]) = \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 3] \rangle) = 3$.
  Therefore, $\abstractrangename_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3$.
  On the other hand, projecting away the variable \texttt{speed} from the abstract intervals results in:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]))) ={}} \\
  & \left\{
    \begin{array}{l}
    \{\textup{low}\}, \{\textup{mid\-/low}\}, \{\textup{mid\-/high}\}, \{\textup{high}\}, \\
    \{\textup{low}, \textup{mid\-/low}\}, \{\textup{low}, \textup{mid\-/high}\},
    \{\textup{mid\-/low}, \textup{mid\-/high}\}\\
    \{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}
    \end{array}
    \right\}
  \end{eqnarray*}
  In this case, we obtain the following sizes for the combination of buckets:
  \begin{align*}
    \abstractdomaindistance(\bucket[\textup{low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 0 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 1 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 2 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 3 \rangle) \spacearound{=} 0 \\
    %
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 1] \rangle) \\ \spacearound{&=} 1 \\
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 2] \rangle) \\ \spacearound{&=} 2 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/low}] \abstractdomainjoin \bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [1, 2] \rangle) \\ \spacearound{&=} 1 \\
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/low}] \abstractdomainjoin \bucket[\textup{mid\-/high}])
     \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 2] \rangle) \\ \spacearound{&=} 2
  \end{align*}
  Therefore, $\abstractrangename_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2$.
\end{example}

To prove that $\abstractrange$ is a sound implementation of $\range$, we require the classic soundness condition on the abstract operator $\abstractdomaindistance$, ensuring that the abstract distance is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaindistance$}{Size}]\labdef{soundness-size}
  Given an abstract value $\defstate^\natural\in\abstractdomain$ and the output variables of interest $\defoutputvariables$, it holds that:
  \[\distance(\setdef{\outputobs(\defstate)(\defoutputvariables)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}) \LE \abstractdomaindistance(\defstate^\natural)\]
\end{definition}

The next result shows that the abstract impact $\abstractrange$ is a sound over-approximation of the concrete impact $\range$, \cf{} \refdef*{range}[*-16.2].

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:ab} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-16.7],
    \item \label{proof:ac} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*-12.3],
    \item \label{proof:ad} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*-8.5], and
    \item \label{proof:ae} $\abstractdomaindistance$ is sound, \cf{} \refdef*{soundness-size}[*-4];
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}
\begin{proof}
  We need to prove that
  \begin{gather*}
    \range(\tracesemanticsnoparam) = \sup_{\definput\in\reducedstate}
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariable)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput})
    \LE \\
    \abstractrange(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \max~\setdef{\abstractdomaindistance(K)}{K \in I}
  \end{gather*}
  where $I = \setdef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}$.
  Let $\overline{\definput}\in\reducedstate$ be such that:
  \begin{gather*}
    \sup_{\definput\in\reducedstate}
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput})
    \spacearound{=} \\
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}})
  \end{gather*}
  Let $\overline{K} \in I$ be such that:
  \begin{gather*}
    \max~\setdef{\abstractdomaindistance(K)}{K \in I}
    \spacearound{=}
    \abstractdomaindistance(\overline{K})
  \end{gather*}
  where $\overline{K} = \abstractdomainjoin\seTDef{\bucket}{j\in J}$ and $J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})$.
  We need to show that $\distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}) \le \abstractdomaindistance(\overline{K})$.
  By contradiction, we assume that $\distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}) > \abstractdomaindistance(\overline{K})$, meaning that the size of output abstraction over the variable $\defoutputvariables$ from states in $\tracesemanticsnoparam$ is higher than the size of $\overline{K}$ in the abstract. Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{au1} there exist output abstractions that are not matched by any output bucket,
    \item \label{au2} some output abstractions are matched by the same output bucket,
    \item \label{au3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract, or
    \item \label{au4} the size of the abstract element is not greater than the size of the output abstraction.
  \end{enumerate}
  Similarly to the proof of \reflemma{abstractoutcomes-is-sound}, we can show that the first three cases are not possible by \ref{proof:ab}, \ref{proof:ac}, and \ref{proof:ad}.
  The fourth case \ref{au4} is not possible by \ref{proof:ae} as the soundness of the size operator ensures that the size of the abstract element is always greater than the size of the output abstraction.
  Therefore, the assumption is false, and we conclude that $\abstractrange$ is a sound implementation of $\range$.
\end{proof}

\begin{example}
  Let \texttt{risk} be the output variable of interest.
  The quantities computed by the abstract implementation $\abstractrange$ in \refexample{abstract-range} are sound over-approximations of the concrete implementation $\range$.
  \begin{align*}
    & \rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\textup{landing-alarm-system}}) = 3 \\
    &\qquad\LE \abstractrangename_{\{\texttt{angle}\}}(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = 3
  \end{align*}
  \begin{align*}
    & \rangename_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\textup{landing-alarm-system}}) = 2 \\
    &\qquad\LE \abstractrangename_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2
  \end{align*}
  as expected by \refthm*{soundness}[*-4].
\end{example}

\subsection{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

We define $\abstractqused$ as the number of input values that are missing from perturbation to the input variables $\definputvariables$ to reach the same outcomes.

Specifically, $\abstractqused$ first computes the input values of the variable in $\definputvariables$ that are missing coming from the same output bucket.
These values represent missing partial input configurations that the concrete impact notion $\qused$ may count.
To compute the number of missing (total) input configurations, we multiply the number of missing input values for the number of possible values of the other input variables.
This number of possible values of the other input variables is computed by projecting away all the variables but one from the abstract element and then applying the abstract counting operator $\abstractdomaincount$ from the whole input space $\abstractdomaintop\in\abstractdomain$.
The result is a measure of the influence of the input variables on the output of the program, \ie, the number of input configurations that may lead to different outcomes.
\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(\presfrombuckets, \buckets) \DefeQ& \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaintop \setminus \prefrombucket)) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{align*}
  where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$ and $l$ is the total number of input values a variable takes:
  \begin{align*}
    l_{\defvariable} \DefeQ& \abstractdomaincount(\abstractdomainproject[\inputvariables \setminus \{\defvariable\}](\abstractdomaintop))
  \end{align*}
\end{definition}

\begin{example}\labexample{abstract-qused}
  We show the computation of $\abstractqused$ for the program \refprog*{landing-alarm-system}.
  For the sake of the example, we consider as abstract domain the set of points for each variable, otherwise with the use of interval abstract domain, the result would be too imprecise.
  The backward analysis returns the following set of points:
  \begin{align*}
    \backwardsemanticsnoparam(\bucket[\textup{low}]) \spacearound{&=} \prefrombucket[\textup{low}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/low}]) \spacearound{&=} \prefrombucket[\textup{mid\-/low}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/high}]) \spacearound{&=} \prefrombucket[\textup{mid\-/high}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{high}]) \spacearound{&=} \prefrombucket[\textup{high}] \spacearound{=} \langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle
  \end{align*}
  We are interested in the impact of the input variable \texttt{angle}, hence we project away the other variables from the complement of the given abstract intervals, obtaining:
  \begin{align*}
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \emptyset\rangle) \spacearound{=}\abstractdomainbottom \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{angle} \mapsto \{-4\} \rangle \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{angle} \mapsto \{-4\} \rangle \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{high}]) \spacearound{=} \abstractdomainbottom
  \end{align*}
  Then, $\abstractqusedname_{\{\texttt{angle}\}}$ counts the number of input configurations:
  \begin{align*}
    \abstractdomaincount(\abstractdomainbottom) \spacearound{&=} 0 \\
    \abstractdomaincount(\langle \texttt{angle} \mapsto \{-4\} \rangle) \spacearound{&=} 1
  \end{align*}
  This value has to be multiplied by the number of possible values for the other input variable \texttt{speed}, which is $3$.
  The total number of missing input configurations is $3$ for the variable \texttt{angle}, hence $\abstractqusedname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3$.
  On the other hand, when interested in the variable \texttt{speed} we project away the variable \texttt{angle} from the abstract intervals, obtaining:
  \begin{align*}
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \emptyset\rangle) \spacearound{=}\abstractdomainbottom \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{speed} \mapsto \{1\} \rangle \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{speed} \mapsto \{1\} \rangle \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaintop \setminus \prefrombucket[\textup{high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{high}]) \spacearound{=} \abstractdomainbottom
  \end{align*}
  Then, $\abstractqusedname_{\{\texttt{speed}\}}$ counts the number of input configurations:
  \begin{align*}
    \abstractdomaincount(\abstractdomainbottom) \spacearound{&=} 0 \\
    \abstractdomaincount(\langle \texttt{speed} \mapsto \{1\} \rangle) \spacearound{&=} 1 \\
  \end{align*}
  As before, we multiply such value by the number of possible values for the other input variable \texttt{angle}, \cf{} 2.
  The total number of missing input configurations is then $2$ for the variable \texttt{speed}, hence $\abstractqusedname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2$.
\end{example}

To prove that $\abstractqused$ is a sound implementation of $\qused$, we require the sound soundness condition on the abstract operator $\abstractdomaincount$, ensuring that the abstract count is always lower than the concrete one.
This requirement comes from the comparison operator $\ge$ in the property $\boundedqused$.
Note that, the concrete counterpart of the abstract $\abstractdomaincount$ is the cardinality operator $\cardinalitynospaces{\cdot}$.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaincount$}{Count}]\labdef{soundness-count}
  Given an abstract value $\defstate^\natural\in\abstractdomain$ and the set of input variables of interest $\definputvariables\in\setof\inputvariables$, it holds that:
  \[\cardinality{\setdef{\retrieveinput{\defstate}(\definputvariables)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}} \GE \abstractdomaincount(\defstate^\natural) \]
\end{definition}

The next result shows that the abstract impact $\abstractqused$ is a sound over-approximation of the concrete impact $\qused$, \cf{} \refdef*{qused}[*-5].

\begin{lemma}[$\abstractqused$ is a Sound Implementation of $\qused$]\lablemma{abstractqused-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{pp1} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-2.5],
    \item \label{pp2} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*2],
    \item \label{pp3} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*6], and
    \item \label{pp4} $\abstractdomaincount$ is sound, \cf{} \refdef*{soundness-count}[*10.8];
  \end{enumerate}
  then, $\abstractqused$ is a sound implementation of $\qused$.
\end{lemma}
\begin{proof}
  We need to prove that
    \begin{gather*}
      \qused(\tracesemanticsnoparam) \DefeQ
      \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      } \\
    \GE \\
    \abstractqused(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaintop \setminus \prefrombucket)) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{gather*}
  Let $\overline{\defseq}\in\tracesemanticsnoparam$ be such that:
  \begin{gather*}
    \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      }
    \spacearound{=} \\
    \cardinality{
        Q_\definputvariables(I_{\overline{\deftrace}}(\defsetoftraces)) \setminus I_{\overline{\deftrace}}(\defsetoftraces)
      }
  \end{gather*}
  Let $\overline{j} \le \numberofbuckets$ be such that:
  \begin{gather*}
    \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaintop \setminus \prefrombucket)) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
    \spacearound{=}
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaintop \setminus \prefrombucket[\overline{j}])) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{gather*}
  By contradiction, we assume that $\cardinality{
    Q_\definputvariables(I_{\overline{\deftrace}}(\defsetoftraces)) \setminus I_{\overline{\deftrace}}(\defsetoftraces)
  } < \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaintop \setminus \prefrombucket[\overline{j}])) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}$, meaning that the number of missing input configurations is lower than the number of missing input values for the variable $\definputvariables$ coming from the same output bucket.
  Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{qq1} there exist output abstractions that are not matched by any output bucket,
    \item \label{qq2} some output abstractions are matched by the same output bucket,
    \item \label{qq3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract, or
    \item \label{qq4} counting the number of input configurations in the abstract is not greater than the number of input configurations in the concrete.
  \end{enumerate}
  Again, we can show that the first three cases are not possible by hypothesis \ref{pp1}, \ref{pp2}, and \ref{pp3}. By hypothesis \ref{pp4}, the soundness of the count operator ensures that the number of input configurations in the abstract is always greater than the number of input configurations in the concrete. Therefore, the assumption is false, and we conclude that $\abstractqused$ is a sound implementation of $\qused$.
\end{proof}


\begin{example}
  The quantities computed by the abstract implementation $\abstractqused$ in \refexample{abstract-qused} are sound over-approximations of the concrete implementation $\qused$:
  \begin{align*}
    & \qusedname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 3 \\
    &\qquad\GE \abstractqusedname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3
  \end{align*}
  \begin{align*}
    & \qusedname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 2 \\
    &\qquad\GE \abstractqusedname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2
  \end{align*}
  as expected by \refthm*{soundness}, where $\landingprogram$ is the program of the landing alarm system, \cf{} \refprog{landing-alarm-system}.
  In this case, the bound computed in the abstract is the same as the concrete one, as the abstract domain is precise enough to capture the exact number of missing input configurations.
\end{example}

\section{Summary}
\labsec{quantitative-input-data-usage-summary}

In this chapter, we introduced the quantitative measures $\outcomes$, $\range$, and $\qused$ to quantify the impact of input variables on the output of a program.
We developed a theoretical framework to verify the $\defbound$-bounded impact property of a program and showed the abstract version of the quantitative measures.
In the next chapter, we show how we handle the quantification of input usage and bias in the context of neural network models.
Afterwards, \refch{extensional-eval} presents the evaluation of the quantitative measures on a set of use cases.
