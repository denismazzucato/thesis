%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}

% \begin{itemize}
%   \item $\sup$ and $\inf$ operators;
%   \item $\length$ function;
%   \item abstract domain $\abstractdomain$
%   \item backward reachability state abstract semantics $\backwardsemanticsnoparam$.
% \end{itemize}

In this chapter, we present the quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define a few quantitative measures of input variables' impact on the program outcomes.
Then, we formalize the theoretical framework to verify the quantitative impact property of a program.
At the end, we present the abstract version of the quantitative measures and show how they can be used to verify the quantitative impact property of a program.
In the next chapters, we will present an adaptation of this quantitative notion to the context of neural network and timing side-channel attacks.

\emph{Dans ce chapitre, nous présentons la notion quantitative d'utilisation des données d'entrée, en étendant la définition introduite dans le chapitre précédent. Nous définissons quelques mesures quantitatives de l'impact des variables d'entrée sur les résultats du programme. Ensuite, nous formalisons le cadre théorique pour vérifier la propriété d'impact quantitatif d'un programme. À la fin, nous présentons la version abstraite des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier la propriété d'impact quantitatif d'un programme. Dans les prochains chapitres, nous présenterons une adaptation de cette notion quantitative au contexte des réseaux neuronaux et des attaques par canal auxiliaire temporel.}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}


\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as the amount of input data that influences the program outcomes.
To this end, we develop the \emph{$\defbound$-bounded impact property} $\genbounded$ as the set of program semantics whose input variable $\definputvariable\in\inputvariables$ has an impact on the program outcomes bounded by $\defbound\in\valuesposplus$.
\marginnote{
  The set $\valuesposplus$ contains non-negative numerical values enhanced with $+\infty$.
}
We employ the general notion of an \emph{impact definition}
\[\impactwrapper\in\tracetype\to\valuesposplus\]
to quantify the impact of the input variable $\definputvariable$ on the outcome from a given program semantics.


\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariable\in\variables$ the input variable of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact definition, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where the comparison operator $\comparison$ is either $\le$ or $\ge$.
\end{definition}

We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow further abstractions of computable semantics to return an always greater, or respectively an always smaller, impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$, formally:
  \begin{align*}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align*}
\end{remark}

Next, we instantiate the general definition $\impactwrappername$ with the impact notions \outcomesname{}, \rangename{}, and \qusedname{}. These notions characterize the impact of the input variables each differently. Mostly, \outcomesname{} measures the number of different outcomes, \rangename{} quantify the length of outcome values, and \qusedname{} counts the number of input values used to produce the outcomes.
To this end, these definitions employ the concept of output abstraction with a further restriction on the observed outcomes. We expect the output observer $\outputobs$ (\refdef*{output-observer}) to return a quantifiable element, \ie{}, a value in $\valuesinf$.
An output observer $\outputobs$ that returns a quantifiable element is called an \emph{output descriptor}.

\begin{definition}[Output Descriptor]
  \labdef{output-descriptor}
  An \textup{output descriptor} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
\end{definition}

The above output descriptor $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
We leverage this output descriptor to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.

\begin{example}
  Consider the \refprog*{landing-alarm-system} for the landing alarm system with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and use $\state$ as set of tuples instead of a map between variables and values, the two views are equivalent.
  The output descriptor is instantiated with
  \[
  \outputobs(x) \DefeQ \begin{cases}
    d & \text{if } x = \langle a, b, c, d \rangle \\
    +\infty & \text{otherwise}
  \end{cases}
  \]
  As a result, the output descriptor $\outputobs$ returns the value of the variable $\texttt{risk}$ when the last state of the trace is $\langle a, b, c, d \rangle$. Otherwise, in case of an infinite-length trace, the output descriptor returns $+\infty$.
  In other words, we are interested in the value of $\texttt{risk}$ for terminating traces.
\end{example}

\begin{example}
  Originally introduced in \sidetextcite{Giacobazzi2018}, the output descriptor $\outputobs$ should deal with any possible abstraction an end-user of the framework might want to use.
  For example, one could be interested in the parity of the output value.
  In this case, the output descriptor $\outputobs$ could be defined as:
  \[
  \outputobs(x) \DefeQ \begin{cases}
    d \mod 2 & \text{if } x = \langle a, b, c, d \rangle \\
    +\infty & \text{otherwise}
  \end{cases}
  \]
  The parity of the value of $\texttt{risk}$ is mapped to the value $0$ if even and $1$ if odd.
  As a result, our framework is able to quantify the impact of the input variables on the parity of the output values.
\end{example}

Next, we define the impact definitions of \outcomesname{}, \rangename{}, and \qusedname{}.

\section{The \outcomesname{} Impact Definition}[\outcomesname]
\labsec{outcomes}

Formally $\outcomes\in\tracetype\to\Nplus$ counts the number of different output values reachable by varying the input variable $\definputvariable\in\inputvariables$.
First, we define step-by-step the quantity $\outcomes$,
followed by the instantiation of this quantity within the context of example of \refprog*{landing-alarm-system}[*-12].
We present the formal definition at the end.


Intuitively,
for any possible input configuration $\definput\in\reducedstate$, we collect all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariable$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, we collect the output values of this set of traces by means of the output descriptor $\outputobs$, \ie, $\setdef{
  \outputobs(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$. Specifically, this set contains all the output readings performed by $\outputobs$.
%
Afterwards, we extract the number of elements via the cardinality operator $\cardinality{\cdot}$.
Finally, we iterate through each input configuration $\definput$ and return the maximum value to ensure the greatest impact is preserved.

\begin{example}[Landing Alarm System]
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  \begin{margintable}[*-12]
    \caption{Overview of the $\outcomesname$ impact definition for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
    \labtab{overview-outcomes-angle}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{c|c|c}
      \textsc{Input} & \textsc{Traces} & \outcomesname \\
      \hline
      \hline
      $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 2 \\
      \hline
      \hline
    \end{tabular}}
  \end{margintable}
  \begin{margintable}[*2]
    \caption{Overview of the $\outcomesname$ impact definition for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
    \labtab{overview-outcomes-speed}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{c|c|c}
      \textsc{Input} & \textsc{Traces} & \outcomesname \\
      \hline
      \hline
      $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
      \hline
      $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
      \hline
      $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
      \hline
      \hline
    \end{tabular}}
  \end{margintable}
  Let us revisit the example of the landing alarm system, with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  The input variables are $\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input configurations are
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariable=\texttt{angle}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinality{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  Respectively, \reftab{overview-outcomes-angle} illustrate the steps for $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-outcomes-speed} for $\outcomesname_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

Formally, the $\outcomesname$ impact definition is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
      }}
  \end{align*}
\end{definition}

We note that the above definition is monotone in the amount of traces provided as input.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is based on the observation that the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
  }$ is a subset of the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the cardinality of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')$.
\end{proof}

We show the validation of the $\defbound$-bounded impact property when applied to the $\outcomesname$ impact definition.

\begin{theorem}\labthm{outcomes-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\outcomes$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputvaluessemantics \subseteq \outputvaluesabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}
\begin{proof}
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\outcomesname$ impact definition:
  \begin{eqnarray*}
    \lefteqn{\outputvaluesabstraction(\dependencyabstraction(\bounded)) =} \\
    & \setdef{
      \defsetofdependencies \in \outputvaluestype
    }{
      \sup_{\definput\in\state}
      \cardinality{\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
      }} \le \defbound
    }
  \end{eqnarray*}
  As you can notice, all the intermediate states from the trace semantics are abstracted to input-output dependencies.
  The $\outcomesname$ impact definition does not consider the intermediate states, thus the abstraction to dependencies does not affect the validation of the property.
  Furthermore, even handling the output abstraction at the semantic level, by abstracting output states to output values, does not affect the validation of the property as the $\outcomesname$ impact definition already abstracts the output values before counting them.
\end{proof}

\section{The \rangename{} Impact Definition}[\rangename]
\labsec{range}

The quantity $\range\in\tracetype\to\Rposplus$ determines the
length of the range of output values from all the possible variations in the input variable $\definputvariable\in\inputvariables$.


\begin{example}[Landing Alarm System]
  \labexample{range}
  \begin{margintable}
    \caption{Overview of the $\rangename$ impact definition for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
    \labtab{overview-range-angle}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{c|c|c}
      \textsc{Input} & \textsc{Traces} & \rangename \\
      \hline
      \hline
      $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 3 \\
      \hline
      $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 1 \\
      \hline
      $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 3 \\
      \hline
      $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
      \hline
      $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 1 \\
      \hline
      \hline
    \end{tabular}}
  \end{margintable}
  \begin{margintable}[*14]
    \caption{Overview of the $\rangename$ impact definition for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
    \labtab{overview-range-speed}
    \resizebox{\textwidth}{!}{
    \begin{tabular}{c|c|c}
      \textsc{Input} & \textsc{Traces} & \rangename \\
      \hline
      \hline
      $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
      \hline
      $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
      \hline
      $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
      \hline
      $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
      \hline
      \hline
    \end{tabular}}
  \end{margintable}
  We revisit again the example of the landing alarm system.
  Assuming $\definputvariable=\texttt{angle}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$.
%
  Here, we apply the function $\length$, hence $\length(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  Respectively, \reftab{overview-range-angle} illustrates the steps for $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-range-speed} for $\rangename_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ quantity is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \length(\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
      })
  \end{align*}
\end{definition}

We note that also $\rangename$ is monotonic in the amount of traces.

\begin{lemma}[\rangename{} is Monotonic]
  \lablemma{range-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \range(\defsetoftraces) \le \range(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{outcomes-monotonic}, the proof is based on the observation that the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
  }$ is a subset of the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the length of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\range(\defsetoftraces) \le \range(\defsetoftraces')$.
\end{proof}


We show the validation of the $\defbound$-bounded impact property when applied to the $\rangename$ impact definition.

\begin{theorem}\labthm{range-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\range$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}
\begin{proof}
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\rangename$ impact definition:
  \begin{align*}
    & \outputvaluesabstraction(\dependencyabstraction(\bounded)) = \\
    &\quad
    \setdef{
      \defsetofdependencies \in \outputvaluestype
    }{ \\ & \qquad
      \sup_{\definput\in\state}
      \length({\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
      }}) \le \defbound
    }
  \end{align*}
  As noticed before, the $\rangename$ impact definition does not consider the intermediate states and abstracts the output states before applying the length function.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

\section{The \qusedname{} Impact Definition}[\qusedname]
\labsec{qused}

The quantity $\qused\in\tracetype\to\Nplus$ counts the number of input values that are not used to produce the outcomes.
This definition is of significant importance as it natively handles non-deterministic systems.

For each possible outcome state $\retrieveoutput\defstate\in\state$ and trace $\deftrace\in\defsetoftraces$ that holds the same output abstraction, \ie{} $\outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput\defstate)$, we collect the set of input values of $\definputvariable$ that can produce this outcome $\retrieveoutput\defstate$.
More specifically, we collect the set of input values that belong to traces $\deftrace'$ that have the same output abstraction as $\deftrace$, \ie{} $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)$, and are a variation of $\deftrace$ on the input variables $\inputvariableswithouti$.
Then, we obtain the number of missing input values by subtracting the set of all input values from the set of input values that can produce the outcome $\retrieveoutput\defstate$.
We return the maximum number of input values that are not used to produce the outcomes.

\begin{marginlisting}[*1]
  \caption{The identity program.}
  \labprog{id}
  \vspace{\lineheight}
\begin{lstlisting}
id(x):
  return x;
\end{lstlisting}
\end{marginlisting}
\begin{marginlisting}[*5]
  \caption{The random program.}
  \labprog{random}
  \vspace{\lineheight}
\begin{lstlisting}
random(x):
  return rand();
\end{lstlisting}
\end{marginlisting}
\begin{marginlisting}[*9]
  \caption{Combining random and constant value.}
  \labprog{mix}
  \vspace{2\lineheight}
\begin{lstlisting}
custom(x):
  if x > 0:
    return rand();
  else:
    return 0;
\end{lstlisting}
\denis{fix lineheight between programs and captions}
\end{marginlisting}
\begin{example}
  To explain the $\qusedname$ impact definition, we employ three simple programs.
  The first program we consider, \refprog{id}, return the only input variable $\texttt{x}$ without any modification.
  The second program, \refprog{random}, returns a random value.
  The last one, \refprog{mix}, returns a random value if the input variable $\texttt{x}$ is greater than $0$, otherwise it returns $0$.
  We assume that the output descriptor $\outputobs$ returns the value of the return statement.
  For simplicity, the input space is $\state=\setdef{\langle x \rangle}{x\in\{0, 1, 2\}}$ and the input variable is $\texttt{x}$, thus the set of input values is $\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state} = \{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$ of cardinality $3$.
  The trace semantics of \refprog{id} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{id}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle 0\rangle,
        \langle 1\rangle\rightarrow\langle 1\rangle,
        \langle 2\rangle\rightarrow\langle 2\rangle
    \right\}
  \end{align*}
  As explained above, for any $\deftrace\in \tracesemanticsnoparam\semanticsof{\texttt{id}}$ we collect the set of input values that belong to traces $\deftrace'\in\tracesemanticsnoparam\semanticsof{\texttt{id}}$ that share the same output abstraction as $\deftrace$.
  In this case, the set of input values that can produce the outcome $0$ is $\{\langle 0\rangle\}$, for the outcome $1$ is $\{\langle 1\rangle\}$, and for the outcome $2$ is $\{\langle 2\rangle\}$, all singletons.
  Hence, by subtracting the set of all input values, of cardinality $3$, from the set of input values that can produce the outcomes, we obtain the value $2$ for the three set of traces. Thus, $\qused(\tracesemanticsnoparam\semanticsof{\texttt{id}})=2$, meaning that the input variable $\texttt{x}$ is used.
%
  The trace semantics of \refprog{random} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{random}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 1\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 2\rangle\rightarrow\langle \anyvalue\rangle
    \right\}
  \end{align*}
  In this case, any outcome can be produced by any input value, thus the set of input values is $\{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$ for all outcomes.
  By subtracting the set of all input values from the set of input values that can produce the outcomes, we obtain the value $0$.
  Thus, $\qused(\tracesemanticsnoparam\semanticsof{\texttt{random}})=0$, meaning that the input variable $\texttt{x}$ is not used\sidenote{As we will see later, a value of $0$ for $\qusedname$ means that the input variable is not used.}.
  %
  The trace semantics of \refprog{mix} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle 0\rangle,
        \langle 1\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 2\rangle\rightarrow\langle \anyvalue\rangle
    \right\}
  \end{align*}
  In this case, the set of input values that can produce the outcome $0$ is $\{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$, for the outcome $1$ is $\{\langle 1\rangle, \langle 2\rangle\}$, and for the outcome $2$ is $\{\langle 1\rangle, \langle 2\rangle\}$.
  By subtracting the set of all input values from the set of input values that can produce the outcomes, we obtain the value $0, 1, 1$, respectively.
  Thus, we yield the highest value, obtaining $\qused(\tracesemanticsnoparam\semanticsof{\texttt{custom}})=1$.
\end{example}

Formally, the $\qusedname$ quantity is defined as follows:

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\qused\in\tracetype\to\Nplus$ is defined as
  %
  \marginnote[*2]{Note that, $\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state}$ is the set of all input values.}
  \begin{eqnarray*}
    \qused(\defsetoftraces) \DefeQ
    \sup_{\retrieveoutput\defstate \in \stateandbottom}
      \spacer\left|
        \begin{array}{l}
          \setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state} \setminus \\
          \quad \bigsetdef{
            \retrieveinput{\defseq'}(\definputvariable)
            }{
              \deftrace' \in \defsetoftraces \LanD \\
              \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD \\
              \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
            }
        \end{array}
      \right|
  \end{eqnarray*}
\end{definition}

We show that $\qusedname$ is (anti-)monotonic in the amount of traces for non-empty sets of traces.
In fact, $\qused(\emptyset) = \sup \emptyset = 0$ as the set of states is also empty.
On the other hand, the set of traces with at least one trace yields the highest value of $\qusedname$, \ie{} $\cardinalitynospaces{\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state}} - 1$.
Hence, the value of $\qusedname$ always decreases by enlarging the set of traces. Until the set of traces contains all possible traces\sidenote{The set of traces containing all the possible traces can be obtained by the random program, \cf{} \refprog{random}.} and the value of $\qusedname$ is $0$.

\begin{lemma}[\qusedname{} is Anti-Monotonic]
  \lablemma{qused-antimonotonic}
  For any non-empty set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \neq \emptyset \LanD \defsetoftraces \subseteq \defsetoftraces' \ImplieS \qused(\defsetoftraces) \ge \qused(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  We assume the cardinality of input values is $n$ and that $\qused(\defsetoftraces) = \defbound$.
  Let us say that $\defoutput$ is the output value that maximizes $\qused(\defsetoftraces)$, \ie{} $\cardinalitynospaces{\setdef{
    \retrieveinput{\defseq'}(\definputvariable)
    }{
      \deftrace' \in \defsetoftraces \land
      \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\defoutput) \land
      \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
    }} = n - \defbound$.
  By hypothesis that $\defsetoftraces$ is not empty, we have that $\defbound > 0$ since it exists at least one trace satisfying the above set.
  Otherwise, the $\sup$ operator of an empty set would return $0$ and by adding traces this value would increase.
  The other set of traces $\defsetoftraces'$ contains all the traces of $\defsetoftraces$ and possibly more.
  Thus, $\setdef{
    \retrieveinput{\defseq'}(\definputvariable)
    }{
      \deftrace' \in \defsetoftraces' \land
      \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\defoutput) \land
      \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
    }$ contains, at least, all the input values of the one obtained for $\defsetoftraces$.
    As a consequence, the cardinality can only be bigger or equal to $n - \defbound$.
    The anti-monotonicity follows from the fact that this cardinality is subtracted from the set of all input values.
\end{proof}


Next, We show the validation of the $\defbound$-bounded impact property when applied to the $\qusedname$ impact definition.
Note that, we employ the $\ge$ operator to allow semantics in our property, this choice is forced by the fact that the $\qusedname$ is anti-monotonic.

\begin{theorem}\labthm{qused-validation}
  Whenever $\impactwrapper$ in $\revbounded$ is instantiated with $\qused$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \REVBOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\REVBOUNDED))
  \end{align*}
\end{theorem}
\begin{proof}
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\qusedname$ impact definition:
  \begin{eqnarray*}
    \lefteqn{\outputvaluesabstraction(\dependencyabstraction(\bounded)) =} \\
    &
    \setdef{
      \defsetofdependencies \in \outputvaluestype
    }{
      \sup\limits_{\retrieveoutput\defstate \in \stateandbottom}
      \spacer\left|
        \begin{array}{l}
          \setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state} \setminus \\
          \quad \bigsetdef{
            \retrieveinput{\defseq'}(\definputvariable)
            }{
              \deftrace' \in \defsetoftraces \LanD \\
              \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD \\
              \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
            }
        \end{array}
      \right| \le \defbound
    }
  \end{eqnarray*}
  As noticed before, the $\qusedname$ impact definition does not consider the intermediate states and abstracts the output states before any computation.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}


Differently from the previous impact definitions, it holds that, whenever $\qused(\tracesemanticsnoparam) = 0$, the program does not use the input variable $\definputvariable$, even in the presence of non-deterministic systems.
Thus, we can establish the following equivalence:

\begin{lemma}[Unused Equivalence]\lablemma{qualitative-quantitative-equivalence}
  It holds that:
  \begin{gather*}
    \unusediowrapper(\tracesemanticsnoparam) \IfF \qused(\tracesemanticsnoparam) = 0
  \end{gather*}
\end{lemma}
\begin{proof}
  To show ($\Rightarrow$) we assume that $\unusediowrapper(\tracesemanticsnoparam)$.
  From \refprop*{abstract-unused-property}[*-2] we have that any outcome either is not reachable or is reachable from every input value of the variable $\definputvariable$.
  Thus, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values.
  By subtracting this set from the set of input values that can produce the outcome $\retrieveoutput\defstate$, we obtain the value $0$, concluding that $\qused(\tracesemanticsnoparam) = 0$.
  To show ($\Leftarrow$) we assume that $\qused(\tracesemanticsnoparam) = 0$.
  By definition, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values.
  \denis{to finish}
\end{proof}


As a consequence of \reflemma{qualitative-quantitative-equivalence}, we obtain an equivalence between the unused property (\refdef*{unused}[*-3]) and the $\defbound$-bounded impact property (\refdef*{bounded}) instantiated with the $\qusedname$ impact definition:
\[
\neg\unused \spacearound{=} \mathscr{B}_{\definputvariable}^{\ge 1}
\]
meaning that if a program semantics does not use the variable $\definputvariable$, then it has an impact of at least $1$, and vice versa.
\marginnote[*2]{
  Instantiated with $\qusedname$:
  \begin{eqnarray*}
    \mathscr{B}_{\definputvariable}^{\ge 1} \DefeQ \setdef{\tracesemantics}{\qused(\defsetoftraces) \ge 1}
  \end{eqnarray*}
}

In the rest of this chapter, we present the theoretical framework to verify the $\defbound$-bounded impact property of a program and show the abstract version of the quantitative measures introduced in the previous sections.

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

In this section, we introduce a sound and computable static analysis to verify the $\defbound$-bounded impact property of a program.
The soundness of the approach leverages two elements: (1) the backward abstract semantics (\cf{} \refdef{?}), and (2) sound and computable implementations of the quantitative measures \outcomesname{}, \rangename{}, and \qusedname{}, written as $\abstractoutcomes$, $\abstractrange$, and $\abstractqused$ respectively.


To quantify the usage of an input variable, we need to determine the input configurations leading to specific output values.
As our impact definitions measure over the reachable output values (more precisely, over their abstraction by $\outputobs$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is essential for obtaining a precise and meaningful analysis result.

For each output bucket $\bucket\in\abstractdomain$ where $1 \le j \le n$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
More formally, the reduction of the dependency semantics $\dependencysemanticsnoparam$ (\refdef*{dependency-semantics}[*-2]) to the dependencies with final states in $X$ is defined as:
\[\reduce[\dependencysemanticsnoparam]{X} \DefeQ \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in X}\]
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemanticsnoparam\in\backwardtype$ which computes the backward semantics $\backwardsemanticsnoparam(\bucket)$ from a given output bucket $\bucket\in\abstractdomain$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\setof\pairofstates$ employs the concretization of the abstract domain, \cf{}
$\abstractdomainconcretization$, to restore all possible input-output dependencies, formally:
\[\backwardconcretization(\backwardsemanticsnoparam)\bucket \DefeQ \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}\]
We can thus define the soundness condition for the backward semantics with respect to the reduction of the dependency semantics.


\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reduceddependencysemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$ as follows:

\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
where the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\setof\pairofstates$ is defined as:
\begin{align*}\multiconcretization(\multisemantics)\buckets \DefeQ \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
\end{align*}
\end{definition}

Next, we show the soundness of the multi-bucket semantics with respect to the dependency semantics.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}
\begin{proof}
  \begin{align*}
    &\vphantom{=} \multiconcretization(\multisemanticsnoparam)\buckets
      && \text{by $\multiconcretization$} \\
    &= \bigsetjoin_{j \le n}\setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemanticsnoparam(\buckets))_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\multisemanticsnoparam$} \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(((\backwardsemanticsnoparam(\bucket[t]))_{t\le n})_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \text{by $\backwardconcretization$} \\
    &= \bigsetjoin_{j \le n} \backwardconcretization(\backwardsemanticsnoparam)\bucket
  \end{align*}
  From \refdef{sound-over-approximation}, we obtain that $\foralldef{j \le n}{\reduceddependencysemanticsnoparam \subseteq \backwardconcretization(\backwardsemanticsnoparam(\bucket))}$.
  Thus, by monotonicity of the union operator over set inclusion, it holds that $\bigsetjoin_{j\le n}\reduceddependencysemanticsnoparam \subseteq \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$. We conclude by:
  \begin{align*}
    \bigsetjoin_{j\le n}\reduceddependencysemanticsnoparam &= \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$} \\
    &= \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by set definition} \\
    &= \reducenoparam{\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$}
  \end{align*}
  \end{proof}


Whenever the output buckets \textit{cover} the subset of outcomes abstracted by $\outputobs$, $\multisemanticsnoparam$ is a sound over-approximation of $\dependencysemanticsnoparam$.
The concept of covering for output buckets ensures that no potential final state is missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  We say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[
    \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput{\defstate} \in \state} \subseteq \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}
  \]
\end{definition}

Additionally, the output buckets needs to be compatible with the concrete outcomes of the program, meaning that two output states cannot map to the same output abstraction if they belong to different output buckets.

\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}

We expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher (or always lower depending on the ordering operator of $\genbounded$) than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  % For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever it holds that:
  % \[
  %   \impactwrapper(
  %     \multiconcretization(\multisemantics)\buckets
  %   ) \LE \impactinstance(\multisemantics\buckets, \buckets)
  % \]
  The concretization of the abstract implementation $\impactinstance$ is $\impactinstanceconcretization\in\valuesposplus\to\outputvaluestype$, defined as:
  \begin{align*}
    \impactinstanceconcretization(\defbound) \DefeQ
    \setdef{\defsetofdependencies \in \setof{\pair{\state}{\valuesposplus}}}{
      \impactwrapper(\defsetofdependencies) \le \defbound
    }
  \end{align*}
\end{definition}



\begin{lemma}
  \begin{align*}
    \dependencyconcretization(\outputvaluesconcretization(\impactinstanceconcretization(\impactinstance(\multisemantics\buckets, \buckets)))) \subseteq \GENBOUNDED \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}

The next result shows that our static analysis is sound when employed to verify the property of interest $\bounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\le\defbound$, then the program $\defprogram$ satisfies the property $\bounded$, \cf{} $\defprogram \satisfies \bounded$.

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\bounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariable\in\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering}, and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) \le \defbound \ImplieS \defprogram \satisfies \bounded
  \end{align*}
\end{theorem}


Finally,
we define $\abstractrange$, $\abstractoutcomes$, and $\abstractqused$
as possible implementations for $\range$ and $\outcomes$, respectively.

%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variable $\definputvariable$.
For example, in the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainproject(\langle\definputvariable \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariable \mapsto [-\infty, \infty], j \mapsto [2, 4] \rangle$
removes the constraints related to $\definputvariable$.
%
We assume a soundness condition on the project operator to ensure that $\abstractdomainproject(\defstate^\natural)$ represents all the concrete states result of perturbations on the variable $\definputvariable$ from a state represented by an abstract value $\defstate^\natural$.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainproject$}{Project}]\labdef{soundness-project}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, for all $\defstate \in \abstractdomainconcretization(\defstate^\natural)$, whenever it exists a state $\defstate'$ such that $\defstate \stateeq{\inputvariableswithouti} \defstate'$, then it holds that $\defstate' \in \abstractdomainconcretization(\abstractdomainproject(\defstate^\natural))$.
\end{definition}
The above condition ensures that no intersection is missed, potentially spurious ones are allowed by the abstraction.

\section{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}


The definition of $\abstractoutcomes$ first projects away the input variable $\definputvariable$ from all the given abstract values, then it collects all intersecting abstract values via the meet operator $\abstractdomainmeet$.
These intersections represent potential concrete input configurations where variations on the value of $\definputvariable$ lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersects after projections:
\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refdef*{outcomes}) since the number of intersecting abstract values is bounded by $n$, the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:

\begin{definition}[Intersect All Function \texorpdfstring{$\intersectallfunction$}{}]\labdef{intersect-all-function}
  \begin{gather*}
    \intersectallfunction(X^\natural\in\vectorbuckets) \DefeQ \\
    \setdef{J}{J \subseteq \N \land \forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
  \end{gather*}
\end{definition}


Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidetextcite{Bron1973}.
%

In order to prove that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$, we require the output buckets $\buckets$ to be \textit{compatible} with the output descriptor $\reader$.
Intuitively, compatibility ensures that the counting intersecting buckets in the abstract does not miss any concrete outcome.
%
\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\reader\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\reader$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\reader(\defstate_j) \neq \reader(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}
%
Note that, $\outcomes$ is bounded by the number of buckets when the conditions of covering and compatibility hold for the output buckets.
\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the buckets $\buckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef{covering}, it holds that
  $\outcomes(\dependencysemanticsnoparam) \le n$.
\end{lemma}
\begin{proof}
  We notice that $\outcomes(\dependencysemanticsnoparam) \le \cardinalitynospaces{\setdef{\reader(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\finalstatesdependency}}$ as the set of outputs for the dependency semantics is always bigger than any set of outputs.
  It is easy to note that the cardinality of $\setdef{\reader(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\finalstatesdependency}$ is upper bounded by $n$ since any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\reader(\retrieveoutput\defstate) \neq \reader(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$ (by compatibility, \cf{} \refdef{compatibility}).
  Where the existence of the two buckets is guaranteed by covering (\cf{} \refdef{covering}).
  Therefore, there are at most $n$ different output readings.
\end{proof}

The next result shows that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$.

\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item \label{proof:b1} $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item \label{proof:d} $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}
\begin{proof}
  From \ref{proof:a}, \ref{proof:b2}, and the fact that $\outcomes$ is monotone, we obtain that $\outcomes(\dependencysemanticsnoparam) \le \outcomes(\multiconcretization(\multisemanticsnoparam)\buckets)$.
  By definitions of $\abstractoutcomes$, \cf{} \refdef{abstract-outcomes}, and $\outcomes$, \cf{} \refdef{outcomes}, we need to show that:
  \begin{gather*}
    \outcomes(\dependencysemanticsnoparam) = \sup_{\definputvariable\in\reducedstate}
    \cardinality{\setdef{\reader(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\inputvariableswithouti} \definputvariable}} \\
    \le \\
    \abstractoutcomes(X^\natural, \buckets) = \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{gather*}
  where $X^\natural = \multisemanticsnoparam(\buckets)$.
%
  First, from \ref{proof:b1} and \reflemma{outcomes-upper-bound} we know that $\outcomes$ is limited by the number of buckets $n$.
  Notably, $\outcomes$ cannot be unbounded, but it has to be a number, at most $n$. Thus, it exists an initial state $\overline\defstate\in\reducedstate$ such that $\outcomes(\dependencysemanticsnoparam) = \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$, where $\defsetoftraces{\overline\defstate} = \setdef{\reader(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\inputvariableswithouti} \overline\defstate}$.
  We conclude in case this cardinality is $0$ as anything returned by $\abstractoutcomes$ would be greater. In the other case, by covering (\cf{} \ref{proof:b2}), for all dependencies in $\defsetoftraces{\overline\defstate}$
  it exists a bucket $\bucket$ such that $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket)$.

  Furthermore, by compatibility (\cf{} \ref{proof:b1}), for any pair $\inputoutputtuple\defstate, \inputoutputtuple{\defstate'}\in\defsetoftraces{\overline\defstate}$ leading to two different outcomes $\reader(\retrieveoutput{\defstate}) \neq \reader(\retrieveoutput{\defstate'})$, we have two different buckets $\bucket, \bucket[p]$ such that $\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)$ and $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket[p])$.
  Note that, by definition of $\defsetoftraces{\overline\defstate}$ it holds that $\retrieveinput\defstate \stateeq{\inputvariableswithouti} \overline{\defstate} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate'}$, by transitivity $\retrieveinput\defstate \stateeq{\inputvariableswithouti} \retrieveinput{\defstate'}$.

  Let us call $\prefrombucket$ and $\prefrombucket[p]$ the corresponding abstract values from the backward analysis applied to the buckets $\bucket$ and $\bucket[p]$, respectively.
  From the fact that $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \ref{proof:a}, it holds that $\retrieveinput\defstate \in \abstractdomainconcretization(\prefrombucket)$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\prefrombucket[p])$.
  By the soundness condition of $\abstractdomainproject$, \cf{} \ref{proof:d}, we obtain that both states $\retrieveinput\defstate$ and $\retrieveinput\defstate'$ belong to each other projection, \ie, $\retrieveinput\defstate \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket))$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket[p]))$.

  Finally, the function \intersectallfunction{} applied to the projected preconditions $\prefrombucket$ and $\prefrombucket[p]$ finds an intersection between the indices $j$ and $p$ as $\abstractdomainproject(\prefrombucket) \abstractdomainmeet \abstractdomainproject(\prefrombucket[p])$ definitely holds since they share concrete states. Therefore, whenever it exists an intersection in the concrete, the two indices representing the respective precondition discovered by the backward analysis belong to the set $J$ in \refdef{abstract-outcomes}.
  As a consequence, the maximum cardinality of $J$ takes into account all the possible intersections in $\defsetoftraces{\overline\defstate}$, hence $\abstractoutcomes(X^\natural, \buckets) \ge \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$.
\end{proof}




\section{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

Similarly, we define $\abstractrange$ as the maximum length of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomainlength\in\abstractdomain\to\valuesposplus$, which returns the length of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

To prove that $\abstractrange$ is a sound implementation of $\range$, we require the following soundness condition on the abstract operator $\abstractdomainlength$ to ensure that the abstract length is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainlength$}{Length}]\labdef{soundness-length}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomainlength(\defstate^\natural) \ge \length(\setdef{\reader(\defstate)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)})\]
\end{definition}

As previously done, the next result shows that the abstract impact $\abstractrange$ is a sound over-approximation of the concrete impact $\range$, \cf{}\refdef*{range}.

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}

\section{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

We define $\abstractqused$ as the difference between the total number of input configurations and the maximum number of input configurations leading to the same output reading.

\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(X^\natural, \buckets) \DefeQ& \cardinality{\inputvaluesof{\state}} -\max~  \seTDef{\abstractdomaincount(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

To prove that $\abstractqused$ is a sound implementation of $\qused$, we require the following soundness condition on the abstract operator $\abstractdomaincount$ to ensure that the abstract count is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaincount$}{Count}]\labdef{soundness-count}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomaincount(\defstate^\natural) \ge \cardinality{\setdef{\retrieveinput{\defstate}(\definputvariable)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}}\]
\end{definition}

The next result shows that the abstract impact $\abstractqused$ is a sound over-approximation of the concrete impact $\qused$, \cf{} \refdef{qused}.

\begin{lemma}[$\abstractqused$ is a Sound Implementation of $\qused$]\lablemma{abstractqused-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractqused$ is a sound implementation of $\qused$.
\end{lemma}

\section{Summary}
\labsec{quantitative-input-data-usage-summary}

In this chapter, we introduced the quantitative measures $\outcomes$, $\range$, and $\qused$ to quantify the impact of input variables on the output of a program.
We developed a theoretical framework to verify the $\defbound$-bounded impact property of a program and showed the abstract versions of the quantitative measures.
In the next chapter, we show how we handle the quantification of input usage and bias in the context of neural network models.
