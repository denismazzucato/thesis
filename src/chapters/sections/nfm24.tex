%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}


In this chapter, we present a quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define three different quantitative measures for the impact of the input variables on the program outcome, and we formalize a theoretical framework for verifying the resulting quantitative impact property of a program.
At the end, we present abstract versions of the quantitative measures and show how they can be used to verify our quantitative property.
This chapter is based on the work published at Nasa Formal Methods Symposium (NFM) 2024 \cite{Mazzucato2024nfm}.
In the next chapters, we will apply this quantitative framework to the context of neural network and timing side-channel attacks.

\emph{Dans ce chapitre, nous présentons une notion quantitative de l'utilisation des données d'entrée, en étendant la définition introduite dans le chapitre précédent. Nous définissons trois mesures quantitatives différentes pour l'impact des variables d'entrée sur le résultat du programme, et nous formalisons un cadre théorique pour vérifier la propriété d'impact quantitatif résultante d'un programme. À la fin, nous présentons des versions abstraites des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier notre propriété quantitative. Ce chapitre est basé sur le travail publié au Symposium sur les méthodes formelles de la NASA (NFM) 2024 \sidecite{Mazzucato2024nfm}. Dans les prochains chapitres, nous appliquerons ce cadre quantitatif au contexte des réseaux de neurones et des attaques par canaux auxiliaires temporels.
}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}


\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as how much input data influences the program outcomes.
To this end, we develop the \emph{$\defbound$-bounded impact property} $\genbounded$ as the set of program semantics such that the input variable $\definputvariables\in\setof\inputvariables$ has an impact on the program outcome bounded by $\defbound\in\valuesposplus$.
\marginnote{
The set $\valuesposplus$ contains non-negative numerical values enhanced with $+\infty$.
}
Depending on the comparison operator $\comparison\in\{\le,\ge\}$, the impact quantity is bounded by $\defbound$ either from above or below.
We employ the notion of \emph{impact notion}:
\[\impactwrapper\in\tracetype\to\valuesposplus\]
to quantify the impact of the input variable $\definputvariables$ on the outcome of program computations.

\marginnote[*2]{
  As a comparison, here is the definition of $\unused$:
  \begin{named}[\nrefdef{unused}]%
    \input{src/propositions/unused-short}%
  \end{named}%
}
\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariables\in\variables$ be the input variable of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact notion, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where the comparison operator $\comparison$ is either $\le$ or $\ge$.
\end{definition}

We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow further abstractions of computable semantics to return an always greater or, respectively, an always smaller impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$, formally:
  \begin{align*}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align*}
\end{remark}

Next, we instantiate the general definition $\impactwrappername$ with the impact notions \outcomesname{}, \rangename{}, and \qusedname{}. Each of these notions differently characterizes the impact of the input variables, \outcomesname{} counts the number of different outcomes, \rangename{} measures the range of outcome values, and \qusedname{} counts the number of input values used to produce the outcomes.
To this end, these definitions employ the concept of output abstraction, \cf{} \refdef*{output-observer}[*-4], with a further restriction on the observed outcomes.
% We expect the output observer $\outputobs$ (\refdef*{output-observer}[*-2]) to return a quantifiable element, \ie{}, a value in $\valuesinf$.
% An output observer $\outputobs$ that returns a quantifiable element is called an \emph{output observer}.

% \begin{definition}[Output Descriptor]
%   \labdef{output-descriptor}
%   An \textup{output observer} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
% \end{definition}

% The above output observer $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
% We leverage this output observer to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.

\begin{example}
  Consider the \refprog*{landing-alarm-system} for the landing alarm system with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and use $\state$ as set of tuples instead of a map between variables and values, the two views are equivalent.
  The output observer is instantiated with
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  As a result, the output observer $\outputobs$ focuses on the value of the variable $\texttt{risk}$ when the last state of the trace is $\langle a, b, c, d \rangle$. Otherwise, in case of an infinite-length trace, the output observer returns the state $\top$.
  In other words, the output observer abstracts away the value of variables but $\texttt{risk}$, our output variable.
  Note that, even though \refprog{landing-alarm-system} always terminates, we need to take into account that the input parameter of the output observer $\outputobs$ is either the final state or $\statebottom$.
\end{example}

\begin{example}
  Originally introduced in \sidetextcite{Giacobazzi2018}, the output observer $\outputobs$ should deal with any possible abstraction an end-user of the framework might want to use.
  For example, one could be interested in the parity of the output value.
  In this case, the output observer $\outputobs$ could be defined as:
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \mod 2 \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  The parity of the value of $\texttt{risk}$ is mapped to the value $0$ if even and $1$ if odd.
  As a result, in our framework we would quantify the impact of the input variables on the parity of the output values.
\end{example}

Next, we define the impact notions of \outcomesname{}, \rangename{}, and \qusedname{}.

\subsection{The \outcomesname{} Impact Notion}[\outcomesname]
\labsec{outcomes}

Formally $\outcomes\in\tracetype\to\Nplus$ counts the number of different output values reachable by varying the input variable $\definputvariables\in\setof\inputvariables$.
First, we define step-by-step the quantity $\outcomes$,
followed by the instantiation of this quantity in the context of our example: \refprog*{landing-alarm-system}[*-12].
We present the formal definition at the end.


Intuitively,
for any possible input configuration $\definput\in\reducedstate$, we collect all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariables$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, we collect the output values of this set of traces by means of the output observer $\outputobs$, \ie, $\setdef{
  \outputobs(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
}$. Specifically, this set contains all the output readings performed by $\outputobs$.
%
Afterwards, we extract the number of elements via the cardinality operator $\cardinality{\cdot}$.
Finally, we iterate through each input configuration $\definput$ and return the maximum value to ensure that the greatest impact is preserved.

\begin{margintable}[*-10]
  \caption{Overview of the $\outcomesname$ impact notion for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*4]
  \caption{Overview of the $\outcomesname$ impact notion for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 3 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{example}
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  Let us revisit the example of the landing alarm system, with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  The input variables are $\setof\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input space is the set of program states reduced to the input variables, \ie{}
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariables=\texttt{angle}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\setof\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\setof\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace (with the intermediate states and the value of all the 4 variables) of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinality{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  \reftab{overview-outcomes-angle} illustrate the steps for $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-outcomes-speed} for $\outcomesname_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

Formally, the $\outcomesname$ impact notion is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariables\in\setof\inputvariables$ and output observer $\outputobs\in\stateandbottom\to\stateandbottom$,
  the impact notion $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \marginnote{
    The supremum operator $\sup$ yields the least upper bound of the given set, that is, the smallest $q$ such that $q$ is greater than or equal to all elements of the set.
  }
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
      }}
  \end{align*}
\end{definition}

We note that the above definition is monotone in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is based on the observation that, fixed an input state $\retrieveinput\defstate \in \state$, the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
  }$ is a subset of $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the cardinality of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')$.
\end{proof}

\marginnote{\denis{fix missing Theorem label in side theorem references.}}
As done in the previous chapter for the unused property, \cf{} \refthm*{output-validation}, we show the validation of the $\defbound$-bounded impact property when instantiated with the $\outcomesname$ impact notion.

\siderefbox{def}{output-abstraction-semantics}
\begin{lemma}\lablemma{outcomes-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDOUTCOMES \IfF \outputvaluessemantics \subseteq \outputvaluesabstraction(\dependencyabstraction(\BOUNDEDOUTCOMES))
  \end{align*}
\end{lemma}
\begin{proof}
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\outcomesname$ impact notion:
  \begin{eqnarray*}
    \lefteqn{\outputvaluesabstraction(\dependencyabstraction(\bounded)) =} \\
    & \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{
      \sup_{\definput\in\state}
      \cardinality{\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
      }} \le \defbound
    }
  \end{eqnarray*}
  Note that, all the intermediate states from the trace semantics are abstracted to input-output dependencies.
  The $\outcomesname$ impact notion does not consider the intermediate states, thus the abstraction to dependencies does not affect the validation of the property.
  Furthermore, even handling the output abstraction at the semantic level, by abstracting output states to output values, does not affect the validation of the property as the $\outcomesname$ impact notion already abstracts the output values before counting them.
\end{proof}

\reflemma{outcomes-monotonic} and \reflemma{outcomes-validation} are of significant importance as they show that the $\outcomesname$ impact notion can be used to certify that a program has impact of \emph{at most} $\defbound$. Moreover, whenever the given program semantics is deterministic, an impact quantity of zero implies that the input variable has no impact on the program outcomes, in other words, the input variable is unused.
On the other hand, non-deterministic statements in the program may mislead $\outcomesname$ to account differences in the program output as a result of variations in the input variable.

\subsection{The \rangename{} Impact Notion}[\rangename]
\labsec{range}

The quantity $\range\in\tracetype\to\Rposplus$ determines the
length of the range of the output values for all the possible variations in the input variable $\definputvariables\in\setof\inputvariables$.

\begin{margintable}
  \caption{Overview of the $\rangename$ impact notion for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$} & 1 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\rightarrow\langle{3}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\rightarrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\rightarrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\rightarrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\rightarrow\langle{3}\rangle$} & 1 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*14]
  \caption{Overview of the $\rangename$ impact notion for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\rightarrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\rightarrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\rightarrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\rightarrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\rightarrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\rightarrow\langle{2}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}

\begin{example}
  \labexample{range}
  We revisit again the example of the landing alarm system.
  Assuming $\definputvariables=\texttt{angle}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$.
%
  Here, we apply the function $\length$, hence $\length(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  Respectively, \reftab{overview-range-angle} illustrates the steps for $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-range-speed} for $\rangename_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ impact notion is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given an input variable $\definputvariables\in\setof\inputvariables$,
  the impact notion $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \length(\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
      })
  \end{align*}
\end{definition}

The above definition employs the auxiliary function $\length(X) \defeq \sup X - \inf X$ if $X$ is non-empty, otherwise $\length(X) \defeq 0$.

We note that also $\rangename$ is monotonic in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\rangename{} is Monotonic]
  \lablemma{range-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \range(\defsetoftraces) \le \range(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{outcomes-monotonic}, the proof is based on the observation that the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
  }$ is a subset of the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the length of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\range(\defsetoftraces) \le \range(\defsetoftraces')$.
\end{proof}


Similarly to $\outcomesname$, \cf{} \reflemma{outcomes-validation}, we show the validation of the $\defbound$-bounded impact property when applied to the $\rangename$ impact notion.

\begin{lemma}\lablemma{range-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\range$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{lemma}
\begin{proof}
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\rangename$ impact notion:
  \begin{align*}
    & \outputvaluesabstraction(\dependencyabstraction(\bounded)) = \\
    &\quad
    \setdef{
      \defsetofdependencies \in \outputtype
    }{ \\ & \qquad
      \sup_{\definput\in\state}
      \length({\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\setof\inputvariableswithouti} \definput
      }}) \le \defbound
    }
  \end{align*}
  As noticed before, the $\rangename$ impact notion does not consider the intermediate states and abstracts the output states before applying the length function.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

Similarly to the $\outcomesname$ impact notion, \reflemma{outcomes-monotonic} and \reflemma{outcomes-validation} are of significant importance as they show that the $\outcomesname$ impact notion can be used to certify that a program has impact of \emph{at most} $\defbound$. In the present of deterministic systems, an impact quantity of zero implies that the input variable is unused.
Otherwise, similarly to $\outcomesname$, the input variable may have an impact on the program computation even if not used

\subsection{The \qusedname{} Impact Notion}[\qusedname]
\labsec{qused}

The quantity $\qused\in\tracetype\to\Nplus$ counts the number of input values that are not used to produce the outcomes.
Distinctly, this notion natively handles non-deterministic programs, meaning that in $\qusedname$ the impact of the input variable is zero if the input variable is not used to produce the outcomes, even in the presence of non-deterministic statements.

For each possible outcome state $\retrieveoutput\defstate\in\state$ and trace $\deftrace\in\defsetoftraces$ that yields the same output abstraction, \ie{} $\outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput\defstate)$, we collect the set of input values of $\definputvariables$ that can produce this outcome $\retrieveoutput\defstate$.
More specifically, we collect the set of input values that belong to traces $\deftrace'$ that have the same output abstraction as $\deftrace$, \ie{} $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)$, and are a variation of $\deftrace$ on the input variables $\setof\inputvariableswithouti$.
Then, we obtain the number of missing input values by subtracting the set of all input values from the set of input values that can produce the outcome $\retrieveoutput\defstate$.
We return the maximum number of input values that are not used to produce the outcomes.

\begin{marginlisting}[*1]
  \caption{The identity program.}
  \labprog{id}
  \vspace{\lineheight}
\begin{lstlisting}
id(x):
  return x;
\end{lstlisting}
\end{marginlisting}
\begin{marginlisting}[*5]
  \caption{The random program.}
  \labprog{random}
  \vspace{\lineheight}
\begin{lstlisting}
random(x):
  return rand();
\end{lstlisting}
\end{marginlisting}
\begin{marginlisting}[*9]
  \caption{Combining random and constant value.}
  \labprog{mix}
  \vspace{2\lineheight}
\begin{lstlisting}
custom(x):
  if x > 0:
    return rand();
  else:
    return 0;
\end{lstlisting}
\denis{fix lineheight between programs and captions}
\end{marginlisting}
\begin{example}
  To explain the $\qusedname$ impact notion, we employ three simple programs.
  The first program we consider, \refprog{id}, returns the value of the only input variable $\texttt{x}$ without any modification.
  The second program, \refprog{random}, returns a random value.
  The last one, \refprog{mix}, returns a random value if the input variable $\texttt{x}$ is greater than $0$, otherwise it returns $0$.
  For simplicity, the input space is $\state=\setdef{\langle x \rangle}{x\in\{0, 1, 2\}}$ and the input variable is $\texttt{x}$, thus the set of input values is $\setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state} = \{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$ of cardinality $3$.
  The trace semantics of \refprog{id} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{id}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle 0\rangle,
        \langle 1\rangle\rightarrow\langle 1\rangle,
        \langle 2\rangle\rightarrow\langle 2\rangle
    \right\}
  \end{align*}
  As explained above, for any $\deftrace\in \tracesemanticsnoparam\semanticsof{\texttt{id}}$ we collect the set of input values that belong to traces $\deftrace'\in\tracesemanticsnoparam\semanticsof{\texttt{id}}$ that share the same output abstraction as $\deftrace$.
  In this case, the set of input values that can produce the outcome $0$ is $\{\langle 0\rangle\}$, for the outcome $1$ is $\{\langle 1\rangle\}$, and for the outcome $2$ is $\{\langle 2\rangle\}$, all singletons.
  Hence, by subtracting the set of all input values, of cardinality $3$, from the set of input values that can produce the outcomes, we obtain the value $2$ for the three set of traces. Thus, $\qused(\tracesemanticsnoparam\semanticsof{\texttt{id}})=2$, meaning that the input variable $\texttt{x}$ is used.
%
  The trace semantics of \refprog{random} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{random}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 1\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 2\rangle\rightarrow\langle \anyvalue\rangle
    \right\}
  \end{align*}
  In this case, any outcome can be produced by any input value, thus the set of input values is $\{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$ for all outcomes.
  By subtracting the set of all input values from the set of input values that can produce the outcomes, we obtain the value $0$.
  Thus, $\qused(\tracesemanticsnoparam\semanticsof{\texttt{random}})=0$, meaning that the input variable $\texttt{x}$ is not used.
  %
  The trace semantics of \refprog{mix} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix}}
    =
    \left\{
        \langle 0\rangle\rightarrow\langle 0\rangle,
        \langle 1\rangle\rightarrow\langle \anyvalue\rangle,
        \langle 2\rangle\rightarrow\langle \anyvalue\rangle
    \right\}
  \end{align*}
  In this case, the set of input values that can produce the outcome $0$ is $\{\langle 0\rangle, \langle 1\rangle, \langle 2\rangle\}$, for the outcome $1$ is $\{\langle 1\rangle, \langle 2\rangle\}$, and for the outcome $2$ is $\{\langle 1\rangle, \langle 2\rangle\}$.
  By subtracting the set of all input values from the set of input values that can produce the outcomes, we obtain the value $0, 1, 1$, respectively.
  Thus, we yield the highest value, obtaining $\qused(\tracesemanticsnoparam\semanticsof{\texttt{custom}})=1$.

  From these examples we notice that the $\qusedname$ impact notion is able to capture that a variable is not used in a program, even in the presence of non-deterministic statements, \cf{} \refprog{random}.
  On the other hand, we notice that $\qusedname$ discriminates between different amount of impact from \refprog{id} and \refprog{mix}.
  Indeed, \refprog{id} is, intuitively, the program with the highest impact possible as the output is exactly the input value, while \refprog{mix} sometimes returns a random value and sometimes $0$.
\end{example}

Formally, the $\qusedname$ impact notion is defined as follows:

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariables\in\setof\inputvariables$,
  the impact notion $\qused\in\tracetype\to\Nplus$ is defined as
  %
  \marginnote[*2]{Note that, $\setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state}$ is the set of all input values for the variable $\definputvariables$.}
  \begin{eqnarray*}
    \qused(\defsetoftraces) \DefeQ
    \sup_{\retrieveoutput\defstate \in \stateandbottom}
      \spacer\left|
        \begin{array}{l}
          \setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state} \setminus \\
          \quad \setdef{
            \retrieveinput{\defseq'}(\definputvariables)
            }{
              \deftrace' \in \defsetoftraces \LanD
                  \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)
            }
        \end{array}
      \right|
  \end{eqnarray*}
\end{definition}

We show that $\qusedname$ is (anti-)monotonic in the amount of traces for non-empty sets of traces.
In fact, $\qused(\emptyset) = \sup \emptyset = 0$.
On the other hand, the set of traces with at least one trace yields the highest value of $\qusedname$, \ie{} $\cardinalitynospaces{\setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state}} - 1$.
Hence, the value of $\qusedname$ always decreases by enlarging the set of traces. Until the set of traces contains all possible traces\sidenote{The set of traces containing all the possible traces can be obtained by the random program, \cf{} \refprog{random}.} and the value of $\qusedname$ is $0$.

\begin{lemma}[\qusedname{} is Anti-Monotonic]
  \lablemma{qused-antimonotonic}
  For any non-empty set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \neq \emptyset \LanD \defsetoftraces \subseteq \defsetoftraces' \ImplieS \qused(\defsetoftraces) \ge \qused(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  Given two sets of traces $\defsetoftraces, \defsetoftraces' \in \tracetype$, we assume the cardinality of input values is $n$ and that $\qused(\defsetoftraces) = \defbound$.
  Let us say that $\defoutput$ is the output value that maximizes $\qused(\defsetoftraces)$, \ie{} $\cardinalitynospaces{\setdef{
    \retrieveinput{\defseq'}(\definputvariables)
    }{
      \deftrace' \in \defsetoftraces \land
      \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\defoutput) \land
      \retrieveinput{\deftrace'} \stateeq{\setof\inputvariableswithouti} \retrieveinput{\deftrace}
    }} = n - \defbound$.
  By hypothesis that $\defsetoftraces$ is not empty, we have that $\defbound > 0$ since it exists at least one trace satisfying the above set.
  Otherwise, the $\sup$ operator of an empty set would return $0$ and by adding traces this value would only increase, which goes against the conclusion of the lemma.
  The other set of traces $\defsetoftraces'$ contains all the traces of $\defsetoftraces$ and possibly more.
  Thus, $\setdef{
    \retrieveinput{\defseq'}(\definputvariables)
    }{
      \deftrace' \in \defsetoftraces' \land
      \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\defoutput) \land
      \retrieveinput{\deftrace'} \stateeq{\setof\inputvariableswithouti} \retrieveinput{\deftrace}
    }$ contains, at least, all the input values of the one obtained for $\defsetoftraces$.
    As a consequence, the cardinality can only be higher or equal to $n - \defbound$.
    The anti-monotonicity follows from the fact that this cardinality is subtracted from the set of all input values, thus it is reversed.
\end{proof}


Next, we show the validation of the $\defbound$-bounded impact property when instantiated with the $\qusedname$ impact notion.
Note the use of the $\ge$ operator\sidenote{Previously, for the \outcomesname{} and \rangename{} impact notions, the $\defbound$-bounded impact property employed the $\le$ comparison operator.} in our property $\revbounded$, this choice is forced by the fact that the $\qusedname$ is anti-monotonic.

\begin{lemma}\lablemma{qused-validation}
  Whenever $\impactwrapper$ in $\revbounded$ is instantiated with $\qused$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \REVBOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\REVBOUNDED))
  \end{align*}
\end{lemma}
\begin{proof}
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\bounded$ when instantiated with the $\qusedname$ impact notion:
  \begin{eqnarray*}
    \lefteqn{\outputvaluesabstraction(\dependencyabstraction(\bounded)) =} \\
    &
    \setdef{
      \defsetofdependencies \in \outputtype
    }{
      \sup\limits_{\retrieveoutput\defstate \in \stateandbottom}
      \spacer\left|
        \begin{array}{l}
          \setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state} \setminus \\
          \quad \bigsetdef{
            \retrieveinput{\defseq'}(\definputvariables)
            }{
              \deftrace' \in \defsetoftraces \LanD \\
              \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD \\
              \retrieveinput{\deftrace'} \stateeq{\setof\inputvariableswithouti} \retrieveinput{\deftrace}
            }
        \end{array}
      \right| \le \defbound
    }
  \end{eqnarray*}
  As noticed before, the $\qusedname$ impact notion does not consider the intermediate states and abstracts the output states before any computation.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}


Differently from the previous impact notions, it holds that, whenever $\qused(\tracesemantics) = 0$, the program $\defprogram$ does not use the input variable $\definputvariables$, even in the presence of non-determinism.
Thus, we can establish the following equivalence:

\siderefbox{def}{abstract-unused}
\begin{lemma}[Unused Equivalence]\lablemma{qualitative-quantitative-equivalence}
  For all program $\defprogram$, it holds that:
  \begin{gather*}
    \unusediowrapper(\tracesemantics) \IfF \qused(\tracesemantics) = 0
  \end{gather*}
\end{lemma}
\begin{proof}
  To show ($\Rightarrow$) we assume that $\unusediowrapper(\tracesemantics)$.
  As a consequence, we have that any outcome either is not reachable or is reachable from every input value of the variable $\definputvariables$.
  Thus, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values.
  By subtracting this set from the set of input values that can produce the outcome $\retrieveoutput\defstate$, we obtain the value $0$, concluding that $\qused(\tracesemanticsnoparam) = 0$.

  To show ($\Leftarrow$) we assume that $\qused(\tracesemanticsnoparam) = 0$.
  By definition, for all $\retrieveoutput\defstate$, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values, otherwise $\qused(\tracesemanticsnoparam)$ would not be 0.
  Thus, for all traces $\deftrace\in\tracesemantics$ and input values $\defvalue\in\values$ such that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, we have that it exists a trace $\deftrace'$ such that $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput{\deftrace})$ and $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, otherwise it would not be possible that the set of input values that can produce any outcome is the set of all input values. Hence, $\unusediowrapper(\tracesemantics)$.
\end{proof}


As a consequence of \reflemma{qualitative-quantitative-equivalence}, we obtain an equivalence between the (un)used property (\refdef*{unused}[*-6]) and the $\defbound$-bounded impact property (\refdef*{bounded}[*-2]) instantiated with the $\qusedname$ impact notion:
\[
\neg\unused \spacearound{=} \mathscr{B}_{\definputvariables}^{\ge 1}
\]
meaning that if a program semantics uses the variable $\definputvariables$, then it has an impact of at least $1$, and vice versa.

In the rest of this chapter, we present the static analysis to verify the $\defbound$-bounded impact property of a program and show the abstract version of the quantitative measures introduced in this chapter.

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

In this section, we introduce a sound and computable static analysis to verify the $\defbound$-bounded impact property of a program.
The soundness of the approach leverages two elements: (1) a backward abstract semantics, and (2) sound and computable implementations of the quantitative measures \outcomesname{}, \rangename{}, and \qusedname{} (written as $\abstractoutcomes$, $\abstractrange$, and $\abstractqused$ respectively).


To quantify the usage of an input variable, we need to determine the input configurations leading to specific output values.
As our impact notions measure over the reachable output values (more precisely, over their abstraction by $\outputobs$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is a parameter of the analysis and a \emph{good} choice is essential for obtaining a precise and meaningful analysis result.

For each output bucket $\bucket\in\abstractdomain$, where $1 \le j \le n$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
More formally, the reduction of the output-abstraction semantics $\outputsemanticsnoparam$ to the dependencies with abstraction of a final state in $X$ is defined as:
\[
  \reduce[\outputsemanticsnoparam]{X} \DefeQ \setdef{
    \setdef{
      \tuple{\retrieveinput\defstate}{\outputobs(\retrieveoutput{\defstate})}\in\defsetofdependencies
    }{
      \retrieveoutput{\defstate} \in X
      }
  }{
    \defsetofdependencies\in \outputsemanticsnoparam
  }
\]
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemanticsnoparam\in\backwardtype$ which computes the backward semantics $\backwardsemanticsnoparam(\bucket)$ from a given output bucket $\bucket\in\abstractdomain$.
For instance, we could use the backward semantics \refdef{?}\sidenote{This definition will be defined in \refch{abstract-interpretation}, and referenced on the side here} to compute $\backwardsemanticsnoparam(\bucket)$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\outputtype$ employs the concretization of the abstract domain, \cf{}
$\abstractdomainconcretization$, to restore all possible dependencies from input states to output values, formally:
\[
  \backwardconcretization(\backwardsemanticsnoparam)\bucket \DefeQ
  \nonemptysetof{\setdef{
    \inputoutputtuple{\defstate}
  }{
    \retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)
    }
  }
  \]
\marginnote[*-2]{The operator $\nonemptysetof{\cdot}$ returns the set of non-empty subsets of the given argument.}
We can thus define the soundness condition for the backward semantics with respect to the reduction of the output-abstraction semantics.


\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reducedoutputsemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$ as follows:

\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
\end{definition}


The concretization function $\multiconcretization$ maps the multi-bucket semantics $\multisemanticsnoparam$ from a given set of output buckets $\buckets$ to set of sets of dependencies in $\outputtype$.
Specifically, for each output bucket $\bucket\in\buckets$, $\multiconcretization$ concretizes the output from $\abstractdomainconcretization(\bucket)$ and the input states from the application of the backward semantics to $\bucket$, \ie{} $\abstractdomainconcretization((\multisemantics\buckets)_j)$.
Hence, all the possible input-output dependencies are collected for all buckets.
Lastly, to account for the fact that the abstract semantics may discover more dependencies than the concrete ones, the concretization returns all the non-empty combination of dependencies, \cf{} the power set operator $\wp_{+}$.
\marginnote{
  \[\nonemptysetof{X} \DefeQ \setof{X} \setminus \emptyset\]
}
\begin{definition}[Multi-Bucket Concretization \texorpdfstring{$\multiconcretization$}{}]\labdef{multi-concretization}
  We define the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\outputtype$ as:
\begin{align*}
  \multiconcretization &\IN (\multitype)\to\vectorbuckets\to\outputtype \\
  \multiconcretization(\multisemantics)\buckets &\DefeQ
  \nonemptysetof*{\bigsetjoin_{j\le n} \bigsetdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j) \land{} \\ \retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}}
\end{align*}
\end{definition}

Next, we show the soundness of the multi-bucket semantics with respect to the output-abstraction semantics.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin\limits_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}
\begin{proof}
  \begin{align*}
    &\vphantom{=} \multiconcretization(\multisemanticsnoparam)\buckets
      && \text{by $\multiconcretization$} \\
    &= \bigsetjoin_{j \le n}\setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemanticsnoparam(\buckets))_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\multisemanticsnoparam$} \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(((\backwardsemanticsnoparam(\bucket[t]))_{t\le n})_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \text{by $\backwardconcretization$} \\
    &= \bigsetjoin_{j \le n} \backwardconcretization(\backwardsemanticsnoparam)\bucket
  \end{align*}
  From \refdef{sound-over-approximation}, we obtain that $\foralldef{j \le n}{\reducedoutputsemanticsnoparam \subseteq \backwardconcretization(\backwardsemanticsnoparam(\bucket))}$.
  Thus, by monotonicity of the union operator over set inclusion, it holds that $\bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam \subseteq \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$. We conclude by:
  \begin{align*}
    \bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam &= \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$} \\
    &= \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by set definition} \\
    &= \reducenoparam{\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$}
  \end{align*}
  \end{proof}

We introduce the concept of \emph{covering} for output buckets to ensure that no potential final state is missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  Let $\outputobs\in\stateandbottom\to\stateandbottom$ be the output observer, we say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[
    \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput{\defstate} \in \stateandbottom} \subseteq \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}
  \]
\end{definition}


Whenever the output buckets \textit{cover} the subset of outcomes abstracted by $\outputobs$, $\multisemanticsnoparam$ is a sound over-approximation of $\outputsemanticsnoparam$.

\begin{lemma}\lablemma{sound-approximation-covering}
  Let $\buckets\in\vectorbuckets$ be the set of output buckets such that it covers the subset of potential outcomes of a program $\defprogram$.Then, it holds that the semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$:
  \[
    \outputsemanticsnoparam \SubseteQ \multiconcretization(\multisemantics)\buckets
  \]
\end{lemma}
\begin{proof}
  Follows directly from \reflemma{sound-over-approximation-multi-bucket} and \refdef{covering}. The covering of the output buckets ensures that no potential final state is missed and thus let the reduction of the output-abstraction semantics unnecessary, as it holds that $\outputsemanticsnoparam = \reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}$.
\end{proof}



% Additionally, the output buckets needs to be compatible with the concrete outcomes of the program, meaning that two output states cannot map to the same output abstraction if they belong to different output buckets.

% \begin{definition}[Compatibility]\labdef{compatibility}
%   Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
%   \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
% \end{definition}

So far, we presented the semantics $\multisemanticsnoparam$ as an abstraction of the output-abstraction semantics $\outputsemanticsnoparam$ via \reflemma{sound-approximation-covering}.
Next, this section shows the concept of sound implementation of the impact notions.
We expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher (or always lower depending on the ordering operator of $\genbounded$) than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever it holds that:
  \begin{eqnarray*}
    \lefteqn{\forall{
      \defsetoftraces\in \dependencyconcretization(\outputconcretization(\multiconcretization(\multisemantics)\buckets))
    }.} \\ & {
        \impactwrapper(
          \defsetoftraces
          ) \ComparisoN \impactinstance(\multisemantics\buckets, \buckets)
          }
  \end{eqnarray*}
  % The concretization of the abstract implementation $\impactinstance$ is $\boundconcretization\in\valuesposplus\to\outputtype$, defined as:
  % \begin{align*}
  %   \boundconcretization(\defbound) \DefeQ
  %   \setdef{\defsetofdependencies \in \setof{\pair{\state}{\valuesposplus}}}{
  %     \impactwrapper(\defsetofdependencies) \le \defbound
  %   }
  % \end{align*}
\end{definition}

\refdef{sound-implementation} is of importance to ensure that the soundness of the static analysis is preserved when computing the quantity bound. As a reminder, we consider semantics that are collecting semantics, in the sense that semantics collect set of sets of elements, \eg{} set of sets of input-output tuples for the dependency semantics $\dependencysemanticsnoparam$.

We define the concretization of the bound computed by the abstract impact $\impactinstance(\multisemantics\buckets, \buckets)$ via $\boundconcretization \in \valuesinf \to \collectingtype$. It concretizes the set of trace semantics that yield an impact lower (respectively bigger depending on $\comparison$) than the computed bound.

\begin{definition}[Concretization of the Measured Quantity]\labdef{concretization-quantitative}
  The concretization of a measured quantity $\defbound$ is $\boundconcretization\in\valuesinf\to\collectingtype$, defined as:
  \begin{eqnarray*}
    \lefteqn{\boundconcretization(\impactinstance(\multisemantics\buckets, \buckets)) \DefeQ} \\
    & \setdef{\defsetoftraces \in \tracetype}{
      \impactwrapper(\defsetoftraces) \comparison \impactinstance(\multisemantics\buckets, \buckets)
    }
  \end{eqnarray*}
\end{definition}

% Note that, it holds an equivalence with the $\defbound$-bounded impact property:
% \[
%   \boundconcretization(\defbound) = \genbounded
% \]

Additionally, we note that the concretization $\boundconcretization$ is monotonically increasing, respectively decreasing depending on $\comparison$.

\begin{lemma}[Monotonicity of $\boundconcretization$]\lablemma{monotonicity-bound-concretization}
  Depending on the comparison operator, for all quantities $\defbound',\defbound\in\valuesposplus$ measured by the abstract impact $\impactinstance$ it holds that:
  \begin{enumerate}[label=(\roman*)]
    \item $\defbound' \le \defbound \ImplieS \leconcretization(\defbound') \subseteq \leconcretization(\defbound)$
    \item $\defbound' \ge \defbound \ImplieS \geconcretization(\defbound') \supseteq \geconcretization(\defbound)$
  \end{enumerate}
\end{lemma}
\begin{proof}
  The proof follows directly from the definition of the concretization $\boundconcretization$. By increasing the bound $\defbound'$, the set of traces in $\leconcretization(\defbound')$ can only increase as we weaken the condition. On the other hand, $\geconcretization(\defbound')$ can only decrease as we strengthen the condition.
\end{proof}

The next result shows that our static analysis is sound when employed to verify the property of interest $\genbounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\comparison\defbound$, then the program $\defprogram$ satisfies the property $\genbounded$, \cf{} $\defprogram \satisfies \genbounded$.

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\genbounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering}, and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \comparison \defbound \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{theorem}
\begin{proof}
  Assuming $\comparison$ is $\le$, the proof follows:
  \begin{align*}
    &\impactinstance(\multisemantics\buckets, \buckets) = \defbound'
      && \text{by \ref{p:third}} \\
    & \implies
    \forall{
      \defsetoftraces\in \dependencyconcretization(\outputconcretization(\multiconcretization(\multisemantics)\buckets))
    }. \\ & \phantom{\implies} \qquad
        \impactwrapper(
          \multiconcretization(\multisemantics)\buckets
        ) \LE \defbound'
      && \text{by \ref{p:first}} \\
    & \implies
    \forall{
      \defsetoftraces\in \dependencyconcretization(\outputconcretization(\outputsemantics))
    }. \\ & \phantom{\implies} \qquad
        \impactwrapper(
          \multiconcretization(\multisemantics)\buckets
        ) \LE \defbound'
      && \text{by \refdef{concretization-quantitative}} \\
    & \implies
    \dependencyconcretization(\outputconcretization(\outputsemantics)) \SubseteQ \leconcretization(\defbound')
      && \text{by \reflemma{monotonicity-bound-concretization} and } \defbound' \le \defbound \\
    & \implies
    \dependencyconcretization(\outputconcretization(\outputsemantics)) \SubseteQ \leconcretization(\defbound)
      && \text{by } \bounded = \leconcretization(\defbound) \\
    & \implies
    \dependencyconcretization(\outputconcretization(\outputsemantics)) \SubseteQ \bounded
      && \text{by \refthm{collecting-dependency-galois-connection}} \\
    & \implies
    \outputconcretization(\outputsemantics) \SubseteQ \dependencyabstraction(\bounded)
      && \text{by \refthm{dependency-output-galois-connection}} \\
    & \implies
    \outputsemantics \SubseteQ \outputabstraction(\dependencyabstraction(\bounded))
  \end{align*}
  In case $\impactwrappername$ is instantiated with $\outcomesname$, we obtain the result by \reflemma{outcomes-validation}. Otherwise, if $\impactwrappername$ is instantiated with $\rangename$, we obtain the result by \reflemma{range-validation}. On the other hand, if $\comparison$ is $\ge$ the proof follows by the same reasoning inverting $\subseteq$ with $\supseteq$ when \reflemma{monotonicity-bound-concretization} is applied.
  In such case, $\impactwrappername$ is instantiated with $\qusedname$ and we conclude the proof following \reflemma{qused-validation}.
\end{proof}


Finally,
we define $\abstractrange$, $\abstractoutcomes$, and $\abstractqused$
as possible implementations for $\range$ and $\outcomes$, respectively.

%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variables $\definputvariables$, that is, the reduction in dimensionality of the abstract element by projecting its image to the reduced variable space.
\begin{example}
In the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainproject(\langle\definputvariables \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariables \mapsto [-\infty, \infty], j \mapsto [2, 4] \rangle$
  removes the constraints related to $\definputvariables$.
\end{example}
%
% We define the soundness condition on the project operator to ensure that $\abstractdomainproject(\defstate^\natural)$ represents all the concrete states result of perturbations on the variable $\definputvariables$ from a state represented by an abstract value $\defstate^\natural$.
We define the condition a sound projection operator $\abstractdomainproject$ must satisfy to ensure that no concrete state is missed by the projection.
In fact, the projection operator is sound whenever the projection of variable $\definputvariable$ from the abstract value $\defstate^\natural$ contains all the concrete states that can be obtained by perturbing the variable $\definputvariable$ from a concrete state represented by $\defstate^\natural$.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainproject$}{Project}]\labdef{soundness-project}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, we say that the projection operator $\abstractdomainproject$ is \textup{sound} whenever it holds that:
  \[
    \setdef{\defstate'\in\stateandbottom}{\defstate\in\abstractdomainconcretization(\defstate^\natural) \land \defstate \stateeq{\inputvariableswithouti} \defstate'} \SubseteQ \abstractdomainconcretization(\abstractdomainproject(\defstate^\natural))
  \]
\end{definition}

\subsection{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}


The definition of $\abstractoutcomes$ first projects away the input variable $\definputvariables$ from all the given abstract values, then it collects all possible abstract values resulting from the meet operation over any two resulting abstract domain elements.
These intersections represent concrete input configurations where variations on the value of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersect after projections:
\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refdef*{outcomes}) since the number of intersecting abstract values is finite and bounded by $n$, the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:

\begin{definition}[\texorpdfstring{$\intersectallfunction$}{}]\labdef{intersect-all-function}
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction(X^\natural\in\vectorbuckets) \DefeQ} \\
    & \setdef{J \subseteq \N}{\forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
  \end{eqnarray*}
\end{definition}


Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidetextcite{Bron1973}.
All together, the abstract implementation $\abstractoutcomes$ returns the value of the maximum among all the sizes of the maximum cliques for each projection.
%

In order to prove that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$, we require the output buckets $\buckets$ to be \textit{compatible} with the output observer $\outputobs$.
That is, any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$.
Intuitively, compatibility ensures that the counting intersecting buckets in the abstract does not miss any concrete outcome.
%
\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}
%
Note that, $\outcomes$ is bounded by the number of buckets when the conditions of covering and compatibility hold for the output buckets.
\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the $numberofbuckets$ buckets $\buckets\in\vectorbuckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef{covering}, it holds that
  $\outcomes(\dependencysemanticsnoparam) \le n$.
\end{lemma}
\begin{proof}
  We notice that $\outcomes(\dependencysemanticsnoparam) \le \cardinalitynospaces{\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\stateandbottom}}$ as the set of outputs for the dependency semantics is always bigger than any set of outputs.
  It is easy to note that the cardinality of $\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\finalstatesdependency}$ is bounded from above by $n$ since any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$ (by compatibility, \cf{} \refdef{compatibility}).
  Where the existence of the two buckets is guaranteed by covering (\cf{} \refdef{covering}).
  Therefore, there are at most $n$ different output readings.
\end{proof}

The next result shows that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$.

\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let  $\definputvariables\in\setof\inputvariables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item \label{proof:b1} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item \label{proof:d} $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}
\begin{proof}
  \marginnote{\denis{Incoherent with last modifications}}
  From \ref{proof:a}, \ref{proof:b2}, and the fact that $\outcomes$ is monotone, we obtain that $\outcomes(\dependencysemanticsnoparam) \le \outcomes(\multiconcretization(\multisemanticsnoparam)\buckets)$.
  By definitions of $\abstractoutcomes$, \cf{} \refdef{abstract-outcomes}, and $\outcomes$, \cf{} \refdef{outcomes}, we need to show that:
  \begin{gather*}
    \outcomes(\dependencysemanticsnoparam) = \sup_{\definputvariables\in\reducedstate}
    \cardinality{\setdef{\outputobs(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\setof\inputvariableswithouti} \definputvariables}} \\
    \le \\
    \abstractoutcomes(X^\natural, \buckets) = \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{gather*}
  where $X^\natural = \multisemanticsnoparam(\buckets)$.
%
  First, from \ref{proof:b1} and \reflemma{outcomes-upper-bound} we know that $\outcomes$ is limited by the number of buckets $n$.
  Notably, $\outcomes$ cannot be unbounded, but it has to be a number, at most $n$. Thus, it exists an initial state $\overline\defstate\in\reducedstate$ such that $\outcomes(\dependencysemanticsnoparam) = \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$, where $\defsetoftraces{\overline\defstate} = \setdef{\outputobs(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\setof\inputvariableswithouti} \overline\defstate}$.
  We conclude in case this cardinality is $0$ as anything returned by $\abstractoutcomes$ would be greater. In the other case, by covering (\cf{} \ref{proof:b2}), for all dependencies in $\defsetoftraces{\overline\defstate}$
  it exists a bucket $\bucket$ such that $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket)$.

  Furthermore, by compatibility (\cf{} \ref{proof:b1}), for any pair $\inputoutputtuple\defstate, \inputoutputtuple{\defstate'}\in\defsetoftraces{\overline\defstate}$ leading to two different outcomes $\outputobs(\retrieveoutput{\defstate}) \neq \outputobs(\retrieveoutput{\defstate'})$, we have two different buckets $\bucket, \bucket[p]$ such that $\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)$ and $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket[p])$.
  Note that, by definition of $\defsetoftraces{\overline\defstate}$ it holds that $\retrieveinput\defstate \stateeq{\setof\inputvariableswithouti} \overline{\defstate} \stateeq{\setof\inputvariableswithouti} \retrieveinput{\defstate'}$, by transitivity $\retrieveinput\defstate \stateeq{\setof\inputvariableswithouti} \retrieveinput{\defstate'}$.

  Let us call $\prefrombucket$ and $\prefrombucket[p]$ the corresponding abstract values from the backward analysis applied to the buckets $\bucket$ and $\bucket[p]$, respectively.
  From the fact that $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \ref{proof:a}, it holds that $\retrieveinput\defstate \in \abstractdomainconcretization(\prefrombucket)$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\prefrombucket[p])$.
  By the soundness condition of $\abstractdomainproject$, \cf{} \ref{proof:d}, we obtain that both states $\retrieveinput\defstate$ and $\retrieveinput\defstate'$ belong to each other projection, \ie, $\retrieveinput\defstate \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket))$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket[p]))$.

  Finally, the function \intersectallfunction{} applied to the projected preconditions $\prefrombucket$ and $\prefrombucket[p]$ finds an intersection between the indices $j$ and $p$ as $\abstractdomainproject(\prefrombucket) \abstractdomainmeet \abstractdomainproject(\prefrombucket[p])$ definitely holds since they share concrete states. Therefore, whenever it exists an intersection in the concrete, the two indices representing the respective precondition discovered by the backward analysis belong to the set $J$ in \refdef{abstract-outcomes}.
  As a consequence, the maximum cardinality of $J$ takes into account all the possible intersections in $\defsetoftraces{\overline\defstate}$, hence $\abstractoutcomes(X^\natural, \buckets) \ge \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$.
\end{proof}




\subsection{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

We define $\abstractrange$ as the maximum distance of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomainlength\in\abstractdomain\to\valuesposplus$, which returns the size of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.

\begin{example}
  In the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainlength([2, 4]) = 2$.
  On the other hand, whenever the input abstract element is unbounded, the size is $+\infty$, \eg{} $\abstractdomainlength([0, +\infty]) = +\infty$.
\end{example}

The abstract range $\abstractrange$ first projects away the input variable $\definputvariables$ from all the given abstract values.
Then, it collects all the possible intersections among the projected abstract values.
These intersections represent concrete input configurations where variations on the value of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
All the possible combination of intersections are joined together to find the maximum range of the extreme values of the buckets.

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

To prove that $\abstractrange$ is a sound implementation of $\range$, we require the following soundness condition on the abstract operator $\abstractdomainlength$ to ensure that the abstract length is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainlength$}{Length}]\labdef{soundness-length}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomainlength(\defstate^\natural) \ge \length(\setdef{\outputobs(\defstate)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)})\]
\end{definition}

The next result shows that the abstract impact $\abstractrange$ is a sound over-approximation of the concrete impact $\range$, \cf{}\refdef*{range}.

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let  $\definputvariables\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}
\begin{proof}
  \denis{todo}
\end{proof}

\subsection{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

We define $\abstractqused$ as the difference between the total number of input configurations and the maximum number of input configurations leading to the same output reading.

\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(X^\natural, \buckets) \DefeQ& \cardinality{\inputvaluesof{\state}} -\max~  \seTDef{\abstractdomaincount(\abstractdomainprojectothers(X^\natural_j))}{j \le n}
  \end{align*}
\end{definition}

To prove that $\abstractqused$ is a sound implementation of $\qused$, we require the following soundness condition on the abstract operator $\abstractdomaincount$ to ensure that the abstract count is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaincount$}{Count}]\labdef{soundness-count}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomaincount(\defstate^\natural) \GE \cardinality{\setdef{\retrieveinput{\defstate}(\definputvariables)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}}\]
\end{definition}

The next result shows that the abstract impact $\abstractqused$ is a sound over-approximation of the concrete impact $\qused$, \cf{} \refdef{qused}.

\begin{lemma}[$\abstractqused$ is a Sound Implementation of $\qused$]\lablemma{abstractqused-is-sound}
  Let  $\definputvariables\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractqused$ is a sound implementation of $\qused$.
\end{lemma}
\begin{proof}
  \denis{todo}
\end{proof}

\section{Summary}
\labsec{quantitative-input-data-usage-summary}

In this chapter, we introduced the quantitative measures $\outcomes$, $\range$, and $\qused$ to quantify the impact of input variables on the output of a program.
We developed a theoretical framework to verify the $\defbound$-bounded impact property of a program and showed the abstract version of the quantitative measures.
In the next chapter, we show how we handle the quantification of input usage and bias in the context of neural network models.
