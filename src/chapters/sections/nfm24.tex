%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}

% \begin{itemize}
%   \item $\sup$ and $\inf$ operators;
%   \item $\length$ function;
%   \item abstract domain $\abstractdomain$
%   \item backward reachability state abstract semantics $\backwardsemanticsnoparam$.
% \end{itemize}

% In this chapter, we present the quantitative framework used to measure the contributions of the input variables to the outcome of a program. First, we introduce a leading example of a landing-risk alarm system to illustrate the motivation of this chapter. Then, we present the quantitative framework and its properties. Since the framework depends on the underlying notion of impact, we show a few possible definitions of impact. Finally, we demonstrate the effectiveness of our approach against a set of potential applications.

% \textit{Dans ce chapitre, nous présentons le cadre quantitatif utilisé pour mesurer les contributions des variables d'input à l'output d'un programme. Tout d'abord, nous introduisons un exemple principal d'un système d'alarme de risque d'atterrissage pour illustrer la motivation de ce chapitre. Ensuite, nous présentons le cadre quantitatif et ses propriétés. Étant donné que le cadre dépend de la notion d'impact, nous en montrons quelques définitions possibles. Enfin, nous démontrons l'efficacité notre approche contre des applications potentielles.}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle,
% \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}

% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}


\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariable\in\variables$ the input variable of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact definition, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where $\comparison \in \{\le, \ge, =\}$.
\end{definition}

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$. Formally:
  \begin{align}
    \labeq{bounded-soundness}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align}
\end{remark}

\section{The \outcomesname{} Impact Definition}[\outcomesname]
\labsec{outcomes}

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\outcomes\in\tracetype\to\Rposplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      }}
  \end{align*}
\end{definition}

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}

\section{The \rangename{} Impact Definition}[\rangename]
\labsec{range}

\begin{definition}[\rangename]\labdef{range}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \length(\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      })
  \end{align*}
\end{definition}

\begin{theorem}\labthm{range-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\range$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \inputoutputsemantics \subseteq \inputoutputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}

\section{The \qusedname{} Impact Definition}[\qusedname]
\labsec{qused}

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\qused\in\tracetype\to\Nplus$ is defined as
  %
  \begin{align*}
    \qused(\defsetoftraces) \DefeQ
    \sup \setdef{
      \cardinality{&\setdef{\inputobs(\retrieveinput\defstate)(\definputvariable)}{\retrieveinput\defstate \in \state} \setminus \\ & \setdef{
        \inputobs(\retrieveinput{\defseq'})(\definputvariable)
        }{
          \deftrace,\deftrace' \in \defsetoftraces \LanD
          \\ & \qquad \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput\defstate) \LanD
          \\ & \qquad \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD
          \\ & \qquad \inputobs(\retrieveinput{\deftrace'}) \stateeq{\inputvariableswithouti} \inputobs(\retrieveinput{\deftrace})
        }}
    }{
      \retrieveoutput\defstate \in \state
    }
  \end{align*}
\end{definition}

\begin{theorem}\labthm{qused-validation}
  Whenever $\impactwrapper$ in $\revbounded$ is instantiated with $\qused$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \REVBOUNDED \IfF \inputoutputsemantics \subseteq \inputoutputabstraction(\dependencyabstraction(\REVBOUNDED))
  \end{align*}
\end{theorem}


\begin{remark}[Unused Equivalence]\labremark{qualitative-quantitative-equivalence}
  \begin{gather*}
    \unusediowrapper(\tracesemanticsnoparam) \IfF \qused(\tracesemanticsnoparam) = 0 \\
    \neg\unused \spacearound{=} \mathscr{B}_{\definputvariable}^{\ge 1}
  \end{gather*}
\end{remark}

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reduceddependencysemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}


\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
where the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\setof\pairofstates$ is defined as:
\begin{align*}\multiconcretization(\multisemantics)\buckets \DefeQ \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
\end{align*}
\end{definition}

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}

\begin{definition}[Covering]\label{def:covering}
  We say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[\filter\subseteq \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}\]
\end{definition}

\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  % For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever it holds that:
  % \[
  %   \impactwrapper(
  %     \multiconcretization(\multisemantics)\buckets
  %   ) \LE \impactinstance(\multisemantics\buckets, \buckets)
  % \]
  The concretization of the abstract implementation $\impactinstance$ is $\impactinstanceconcretization\in\valuesposplus\to\inputoutputtype$, defined as:
  \begin{align*}
    \impactinstanceconcretization(\defbound) \DefeQ
    \setdef{\defsetofdependencies \in \setof\pairofstates}{
      \impactwrapper(\defsetofdependencies) \le \defbound
    }
  \end{align*}
\end{definition}

\begin{lemma}
  \begin{align*}
    \dependencyconcretization(\inputoutputconcretization(\impactinstanceconcretization(\impactinstance(\multisemantics\buckets, \buckets)))) \subseteq \GENBOUNDED \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\bounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariable\in\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes $\filter$, \cf{} \refdef{covering}, and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) \le \defbound \ImplieS \defprogram \satisfies \bounded
  \end{align*}
\end{theorem}


\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainproject$}{Project}]\labdef{soundness-project}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, for all $\defstate \in \abstractdomainconcretization(\defstate^\natural)$, whenever it exists a state $\defstate'$ such that $\defstate \stateeq{\inputvariableswithouti} \defstate'$, then it holds that $\defstate' \in \abstractdomainconcretization(\abstractdomainproject(\defstate^\natural))$.
\end{definition}

\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}

\section{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}

\begin{definition}[Intersect All Function \texorpdfstring{$\intersectallfunction$}{}]\labdef{intersect-all-function}
  \begin{gather*}
    \intersectallfunction(X^\natural\in\vectorbuckets) \DefeQ \\
    \setdef{J}{J \subseteq \N \land \forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
  \end{gather*}
\end{definition}

\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}

\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the buckets $\buckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef{covering}, it holds that
  $\outcomes(\dependencysemanticsnoparam) \le n$.
\end{lemma}

\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item \label{proof:b1} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item \label{proof:d} $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}


\section{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainlength$}{Length}]\labdef{soundness-length}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomainlength(\defstate^\natural) \ge \length(\setdef{\outputobs(\defstate)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)})\]
\end{definition}

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}

\section{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(X^\natural, \buckets) \DefeQ& \cardinality{\inputvaluesof{\state}} -\max~  \seTDef{\abstractdomaincount(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}
