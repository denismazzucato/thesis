%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}

% \begin{itemize}
%   \item $\sup$ and $\inf$ operators;
%   \item $\length$ function;
%   \item abstract domain $\abstractdomain$
%   \item backward reachability state abstract semantics $\backwardsemanticsnoparam$.
% \end{itemize}

In this chapter, we present the quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define a few quantitative measures of input variables' impact on the program outcomes.
Then, we formalize the theoretical framework to verify the quantitative impact property of a program.
At the end, we present the abstract version of the quantitative measures and show how they can be used to verify the quantitative impact property of a program.
In the next chapters, we will present an adaptation of this quantitative notion to the context of neural network and timing side-channel attacks.

\emph{Dans ce chapitre, nous présentons la notion quantitative d'utilisation des données d'entrée, en étendant la définition introduite dans le chapitre précédent. Nous définissons quelques mesures quantitatives de l'impact des variables d'entrée sur les résultats du programme. Ensuite, nous formalisons le cadre théorique pour vérifier la propriété d'impact quantitatif d'un programme. À la fin, nous présentons la version abstraite des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier la propriété d'impact quantitatif d'un programme. Dans les prochains chapitres, nous présenterons une adaptation de cette notion quantitative au contexte des réseaux neuronaux et des attaques par canal auxiliaire temporel.}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as the amount of input data that influences the program outcomes.
To this end, we develop the \emph{$\defbound$-bounded impact property} $\genbounded$ as the set of program semantics whose input variable $\definputvariable\in\inputvariables$ has an impact on the program outcomes bounded by $\defbound\in\valuesposplus$.
We employ the notion of \emph{impact definition} $\impactwrapper\in\tracetype\to\valuesposplus$ to quantify the impact of the input variable $\definputvariable$ on the outcome from a given program semantics.


\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariable\in\variables$ the input variable of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact definition, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where $\comparison \in \{\le, \ge\}$.
\end{definition}

We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow further abstractions of computable semantics to return an always greater or smaller impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$. Formally:
  \begin{align}
    \labeq{bounded-soundness}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align}
\end{remark}

Next, we formalize the impact notions \outcomesname{}, \rangename{}, and \qusedname{}. These notions characterize the impact of the input variables each differently. Mostly, \outcomesname{} measures the number of different outcomes, \rangename{} quantify the length of outcome values, and \qusedname{} counts the number of input values used to produce the outcomes.
To this end, these definitions employ the concept of output abstraction with a further restriction on the observed outcomes. We expect the output observer $\outputobs$ to return a quantifiable element, \ie{}, a value or infinite in $\valuesinf$.
An output observer $\outputobs$ with a quantifiable element is called an \emph{output descriptor}.

\begin{definition}[Output Descriptor]
  \labdef{output-descriptor}
  An \textup{output descriptor} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
\end{definition}

The above output descriptor $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
We leverage this output descriptor to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.

\begin{example}
  Consider the~\refprog{landing-alarm-system} for the landing alarm system with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and use $\state$ as set of tuples instead of a map between variables and values, the two views are equivalent.
  The output descriptor is instantiated with
  \[
  \outputobs(x) \DefeQ \begin{cases}
    d & \text{if } x = \langle a, b, c, d \rangle \\
    +\infty & \text{otherwise}
  \end{cases}
  \]
  and $\filter=\{0,1,2,3\}$ filters $+\infty$ from the possible outputs.
  In other words, we are interested in the value of $\texttt{risk}$ for terminating traces.

  However, the end-user of the analysis may be interested in only a subset of the possible outcomes of the program.
  For instance, only about the risk levels in $\{0, 1, 2\}$, forgetting about the value $3$.
  It is crucial that our impact definitions remain sound to the user assumption on post-conditions, even when it is under-approximating the exact one.
  Thus, the filter specifies this information by $\filter=\{0, 1, 2\}$, which is a subset of all the possible values of the output variable \texttt{risk}.
\end{example}

\begin{example}
  another example where we use the output descriptor for parity as in ANI.
\end{example}

\section{The \outcomesname{} Impact Definition}[\outcomesname]
\labsec{outcomes}

\denis{Maybe add here content from the overview.}

Formally $\outcomes\in\setof\tracetype\to\Nplus$ counts the number of different output values, allowed by the output descriptor, reachable by varying the input variable $\definputvariable\in\inputvariables$.
First, we define step-by-step the quantity $\outcomes$,
followed by the instantiation of this quantity within the context of example of \refprog{landing-alarm-system}.
We present the formal definition at the end.


Intuitively,
for any possible input configuration $\definput\in\reducedstate$, we collect all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariable$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, we collect the output values of this set of traces by means of the output descriptor $\outputdesc$, \ie, $\setdef{
  \reader(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$. Specifically, this set contains all the output readings performed by $\reader$.
%
Afterwards, we extract the number of elements via the cardinality operator $\cardinality{\cdot}$.
Finally, we iterate through each input configuration $\definput$ and return the maximum value to ensure the greatest impact is preserved.

\begin{example}[Landing Alarm System]
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  Let us revisit the example of the landing alarm system, with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  The input variables are $\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input configurations are
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariable=\texttt{angle}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \reader(\retrieveoutput\defseq)
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinality{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  \reftab{overview} (column \textsc{Outcomes}) illustrate the steps for $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and $\outcomesname_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ respectively.
\end{example}

Formally, the $\outcomesname$ impact definition is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      }}
  \end{align*}
\end{definition}

We note that the above definition is monotone in the amount of traces provided as input.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}

We show the validation of the $\defbound$-impact property when applied to $\outcomesname$.

\begin{theorem}\labthm{outcomes-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\outcomes$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}

\section{The \rangename{} Impact Definition}[\rangename]
\labsec{range}

The quantity $\range\in\setof\tracetype\to\Rposplus$ determines the
length of the range of output values from all the possible variations in the input variable $\definputvariable\in\inputvariables$.

\begin{example}[Landing Alarm System]
  \labexample{range}
  We revisit again the example of the landing alarm system.
  Assuming $\definputvariable=\texttt{angle}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$.
%
  Here, we apply the function $\length$, hence $\length(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  \reftab{overview} illustrates the steps for both $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and $\rangename_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ quantity is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \length(\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      })
  \end{align*}
\end{definition}

As done for the previous impact quantity, we note that $\rangename$ is monotonic in the amount of traces.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}

We show the validation of the $\defbound$-bounded impact property when applied to $\rangename$.

\begin{theorem}\labthm{range-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\range$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}

\section{The \qusedname{} Impact Definition}[\qusedname]
\labsec{qused}

The quantity $\qused\in\setof\tracetype\to\Nplus$ counts the number of input values that are not used to produce the outcomes.
This definition is of significant importance as it natively handles non-deterministic systems.

For each possible outcome state $\retrieveoutput\defstate\in\state$ and trace $\deftrace\in\defsetoftraces$ that holds the same output abstraction, \ie{} $\outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput\defstate)$, we collect the set of input values of $\definputvariable$ that can produce this outcome $\retrieveoutput\defstate$.
More specifically, we collect the set of input values that belong to traces $\deftrace'$ that have the same output abstraction as $\deftrace$, \ie{} $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)$, and are a variation of $\deftrace$ on the input variables $\inputvariableswithouti$.
Then, we obtain the number of missing input values by subtracting the set of all input values from the set of input values that can produce the outcome $\retrieveoutput\defstate$.
We return the maximum number of input values that are not used to produce the outcomes.

\begin{example}
  \denis{3 examples: id, random, mix}
\end{example}

Formally, the $\qusedname$ quantity is defined as follows:

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\qused\in\tracetype\to\Nplus$ is defined as
  %
  \begin{align*}
    \qused(\defsetoftraces) \DefeQ
    \sup \setdef{
      \cardinality{&\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state} \setminus \\ & \setdef{
        \retrieveinput{\defseq'}(\definputvariable)
        }{
          \deftrace' \in \defsetoftraces \LanD
          \\ & \qquad \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD
          \\ & \qquad \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
        }}
    }{
      \retrieveoutput\defstate \in \state
    }
  \end{align*}
\end{definition}

We show that $\qusedname$ is (anti-)monotonic in the amount of traces for non-empty sets of traces.

\begin{lemma}[\qusedname{} is Anti-Monotonic]
  \lablemma{qused-antimonotonic}
  For any non-empty set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \neq \emptyset \LanD \defsetoftraces \subseteq \defsetoftraces' \ImplieS \qused(\defsetoftraces) \ge \qused(\defsetoftraces')
  \end{align*}
\end{lemma}

In fact, $\qused(\emptyset) = \cardinalitynospaces{\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate\in\state}}$, the highest possible value for $\qusedname$. This is due to the fact that no trace is available to produce the outcomes. Instead, by considering set of traces with at least one trace, the value of $\qusedname$ always increases by enlarging the set of traces.

Next we show the validation of the $\defbound$-bounded impact property when applied to $\qusedname$.

\begin{theorem}\labthm{qused-validation}
  Whenever $\impactwrapper$ in $\revbounded$ is instantiated with $\qused$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \REVBOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\REVBOUNDED))
  \end{align*}
\end{theorem}

Differently from the previous impact definitions, it holds that whenever $\qused(\tracesemanticsnoparam) = 0$, the program does not use the input variable $\definputvariable$, even in the presence of non-deterministic systems.
Thus, we can establish the following equivalence:

\begin{remark}[Unused Equivalence]\labremark{qualitative-quantitative-equivalence}
  \begin{gather*}
    \unusediowrapper(\tracesemanticsnoparam) \IfF \qused(\tracesemanticsnoparam) = 0 \\
    \neg\unused \spacearound{=} \mathscr{B}_{\definputvariable}^{\ge 1}
  \end{gather*}
\end{remark}

In the rest of this chapter, we present the theoretical framework to verify the $\defbound$-bounded impact property of a program and show the abstract version of the quantitative measures.

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

In this section, we introduce a sound and computable static analysis to verify the $\defbound$-bounded impact property of a program.
The soundness of the approach leverages two elements: (1) the backward abstract semantics (\cf{} \refdef{?}), and (2) sound and computable implementations of the quantitative measures \outcomesname{}, \rangename{}, and \qusedname{}, written as $\abstractoutcomes$, $\abstractrange$, and $\abstractqused$ respectively.


To quantify the usage of an input variable, we need to determine the input configurations leading to specific output values.
As our impact definitions $\outcomes$ and $\range$ measure over the different output values (i.e., $\reader(\retrieveoutput{\defstate})$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is essential for obtaining a precise and meaningful analysis result.

For each output bucket $\bucket\in\abstractdomain$ where $j \le n$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
More formally, the reduction of the dependency semantics $\dependencysemanticsnoparam$ to the dependencies with final states in $X$ is defined as:
\[\reduce[\dependencysemanticsnoparam]{X} \DefeQ \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in X}\]
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemanticsnoparam\in\backwardtype$ which computes the backward semantics $\backwardsemanticsnoparam(\bucket)$ from a given output bucket $\bucket\in\abstractdomain$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\setof\pairofstates$ employs %the abstract concretization
$\abstractdomainconcretization$ to restore all possible input-output dependencies, formally:
\[\backwardconcretization(\backwardsemanticsnoparam)\bucket \DefeQ \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam\bucket)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}\]
We can thus define the soundness condition for the backward semantics with respect to the reduction of the dependency semantics.


\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reduceddependencysemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$ as follows:

\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
where the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\setof\pairofstates$ is defined as:
\begin{align*}\multiconcretization(\multisemantics)\buckets \DefeQ \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
\end{align*}
\end{definition}

Next, we show the soundness of the multi-bucket semantics with respect to the dependency semantics.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}
\begin{proof}
  \begin{align*}
    &\vphantom{=} \multiconcretization(\multisemanticsnoparam)\buckets
      && \text{by $\multiconcretization$} \\
    &= \bigsetjoin_{j \le n}\setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemanticsnoparam(\buckets))_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\multisemanticsnoparam$} \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(((\backwardsemanticsnoparam(\bucket[t]))_{t\le n})_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \\
    &= \bigsetjoin_{j \le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
    && \text{by $\backwardconcretization$} \\
    &= \bigsetjoin_{j \le n} \backwardconcretization(\backwardsemanticsnoparam)\bucket
  \end{align*}
  From \refdef{sound-over-approximation}, we obtain that $\foralldef{j \le n}{\reduceddependencysemanticsnoparam \subseteq \backwardconcretization(\backwardsemanticsnoparam(\bucket))}$.
  Thus, by monotonicity of the union operator over set inclusion, it holds that $\bigsetjoin_{j\le n}\reduceddependencysemanticsnoparam \subseteq \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$. We conclude by:
  \begin{align*}
    \bigsetjoin_{j\le n}\reduceddependencysemanticsnoparam &= \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$} \\
    &= \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by set definition} \\
    &= \reducenoparam{\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$}
  \end{align*}
  \end{proof}


Whenever the output buckets \textit{cover} the subset of potential outcomes $\filter$, $\multisemanticsnoparam$ is a sound over-approximation of $\dependencysemanticsnoparam$.
The concept of covering for output buckets ensures that no potential final state is missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  We say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[\filter\subseteq \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}\]
\end{definition}

Additionally, the output buckets needs to be compatible with the concrete outcomes of the program, meaning that two output states cannot map to the same output abstraction if they belong to different output buckets.

\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}

We expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher (or lower depending on the ordering operator of $\genbounded$) than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  % For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever it holds that:
  % \[
  %   \impactwrapper(
  %     \multiconcretization(\multisemantics)\buckets
  %   ) \LE \impactinstance(\multisemantics\buckets, \buckets)
  % \]
  The concretization of the abstract implementation $\impactinstance$ is $\impactinstanceconcretization\in\valuesposplus\to\inputoutputtype$, defined as:
  \begin{align*}
    \impactinstanceconcretization(\defbound) \DefeQ
    \setdef{\defsetofdependencies \in \setof\pairofstates}{
      \impactwrapper(\defsetofdependencies) \le \defbound
    }
  \end{align*}
\end{definition}



\begin{lemma}
  \begin{align*}
    \dependencyconcretization(\inputoutputconcretization(\impactinstanceconcretization(\impactinstance(\multisemantics\buckets, \buckets)))) \subseteq \GENBOUNDED \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}

The next result shows that our static analysis is sound when employed to verify the property of interest $\bounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\le\defbound$, then the program $\defprogram$ satisfies the property $\bounded$, \cf{} $\defprogram \satisfies \bounded$.

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\bounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariable\in\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes $\filter$, \cf{} \refdef{covering}, and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) \le \defbound \ImplieS \defprogram \satisfies \bounded
  \end{align*}
\end{theorem}


Finally,
we define $\abstractrange$, $\abstractoutcomes$, and $\abstractqused$
as possible implementations for $\range$ and $\outcomes$, respectively.

%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variable $\definputvariable$.
For example, in the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainproject(\langle\definputvariable \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariable \mapsto [-\infty, \infty], j \mapsto [2, 4] \rangle$
removes the constraints related to $\definputvariable$.
%
We assume a soundness condition on the project operator to ensure that $\abstractdomainproject(\defstate^\natural)$ represents all the concrete states result of perturbations on the variable $\definputvariable$ from a state represented by an abstract value $\defstate^\natural$.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainproject$}{Project}]\labdef{soundness-project}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, for all $\defstate \in \abstractdomainconcretization(\defstate^\natural)$, whenever it exists a state $\defstate'$ such that $\defstate \stateeq{\inputvariableswithouti} \defstate'$, then it holds that $\defstate' \in \abstractdomainconcretization(\abstractdomainproject(\defstate^\natural))$.
\end{definition}
The above condition ensures that no intersection is missed, potentially spurious ones are allowed by the abstraction.

\section{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}


The definition of $\abstractoutcomes$ first projects away the input variable $\definputvariable$ from all the given abstract values, then it collects all intersecting abstract values via the meet operator $\abstractdomainmeet$.
These intersections represent potential concrete input configurations where variations on the value of $\definputvariable$ lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersects after projections:
\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refdef*{outcomes}) since the number of intersecting abstract values is bounded by $n$, the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:

\begin{definition}[Intersect All Function \texorpdfstring{$\intersectallfunction$}{}]\labdef{intersect-all-function}
  \begin{gather*}
    \intersectallfunction(X^\natural\in\vectorbuckets) \DefeQ \\
    \setdef{J}{J \subseteq \N \land \forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
  \end{gather*}
\end{definition}


Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidetextcite{Bron1973}.
%

In order to prove that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$, we require the output buckets $\buckets$ to be \textit{compatible} with the output descriptor $\reader$.
Intuitively, compatibility ensures that the counting intersecting buckets in the abstract does not miss any concrete outcome.
%
\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\reader\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\reader$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\reader(\defstate_j) \neq \reader(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}
%
Note that, $\outcomes$ is bounded by the number of buckets when the conditions of covering and compatibility hold for the output buckets.
\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the buckets $\buckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef{covering}, it holds that
  $\outcomes(\dependencysemanticsnoparam) \le n$.
\end{lemma}
\begin{proof}
  We notice that $\outcomes(\dependencysemanticsnoparam) \le \cardinalitynospaces{\setdef{\reader(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\finalstatesdependency}}$ as the set of outputs for the dependency semantics is always bigger than any set of outputs.
  It is easy to note that the cardinality of $\setdef{\reader(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\finalstatesdependency}$ is upper bounded by $n$ since any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\reader(\retrieveoutput\defstate) \neq \reader(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$ (by compatibility, \cf{} \refdef{compatibility}).
  Where the existence of the two buckets is guaranteed by covering (\cf{} \refdef{covering}).
  Therefore, there are at most $n$ different output readings.
\end{proof}

The next result shows that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete impact $\outcomes$.

\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item \label{proof:b1} $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item \label{proof:d} $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}
\begin{proof}
  From \ref{proof:a}, \ref{proof:b2}, and the fact that $\outcomes$ is monotone, we obtain that $\outcomes(\dependencysemanticsnoparam) \le \outcomes(\multiconcretization(\multisemanticsnoparam)\buckets)$.
  By definitions of $\abstractoutcomes$, \cf{} \refdef{abstract-outcomes}, and $\outcomes$, \cf{} \refdef{outcomes}, we need to show that:
  \begin{gather*}
    \outcomes(\dependencysemanticsnoparam) = \sup_{\definputvariable\in\reducedstate}
    \cardinality{\setdef{\reader(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\inputvariableswithouti} \definputvariable}} \\
    \le \\
    \abstractoutcomes(X^\natural, \buckets) = \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{gather*}
  where $X^\natural = \multisemanticsnoparam(\buckets)$.
%
  First, from \ref{proof:b1} and \reflemma{outcomes-upper-bound} we know that $\outcomes$ is limited by the number of buckets $n$.
  Notably, $\outcomes$ cannot be unbounded, but it has to be a number, at most $n$. Thus, it exists an initial state $\overline\defstate\in\reducedstate$ such that $\outcomes(\dependencysemanticsnoparam) = \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$, where $\defsetoftraces{\overline\defstate} = \setdef{\reader(\retrieveoutput{\defstate})}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam\land\retrieveinput\defstate \stateeq{\inputvariableswithouti} \overline\defstate}$.
  We conclude in case this cardinality is $0$ as anything returned by $\abstractoutcomes$ would be greater. In the other case, by covering (\cf{} \ref{proof:b2}), for all dependencies in $\defsetoftraces{\overline\defstate}$
  it exists a bucket $\bucket$ such that $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket)$.

  Furthermore, by compatibility (\cf{} \ref{proof:b1}), for any pair $\inputoutputtuple\defstate, \inputoutputtuple{\defstate'}\in\defsetoftraces{\overline\defstate}$ leading to two different outcomes $\reader(\retrieveoutput{\defstate}) \neq \reader(\retrieveoutput{\defstate'})$, we have two different buckets $\bucket, \bucket[p]$ such that $\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)$ and $\retrieveoutput{\defstate'}\in\abstractdomainconcretization(\bucket[p])$.
  Note that, by definition of $\defsetoftraces{\overline\defstate}$ it holds that $\retrieveinput\defstate \stateeq{\inputvariableswithouti} \overline{\defstate} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate'}$, by transitivity $\retrieveinput\defstate \stateeq{\inputvariableswithouti} \retrieveinput{\defstate'}$.

  Let us call $\prefrombucket$ and $\prefrombucket[p]$ the corresponding abstract values from the backward analysis applied to the buckets $\bucket$ and $\bucket[p]$, respectively.
  From the fact that $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \ref{proof:a}, it holds that $\retrieveinput\defstate \in \abstractdomainconcretization(\prefrombucket)$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\prefrombucket[p])$.
  By the soundness condition of $\abstractdomainproject$, \cf{} \ref{proof:d}, we obtain that both states $\retrieveinput\defstate$ and $\retrieveinput\defstate'$ belong to each other projection, \ie, $\retrieveinput\defstate \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket))$ and $\retrieveinput{\defstate'} \in \abstractdomainconcretization(\abstractdomainproject(\prefrombucket[p]))$.

  Finally, the function \intersectallfunction{} applied to the projected preconditions $\prefrombucket$ and $\prefrombucket[p]$ finds an intersection between the indices $j$ and $p$ as $\abstractdomainproject(\prefrombucket) \abstractdomainmeet \abstractdomainproject(\prefrombucket[p])$ definitely holds since they share concrete states. Therefore, whenever it exists an intersection in the concrete, the two indices representing the respective precondition discovered by the backward analysis belong to the set $J$ in \refdef{abstract-outcomes}.
  As a consequence, the maximum cardinality of $J$ takes into account all the possible intersections in $\defsetoftraces{\overline\defstate}$, hence $\abstractoutcomes(X^\natural, \buckets) \ge \cardinalitynospaces{\defsetoftraces{\overline\defstate}}$.
\end{proof}




\section{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

Similarly, we define $\abstractrange$ as the maximum length of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomainlength\in\abstractdomain\to\valuesposplus$, which returns the length of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

To prove that $\abstractrange$ is a sound implementation of $\range$, we require the following soundness condition on the abstract operator $\abstractdomainlength$ to ensure that the abstract length is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainlength$}{Length}]\labdef{soundness-length}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomainlength(\defstate^\natural) \ge \length(\setdef{\reader(\defstate)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)})\]
\end{definition}

As previously done, the next result shows that the abstract impact $\abstractrange$ is a sound over-approximation of the concrete impact $\range$, \cf{}\refdef*{range}.

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}

\section{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

We define $\abstractqused$ as the difference between the total number of input configurations and the maximum number of input configurations leading to the same output reading.

\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(X^\natural, \buckets) \DefeQ& \cardinality{\inputvaluesof{\state}} -\max~  \seTDef{\abstractdomaincount(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

To prove that $\abstractqused$ is a sound implementation of $\qused$, we require the following soundness condition on the abstract operator $\abstractdomaincount$ to ensure that the abstract count is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaincount$}{Count}]\labdef{soundness-count}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomaincount(\defstate^\natural) \ge \cardinality{\setdef{\retrieveinput{\defstate}(\definputvariable)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}}\]
\end{definition}

The next result shows that the abstract impact $\abstractqused$ is a sound over-approximation of the concrete impact $\qused$, \cf{} \refdef{qused}.

\begin{lemma}[$\abstractqused$ is a Sound Implementation of $\qused$]\lablemma{abstractqused-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\reader$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractqused$ is a sound implementation of $\qused$.
\end{lemma}

\section{Summary}
\labsec{quantitative-input-data-usage-summary}

In this chapter, we introduced the quantitative measures $\outcomes$, $\range$, and $\qused$ to quantify the impact of input variables on the output of a program.
We developed a theoretical framework to verify the $\defbound$-bounded impact property of a program and showed the abstract versions of the quantitative measures.
In the next chapter, we show how we handle the quantification of input usage and bias in the context of neural network models.
