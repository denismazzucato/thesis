%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}

% \begin{itemize}
%   \item $\sup$ and $\inf$ operators;
%   \item $\length$ function;
%   \item abstract domain $\abstractdomain$
%   \item backward reachability state abstract semantics $\backwardsemanticsnoparam$.
% \end{itemize}

In this chapter, we present the quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define a few quantitative measures of input variables' impact on the program outcomes.
Then, we formalize the theoretical framework to verify the quantitative impact property of a program.
At the end, we present the abstract version of the quantitative measures and show how they can be used to verify the quantitative impact property of a program.
In the next chapters, we will present an adaptation of this quantitative notion to the context of neural network and timing side-channel attacks.

\emph{Dans ce chapitre, nous présentons la notion quantitative d'utilisation des données d'entrée, en étendant la définition introduite dans le chapitre précédent. Nous définissons quelques mesures quantitatives de l'impact des variables d'entrée sur les résultats du programme. Ensuite, nous formalisons le cadre théorique pour vérifier la propriété d'impact quantitatif d'un programme. À la fin, nous présentons la version abstraite des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier la propriété d'impact quantitatif d'un programme. Dans les prochains chapitres, nous présenterons une adaptation de cette notion quantitative au contexte des réseaux neuronaux et des attaques par canal auxiliaire temporel.}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Definitions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as the amount of input data that influences the program outcomes.
To this end, we develop the \emph{$\defbound$-bounded impact property} $\genbounded$ as the set of program semantics whose input variable $\definputvariable\in\inputvariables$ has an impact on the program outcomes bounded by $\defbound\in\valuesposplus$.
We employ the notion of \emph{impact definition} $\impactwrapper\in\tracetype\to\valuesposplus$ to quantify the impact of the input variable $\definputvariable$ on the outcome from a given program semantics.


\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariable\in\variables$ the input variable of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact definition, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where $\comparison \in \{\le, \ge\}$.
\end{definition}

We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow further abstractions of computable semantics to return an always greater or smaller impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$. Formally:
  \begin{align}
    \labeq{bounded-soundness}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align}
\end{remark}

Next, we formalize the impact notions \outcomesname{}, \rangename{}, and \qusedname{}. These notions characterize the impact of the input variables each differently. Mostly, \outcomesname{} measures the number of different outcomes, \rangename{} quantify the length of outcome values, and \qusedname{} counts the number of input values used to produce the outcomes.
To this end, these definitions employ the concept of output abstraction with a further restriction on the observed outcomes. We expect the output observer $\outputobs$ to return a quantifiable element, \ie{}, a value or infinite in $\valuesinf$.
An output observer $\outputobs$ with a quantifiable element is called an \emph{output descriptor}.

\begin{definition}[Output Descriptor]
  \labdef{output-descriptor}
  An \textup{output descriptor} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
\end{definition}

The above output descriptor $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
We leverage this output descriptor to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.

\begin{example}
  Consider the~\refprog{landing-alarm-system} for the landing alarm system with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and use $\state$ as set of tuples instead of a map between variables and values, the two views are equivalent.
  The output descriptor is instantiated with
  \[
  \outputobs(x) \DefeQ \begin{cases}
    d & \text{if } x = \langle a, b, c, d \rangle \\
    +\infty & \text{otherwise}
  \end{cases}
  \]
  and $\filter=\{0,1,2,3\}$ filters $+\infty$ from the possible outputs.
  In other words, we are interested in the value of $\texttt{risk}$ for terminating traces.

  However, the end-user of the analysis may be interested in only a subset of the possible outcomes of the program.
  For instance, only about the risk levels in $\{0, 1, 2\}$, forgetting about the value $3$.
  It is crucial that our impact definitions remain sound to the user assumption on post-conditions, even when it is under-approximating the exact one.
  Thus, the filter specifies this information by $\filter=\{0, 1, 2\}$, which is a subset of all the possible values of the output variable \texttt{risk}.
\end{example}

\section{The \outcomesname{} Impact Definition}[\outcomesname]
\labsec{outcomes}

Formally $\outcomes\in\setof\tracetype\to\Nplus$ counts the number of different output values, allowed by the output descriptor, reachable by varying the input variable $\definputvariable\in\inputvariables$.
First, we define step-by-step the quantity $\outcomes$,
followed by the instantiation of this quantity within the context of example of \refprog{landing-alarm-system}.
We present the formal definition at the end.


Intuitively,
for any possible input configuration $\definput\in\reducedstate$, we collect all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariable$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, we collect the output values of this set of traces by means of the output descriptor $\outputdesc$, \ie, $\setdef{
  \reader(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\inputvariableswithouti} \definput
}$. Specifically, this set contains all the output readings performed by $\reader$.
%
Afterwards, we extract the number of elements via the cardinality operator $\cardinality{\cdot}$.
Finally, we iterate through each input configuration $\definput$ and return the maximum value to ensure the greatest impact is preserved.

\begin{example}[Landing Alarm System]
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  Let us revisit the example of the landing alarm system, with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  The input variables are $\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input configurations are
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariable=\texttt{angle}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \reader(\retrieveoutput\defseq)
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinality{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  \reftab{overview} (column \textsc{Outcomes}) illustrate the steps for $\outcomesname_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and $\outcomesname_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ respectively.
\end{example}

Formally, the $\outcomesname$ impact definition is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      }}
  \end{align*}
\end{definition}

We note that the above definition is monotone in the amount of traces provided as input.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}

We show the validation of the $\defbound$-impact property when applied to $\outcomesname$.

\begin{theorem}\labthm{outcomes-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\outcomes$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}

\section{The \rangename{} Impact Definition}[\rangename]
\labsec{range}

The quantity $\range\in\setof\tracetype\to\Rposplus$ determines the
length of the range of output values from all the possible variations in the input variable $\definputvariable\in\inputvariables$.

\begin{example}[Landing Alarm System]
  \labexample{range}
  We revisit again the example of the landing alarm system.
  Assuming $\definputvariable=\texttt{angle}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$.
%
  Here, we apply the function $\length$, hence $\length(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  \reftab{overview} illustrates the steps for both $\rangename_{\texttt{angle}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and $\rangename_{\texttt{speed}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ quantity is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \length(\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \inputobs(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \inputobs(\definput)
      })
  \end{align*}
\end{definition}

As done for the previous impact quantity, we note that $\rangename$ is monotonic in the amount of traces.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For any set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}

We show the validation of the $\defbound$-bounded impact property when applied to $\rangename$.

\begin{theorem}\labthm{range-validation}
  Whenever $\impactwrapper$ in $\bounded$ is instantiated with $\range$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDED))
  \end{align*}
\end{theorem}

\section{The \qusedname{} Impact Definition}[\qusedname]
\labsec{qused}

The quantity $\qused\in\setof\tracetype\to\Nplus$ counts the number of input values used to produce the outcomes.
This definition is of significant importance as it natively handles non-deterministic systems.

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariable\in\inputvariables$,
  the quantity $\qused\in\tracetype\to\Nplus$ is defined as
  %
  \begin{align*}
    \qused(\defsetoftraces) \DefeQ
    \sup \setdef{
      \cardinality{&\setdef{\retrieveinput\defstate(\definputvariable)}{\retrieveinput\defstate \in \state} \setminus \\ & \setdef{
        \retrieveinput{\defseq'}(\definputvariable)
        }{
          \deftrace,\deftrace' \in \defsetoftraces \LanD
          \\ & \qquad \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput\defstate) \LanD
          \\ & \qquad \outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate) \LanD
          \\ & \qquad \retrieveinput{\deftrace'} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace}
        }}
    }{
      \retrieveoutput\defstate \in \state
    }
  \end{align*}
\end{definition}

\begin{theorem}\labthm{qused-validation}
  Whenever $\impactwrapper$ in $\revbounded$ is instantiated with $\qused$, the following holds:
  \begin{align*}
    \collectingsemantics \subseteq \REVBOUNDED \IfF \inputoutputsemantics \subseteq \inputoutputabstraction(\dependencyabstraction(\REVBOUNDED))
  \end{align*}
\end{theorem}


\begin{remark}[Unused Equivalence]\labremark{qualitative-quantitative-equivalence}
  \begin{gather*}
    \unusediowrapper(\tracesemanticsnoparam) \IfF \qused(\tracesemanticsnoparam) = 0 \\
    \neg\unused \spacearound{=} \mathscr{B}_{\definputvariable}^{\ge 1}
  \end{gather*}
\end{remark}

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reduceddependencysemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}


\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
where the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\setof\pairofstates$ is defined as:
\begin{align*}\multiconcretization(\multisemantics)\buckets \DefeQ \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
\end{align*}
\end{definition}

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}

\begin{definition}[Covering]\label{def:covering}
  We say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[\filter\subseteq \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}\]
\end{definition}

\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output descriptor $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  % For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever it holds that:
  % \[
  %   \impactwrapper(
  %     \multiconcretization(\multisemantics)\buckets
  %   ) \LE \impactinstance(\multisemantics\buckets, \buckets)
  % \]
  The concretization of the abstract implementation $\impactinstance$ is $\impactinstanceconcretization\in\valuesposplus\to\inputoutputtype$, defined as:
  \begin{align*}
    \impactinstanceconcretization(\defbound) \DefeQ
    \setdef{\defsetofdependencies \in \setof\pairofstates}{
      \impactwrapper(\defsetofdependencies) \le \defbound
    }
  \end{align*}
\end{definition}

\begin{lemma}
  \begin{align*}
    \dependencyconcretization(\inputoutputconcretization(\impactinstanceconcretization(\impactinstance(\multisemantics\buckets, \buckets)))) \subseteq \GENBOUNDED \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\bounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariable\in\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes $\filter$, \cf{} \refdef{covering}, and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) \le \defbound \ImplieS \defprogram \satisfies \bounded
  \end{align*}
\end{theorem}


\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainproject$}{Project}]\labdef{soundness-project}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, for all $\defstate \in \abstractdomainconcretization(\defstate^\natural)$, whenever it exists a state $\defstate'$ such that $\defstate \stateeq{\inputvariableswithouti} \defstate'$, then it holds that $\defstate' \in \abstractdomainconcretization(\abstractdomainproject(\defstate^\natural))$.
\end{definition}

\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}

\section{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}

\begin{definition}[Intersect All Function \texorpdfstring{$\intersectallfunction$}{}]\labdef{intersect-all-function}
  \begin{gather*}
    \intersectallfunction(X^\natural\in\vectorbuckets) \DefeQ \\
    \setdef{J}{J \subseteq \N \land \forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
  \end{gather*}
\end{definition}

\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(X^\natural, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{equation*}
\end{definition}

\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the buckets $\buckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef{covering}, it holds that
  $\outcomes(\dependencysemanticsnoparam) \le n$.
\end{lemma}

\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item \label{proof:b1} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item \label{proof:d} $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{lemma}


\section{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomainlength$}{Length}]\labdef{soundness-length}
  Given an abstract value $\defstate^\natural\in\abstractdomain$, it holds that:
  \[\abstractdomainlength(\defstate^\natural) \ge \length(\setdef{\outputobs(\defstate)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)})\]
\end{definition}

\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let  $\definputvariable\in\variables$ the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation},
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef{covering},
    \item $\buckets$ is compatible with $\outputobs$, \cf{} \refdef{compatibility}, and
    \item $\abstractdomainproject$ is sound, \cf{} \refdef{soundness-project};
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$.
\end{lemma}

\section{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(X^\natural, \buckets) \DefeQ& \cardinality{\inputvaluesof{\state}} -\max~  \seTDef{\abstractdomaincount(K)}{K \in I} \\
    \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
  \end{align*}
\end{definition}
