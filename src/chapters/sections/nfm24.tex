\pagelayout{wide} % No margins
\addpart{Quantitative Verification of Extensional Properties}
\labpart{extensional}
\pagelayout{margin} % Restore margins

\setchapterpreamble[u]{\margintoc}
%

\chapter{Quantitative Input Data Usage}
\labch{quantitative-input-data-usage}


In this chapter, we present a quantitative notion of input data usage, extending the definition introduced in the previous chapter.
We define three different quantifiers for the impact of the input variables on the program outcome, and we formalize a static analysis for verifying the resulting quantitative impact property.
At the end, we present the abstract versions of these quantifiers and show how they can be used to verify the corresponding quantitative property.
This chapter is based on work published at NASA Formal Methods Symposium (NFM) 2024 \cite{Mazzucato2024b}.
Later in this thesis, we will apply our quantitative framework in the context of neural networks and timing side-channel attacks.

\frenchdiv

\emph{Dans ce chapitre, nous présentons une notion quantitative de l'utilisation des données d'entrée, en étendant la définition introduite dans le chapitre précédent. Nous définissons trois mesures quantitatives différentes pour l'impact des variables d'entrée sur le résultat du programme, et nous formalisons une analyse statique pour vérifier la propriété d'impact quantitatif résultante d'un programme. À la fin, nous présentons des versions abstraites des mesures quantitatives et montrons comment elles peuvent être utilisées pour vérifier la propriété quantitative correspondante. Ce chapitre est basé sur un travail publié au Symposium sur les Méthodes Formelles de la NASA (NFM) 2024 \sidecite{Mazzucato2024b}. Dans le reste de cette thèse, nous appliquerons ce cadre quantitatif dans le contexte des réseaux neuronaux et des attaques par canal auxiliaire temporel.}

% \onlysectioncommands{\x,\y,\z,\lc,\exampleinput,\highlight,\inputa,\inputax,\inputay,\outputa,\inputb,\inputbx,\inputby,\outputb,\inputc,\inputcx,\inputcy,\outputc,\inputd,\inputdx,\inputdy,\outputd,\inpute,\inputex,\inputey,\outpute,\inputf,\inputfx,\inputfy,\outputf,\tracea,\traceax,\traceay,\traceb,\tracebx,\traceby,\tracec,\tracecx,\tracecy,\traced,\tracedx,\tracedy,\tracee,\traceex,\traceey,\tracef,\tracefx,\tracefy,\labelrotationangle, \outputvaluea,\outputvalueb,\outputvaluec,\outputvalued,\outputvaluee,\outputvaluef}


% \input{src/chapters/extensional/nfm24/overview.tex}
% \input{src/chapters/extensional/nfm24/quantitative-input-data-usage}
% % \input{src/chapters/extensional/nfm24/hierarchy}
% \input{src/chapters/extensional/nfm24/static-analysis}
% \input{src/chapters/extensional/nfm24/impatto}


\section{The \texorpdfstring{$\defbound$}{k}-Bounded Impact Property}
\labsec{k-bounded-impact-property}

Quantitative input data usage should be understood as quantifying how much the input data influences the program outcome.
To this end, we define the \emph{$\defbound$-bounded impact property}
$\genbounded$ as the set of program semantics such that the input variables
$\definputvariables\in\setof\inputvariables$ have an impact on the program outcome bounded by
$\defbound\in\valuesposplus$.
\marginnote{
  The set $\setof\inputvariables$ contains the input variables of a program.
}
\marginnote{
The set $\valuesposplus$ contains non-negative numerical values as well as with $+\infty$.
}
Depending on the comparison operator $\comparison\in\{\le,\ge\}$, the impact quantity is bounded by $\defbound$ either from above or below.
We employ the \emph{impact quantifier}:
\[\impactwrapper\in\tracetype\to\valuesposplus\]
to quantify the impact of the input variables $\definputvariables$ on the outcome of program computations.

\marginnote[*2]{
  As a comparison, here is the definition of the qualitative counterpart $\unused$:
  \begin{named}[\nrefdef{unused}]%
    \input{src/propositions/unused-short}%
  \end{named}%
}
\begin{definition}[$\defbound$-Bounded Impact Property]
  \labdef{bounded}
  Let $\definputvariables\in\setof\inputvariables$ be the set of input variables of interest, $\impactwrapper\in\tracetype\to\valuesposplus$ an impact quantifier, and $\defbound\in\valuesposplus$ the threshold.
  The \emph{$\defbound$-bounded impact property} $\genbounded$ is defined as follows:
  \begin{align*}
    \GENBOUNDED \DefeQ \setdef
    {\tracesemanticsnoparam \in \tracetype}
    {\impactwrapper(\tracesemanticsnoparam) \comparison \defbound}
  \end{align*}
  where the comparison operator $\comparison$ is either $\le$ or $\ge$.
\end{definition}


We allow the measured impact to be either less than or equal to ($\le$) or greater than or equal to ($\ge$) the threshold $\defbound$.
With such a definition, we allow abstractions of program semantics to return an always greater or, respectively, an always smaller impact than the actual one and thus provide a sound over-approximation of the impact property.

\begin{remark}
  A program $\defprogram$ satisfies the $\defbound$-bounded impact property $\genbounded$ if and only if the collecting semantics of $\defprogram$ implies $\genbounded$, formally:
  \begin{align*}
    \defprogram \satisfies \GENBOUNDED \IfF \collectingsemantics \subseteq \GENBOUNDED
  \end{align*}
\end{remark}

\begin{marginfigure}[*-5]
  \centering
  \resizebox{\textwidth}{!}{
    \begin{tikzpicture}
      % Parameters for the first ellipse
      \def\centerxone{0}
      \def\centeryone{0}
      \def\xradiusone{0.7}
      \def\yradiusone{1}
      \def\angleone{70}

      % Parameters for the second ellipse
      \def\centerxtwo{0.15}
      \def\centerytwo{0.25}
      \def\xradiustwo{1.25}
      \def\yradiustwo{1.5}
      \def\angletwo{68}

      % Parameters for the third ellipse
      \def\centerxthree{0.3}
      \def\centerythree{0.5}
      \def\xradiusthree{2}
      \def\yradiusthree{2}
      \def\anglethree{60}

      % Parameters for the fourth ellipse
      \def\centerxfour{0.4}
      \def\centeryfour{0.75}
      \def\xradiusfour{2.5}
      \def\yradiusfour{2.6}
      \def\anglefour{45}

      % Parameters for the fifth ellipse
      \def\centerxfive{0.5}
      \def\centeryfive{1}
      \def\xradiusfive{3}
      \def\yradiusfive{3.25}
      \def\anglefive{40}

      % Draw the first ellipse
      \draw (\centerxone,\centeryone) ellipse (\xradiusone cm and \yradiusone cm);
      \node[fill=white] at ({\centerxone + \xradiusone*cos(\angleone)}, {\centeryone + \yradiusone*sin(\angleone)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\le}{5pt}0}]$};

      % Draw the second ellipse
      \draw (\centerxtwo,\centerytwo) ellipse (\xradiustwo cm and \yradiustwo cm);
      \node[fill=white] at ({\centerxtwo + \xradiustwo*cos(\angletwo)}, {\centerytwo + \yradiustwo*sin(\angletwo)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\le}{5pt}1}]$};

      % Draw the third ellipse
      \draw (\centerxthree,\centerythree) ellipse (\xradiusthree cm and \yradiusthree cm);
      \node[fill=white] at ({\centerxthree + \xradiusthree*cos(\anglethree)}, {\centerythree + \yradiusthree*sin(\anglethree)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\le}{5pt}2}]$};

      % Draw the fourth ellipse
      \draw (\centerxfour,\centeryfour) ellipse (\xradiusfour cm and \yradiusfour cm);
      \node[fill=white] at ({\centerxfour + \xradiusfour*cos(\anglefour)}, {\centeryfour + \yradiusfour*sin(\anglefour)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\le}{5pt}3}]$};

      % Draw the fifth ellipse
      \node[fill=white] at ({\centerxfive + \xradiusfive*cos(\anglefive)}, {\centeryfive + \yradiusfive*sin(\anglefive)}) {$\dots$};

  \end{tikzpicture}
  }
  \caption{Illustration of the $\defbound$-bounded impact property $\bounded$ for different values of $\defbound$.}
  \labfig{le-bounded}
  \end{marginfigure}

  \begin{marginfigure}[*10]
    \centering
    \resizebox{\textwidth}{!}{
      \begin{tikzpicture}
        % Parameters for the first ellipse
        \def\centerxone{0}
        \def\centeryone{0}
        \def\xradiusone{0.5}
        \def\yradiusone{0.5}
        \def\angleone{110}

        % Parameters for the second ellipse
        \def\centerxtwo{0.15}
        \def\centerytwo{0.25}
        \def\xradiustwo{1.25}
        \def\yradiustwo{1.25}
        \def\angletwo{112}

        % Parameters for the third ellipse
        \def\centerxthree{0.3}
        \def\centerythree{0.5}
        \def\xradiusthree{2}
        \def\yradiusthree{1.75}
        \def\anglethree{120}

        % Parameters for the fourth ellipse
        \def\centerxfour{0.4}
        \def\centeryfour{0.75}
        \def\xradiusfour{2.5}
        \def\yradiusfour{2.6}
        \def\anglefour{135}


        % Draw the first ellipse
        \node[fill=white] at ({\centerxone + \xradiusone*cos(\angleone)}, {\centeryone + \yradiusone*sin(\angleone)}) {$\dots$};

        % Draw the second ellipse
        \draw (\centerxtwo,\centerytwo) ellipse (\xradiustwo cm and \yradiustwo cm);
        \node[fill=white] at ({\centerxtwo + \xradiustwo*cos(\angletwo)}, {\centerytwo + \yradiustwo*sin(\angletwo)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\ge}{5pt}2}]$};

        % Draw the third ellipse
        \draw (\centerxthree,\centerythree) ellipse (\xradiusthree cm and \yradiusthree cm);
        \node[fill=white] at ({\centerxthree + \xradiusthree*cos(\anglethree)}, {\centerythree + \yradiusthree*sin(\anglethree)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\ge}{5pt}1}]$};

        % Draw the fourth ellipse
        \draw (\centerxfour,\centeryfour) ellipse (\xradiusfour cm and \yradiusfour cm);
        \node[fill=white] at ({\centerxfour + \xradiusfour*cos(\anglefour)}, {\centeryfour + \yradiusfour*sin(\anglefour)}) {$\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\ge}{5pt}0}]$};


    \end{tikzpicture}
    }
    \caption{Illustration of the $\defbound$-bounded impact property $\revbounded$ for different values of $\defbound$.}
    \labfig{ge-bounded}
    \end{marginfigure}

As a consequence of the $\defbound$-bounded impact property, \cf{} \refdef{bounded}, we notice that by enlarging the threshold $\defbound$, the set of program semantics that satisfy the property also increases.

\begin{lemma}[Monotonicity of the $\defbound$-Bounded Impact Property]
  \lablemma{bounded-monotonic}
  For all $\defbound, \defbound'\in\valuesposplus$ such that $\defbound \comparison \defbound'$, it holds that:
  \begin{align*}
    \GENBOUNDED \subseteq \mathscr{B}_{\impactwrapper}^{{\scaleto{\comparison}{5pt}\defbound'}}
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is based on the fact that, for all $\defbound, \defbound'\in\valuesposplus$ such that $\defbound \comparison \defbound'$, it holds that $\impactwrapper(\defsetoftraces) \comparison \defbound \implies \impactwrapper(\defsetoftraces) \comparison \defbound'$ for any set of traces $\defsetoftraces\in\tracetype$.
  Consequently, we have that $\genbounded \subseteq \resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\comparison}{5pt}\defbound'}]$.
\end{proof}





Note that, in both cases whether $\comparison$ is $\le$ or $\ge$, the $\defbound$-bounded impact property $\genbounded$ is always a subset of $\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\comparison}{5pt}\defbound'}]$.
\reffig{le-bounded} compares the property $\bounded$ for different values of $\defbound$, the smallest being $\defbound = 0$ containing the program semantics whose input variables have no impact.
By increasing $\defbound$, the set of program semantics that satisfy the property also increases.
Regarding the other operator $\ge$, \reffig{ge-bounded} shows that $\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\ge}{5pt}0}]$ is the property containing all the program semantics, \ie, $\resize{\mathscr{B}}{\impactwrapper}[{\scaleto{\ge}{5pt}0}] = \tracetype$. By decreasing $\defbound$, the set of program semantics that satisfy the property also increases.
Therefore, the $\defbound$-bounded impact property $\bounded$ can be used to verify that the input variables $\definputvariables$ have an impact of \emph{at least} $\defbound$ on the program outcome. Whereas, the property $\revbounded$ can be used to verify that the impact is of \emph{at most} $\defbound$.


Next, we instantiate $\impactwrappername$ with the impact quantifiers of \outcomesname{}, \rangename{}, and \qusedname{}. Each of these quantifiers differently characterizes the impact of the input variables: \outcomesname{} counts the number of different outcomes, \rangename{} measures the range of outcome values, and \qusedname{} counts the number of input values that are \emph{not} used to produce the outcomes.
To this end, these quantifiers employ the concept of output observer, \cf{} \refdef*{output-observer}[*-9].
% We expect the output observer $\outputobs$ (\refdef*{output-observer}[*-2]) to return a quantifiable element, \ie{}, a value in $\valuesinf$.
% An output observer $\outputobs$ that returns a quantifiable element is called an \emph{output observer}.

% \begin{definition}[Output Descriptor]
%   \labdef{output-descriptor}
%   An \textup{output observer} is an output observer $\outputobs\in\stateandbottom\to\valuesinf$ that returns a quantifiable element.
% \end{definition}

% The above output observer $\outputobs$ is generic enough to cover plenty of use cases and still abstract enough to maintain the generality of the output abstraction introduced in the previous chapter.
% We leverage this output observer to provide the end user of the framework the flexibility to choose the meaning of program outputs, without establishing it beforehand.


\begin{marginlisting}
  \caption{Landing alarm system}
  \labprog{landing-alarm-system}
  \vspace{\lineheight}
\begin{lstlisting}[
  language=customPython,
  style=mystyle,]
landing_coeff =
  abs(angle) + speed
if landing_coeff < 2:
  risk = 0
else if landing_coeff > 5:
  risk = 3
else:
  risk =
    floor(landing_coeff) - 2
  \end{lstlisting}
\end{marginlisting}

\begin{example}\labexample{output-observer-landing}
  Consider the \refprog{landing-alarm-system}, called for simplicity program \landingprogram{} in the following. The goal of program \landingprogram{} is to inform the pilot about the level of risk associated with the landing approach.
  It takes two input variables, denoted as \texttt{angle} and \texttt{speed}, for the aircraft-airstrip alignment angle and the aircraft speed, respectively.
A value of 1 represents a good alignment while -4 a non-aligned angle, whereas 1, 2, 3 denote low, medium, and high speed.\sidenote{We initially focus on discrete values to simplify the example and convey the concept. We expand to continuous inputs in \refch{showcase}.}
A safer approach is indicated by lower speed.
The landing risk coefficient combines the absolute landing angle and speed.
The output variable \texttt{risk} is the danger level with possible values $\{0, 1, 2, 3\}$, where 0 represents low danger and 3 high danger.
%
\reffig{input-space-composition} shows the input space composition of this system, where the label near each input represents the degree of risk assigned to the corresponding input configuration.
It is easy to note that a nonaligned angle of approach corresponds to a considerably higher level of risk, whereas the risk with a correct angle depends mostly on the aircraft speed.

\begin{marginfigure}
  \centering
    \begin{tikzpicture}
      % Grid
      \draw[help lines, color=gray!30, dashed] (0,0) grid (2.9,3.9);
      % x-axis
      \draw[->,ultra thick] (0,0)--(3,0) node[right]{\texttt{angle}};
      % \draw[->,ultra thick] (0,0)--(3,0) node[rotate=90,below]{\x};
      % y-axis
      \draw[->,ultra thick] (0,0)--(0,4) node[above]{\texttt{speed}};
      % x-axis ticks
      % \foreach \x in {0,1}
      \draw (0+1,0.1) -- (0+1,-0.1) node[below] {-4};
      \draw (1+1,0.1) -- (1+1,-0.1) node[below] {1};
      % y-axis ticks
      \foreach \y in {1,2,3}
      \draw (0.1,\y) -- (-0.1,\y) node[left] {\y};
      % Nodes
      \fill[color=seabornRed]   (0+1,0+1) circle[radius=2pt];
      \node[above right] at (0+1,0+1) {$3$};
      \fill[color=seabornRed]   (0+1,1+1) circle[radius=2pt];
      \node[above right] at (0+1,1+1) {$3$};
      \fill[color=seabornRed]   (0+1,2+1) circle[radius=2pt];
      \node[above right] at (0+1,2+1) {$3$};
      \fill[color=seabornGreen] (1+1,0+1) circle[radius=2pt];
      \node[above right] at (1+1,0+1) {$0$};
      \fill[color=seabornYellow] (1+1,1+1) circle[radius=2pt];
      \node[above right] at (1+1,1+1) {$1$};
      \fill[color=seabornOrange]    (1+1,2+1) circle[radius=2pt];
      \node[above right] at (1+1,2+1) {$2$};
    \end{tikzpicture}
    \caption{Input space composition of program \landingprogram.}
    \labfig{input-space-composition}
  \end{marginfigure}


  Program states are $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\{0,1,2,3\}}$, where $a$ is the value of $\text{angle}$, $b$ of $\texttt{speed}$, $c$ of $\texttt{landing\_coeff}$, and $d$ of $\texttt{risk}$.
  Here, we abuse the notation and write states in $\state$ as tuples of variable values, without considering program locations.
  The output observer is instantiated with
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  As a result, the output observer $\outputobs$ focuses on the value of the variable $\texttt{risk}$ when the last state of the trace is $\langle a, b, c, d \rangle$. Otherwise, in case of an infinite-length trace, the output observer maps to the state with all variables at $\top$.
  In other words, the output observer abstracts away the value of all variables but $\texttt{risk}$, the output variable.
  Note that, even though \refprog{landing-alarm-system} always terminates, we need to take into account that the input parameter of the output observer $\outputobs$ is either the final state or $\statebottom$.
  \reffig{output-observer-landing} depicts the traces generated by \refprog{landing-alarm-system} where the output values are abstracted by $\outputobs$.
\end{example}
\begin{marginfigure}
  \centering
  \begin{tikzpicture}
    \node (linit) at (0,3) {$\locinit$};
    \node (lend) at (2,3) {$\loc{10}$};
    \draw[->] (linit) -- (lend);

    % Define the positions of the nodes
    \node (-41) at (0,2.5) {${\tuple{-4}{1}}$};
    \node (-42) at (0,2) {${\tuple{-4}{2}}$};
    \node (-43) at (0,1.5) {${\tuple{-4}{3}}$};
    \node (11) at (0,1) {${\tuple{1}{1}}$};
    \node (12) at (0,0.5) {${\tuple{1}{2}}$};
    \node (13) at (0,0) {${\tuple{1}{3}}$};

    \node (3) at (2,2) {${\langle 3 \rangle}$};
    \node (2) at (2,1.5) {${\langle 2 \rangle}$};
    \node (1) at (2,1) {${\langle 1 \rangle}$};
    \node (0) at (2,0.5) {${\langle 0 \rangle}$};

    % Draw the edges
    \draw[->] (-41) -- (3);
    \draw[->] (-42) -- (3);
    \draw[->] (-43) -- (3);

    \draw[->] (11) -- (0);
    \draw[->] (12) -- (1);
    \draw[->] (13) -- (2);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.7) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\outputsemanticsnoparam\semanticsof{\texttt{landing\_alarm\_system}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of the \refprog{landing-alarm-system}.}
\labfig{output-observer-landing}
\end{marginfigure}

\begin{example}
  Originally introduced by \sidetextcite{Giacobazzi2018}, the output observer $\outputobs$ should deal with any possible abstraction an end-user of the framework might want to use.
  For example, one could be interested in the parity of the output value.
  In this case, the output observer $\outputobs$ could be defined as:
  \[
  \outputobs(\defstate) \DefeQ \begin{cases}
    \langle \top, \top, \top, d \!\!\mod 2 \rangle & \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle & \text{otherwise}
  \end{cases}
  \]
  \begin{marginfigure}
    \centering
    \begin{tikzpicture}
      \node (linit) at (0,3) {$\locinit$};
      \node (lend) at (2,3) {$\loc{10}$};
      \draw[->] (linit) -- (lend);

      % Define the positions of the nodes
      \node (-41) at (0,2.5) {${\tuple{-4}{1}}$};
      \node (-42) at (0,2) {${\tuple{-4}{2}}$};
      \node (-43) at (0,1.5) {${\tuple{-4}{3}}$};
      \node (11) at (0,1) {${\tuple{1}{1}}$};
      \node (12) at (0,0.5) {${\tuple{1}{2}}$};
      \node (13) at (0,0) {${\tuple{1}{3}}$};

      \node (odd) at (2,1.5) {${\langle 1 \rangle}$};
      \node (even) at (2,1) {${\langle 0 \rangle}$};

      % Draw the edges
      \draw[->] (-41) -- (odd);
      \draw[->] (-42) -- (odd);
      \draw[->] (-43) -- (odd);

      \draw[->] (11) -- (even);
      \draw[->] (12) -- (odd);
      \draw[->] (13) -- (even);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.7) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\outputsemanticsnoparam\semanticsof{\texttt{landing\_alarm\_system}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of the \refprog{landing-alarm-system} with the parity abstraction.}
  \labfig{parity-landing}
  \end{marginfigure}
  The parity of the value of $\texttt{risk}$ is mapped to the value $0$ if even and $1$ if odd.
  As a result, in our framework we would quantify the impact of the input variables on the parity of the output values.
  \reffig{parity-landing} shows the traces generated by \refprog{landing-alarm-system} where the output values are abstracted by their parity.
\end{example}



Next, we define the impact quantifiers of \outcomesname{}, \rangename{}, and \qusedname{}.

\subsection{The \outcomesname{} Impact Quantifier}[\outcomesname]
\labsec{outcomes}

Formally $\outcomes\in\tracetype\to\Nplus$ counts the number of different output values reachable by varying the input variables $\definputvariables\in\setof\inputvariables$.
% First, we define step-by-step the quantity $\outcomes$,
% followed by the formal definition.
% We instantiate of this quantity in the context of \refprog*{landing-alarm-system}[*-5] at the end, alongside with some properties of $\outcomesname$.


$\outcomes$ collects,
for any possible input configuration $\definput\in\reducedstate$, all the traces that are starting from an input configuration that is a variation of $\definput$ on the input variable $\definputvariables$, \ie, $\setdef{
  \defseq\in \defsetoftraces
}{
  \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
}$, where $\defsetoftraces\in\setof\finiteinfinitesequences$.
Then, it gathers the output values of this set of traces by means of the output observer $\outputobs$, \ie, $\setdef{
  \outputobs(\retrieveoutput\defseq)
}{
  \defseq \in \defsetoftraces \land
    \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
}$. Specifically, this set contains all the output abstractions performed by $\outputobs$.
%
Afterwards, it yields the number of these output values via the cardinality operator $\cardinality{\cdot}$.
Finally, through the supremum operator: $\sup$, it returns the maximum value to ensure that the greatest impact is preserved.
\marginnote{
  The supremum operator $\sup$ yields the least upper bound of the given set of elements $X$:
  %  that is, the smallest $q$ such that $q$ is greater than or equal to all elements of the set.
  \begin{align*}
    \sup X \DefeQ x \text{ such that } \foralldef{y\in X}{x \ge y}
  \end{align*}
}

Formally, the $\outcomesname$ impact quantifier is defined as follows:

\begin{definition}[\outcomesname]\labdef{outcomes}
  Given an input variable $\definputvariables\in\setof\inputvariables$ and output observer $\outputobs\in\stateandbottom\to\stateandbottom$,
  the impact quantifier $\outcomes\in\tracetype\to\Nplus$ is defined as:
  \begin{align*}
    \outcomes(\defsetoftraces) &\DefeQ \sup_{\definput\in\state}
      \cardinality{\setdef{
        \outputobs(\retrieveoutput{\defseq})
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }}
  \end{align*}
\end{definition}


\begin{margintable}[*-5]
  \caption{Overview of the $\outcomesname$ impact quantifier for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\rightarrow\langle{0}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\tracearrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\tracearrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\tracearrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\tracearrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\tracearrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\tracearrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\tracearrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\tracearrow\langle{3}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*9]
  \caption{Overview of the $\outcomesname$ impact quantifier for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-outcomes-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \outcomesname \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 1 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 3 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 3 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{example}
  \labexample{outcomes}
  \newcommand*{\inputa}{\tuple{-4}{1}} \newcommand*{\outputa}{\langle \outputvaluea\rangle} \newcommand*{\outputvaluea}{3}
  \newcommand*{\inputb}{\tuple{-4}{2}} \newcommand*{\outputb}{\langle \outputvalueb\rangle} \newcommand*{\outputvalueb}{3}
  \newcommand*{\inputc}{\tuple{-4}{3}} \newcommand*{\outputc}{\langle \outputvaluec\rangle} \newcommand*{\outputvaluec}{3}
  \newcommand*{\inputd}{\tuple{ 1}{1}} \newcommand*{\outputd}{\langle \outputvalued\rangle} \newcommand*{\outputvalued}{0}
  \newcommand*{\inpute}{\tuple{ 1}{2}} \newcommand*{\outpute}{\langle \outputvaluee\rangle} \newcommand*{\outputvaluee}{1}
  \newcommand*{\inputf}{\tuple{ 1}{3}} \newcommand*{\outputf}{\langle \outputvaluef\rangle} \newcommand*{\outputvaluef}{2}
  \newcommand*{\tracea}{\inputa\to\outputa}
  \newcommand*{\traceb}{\inputb\to\outputb}
  \newcommand*{\tracec}{\inputc\to\outputc}
  \newcommand*{\traced}{\inputd\to\outputd}
  \newcommand*{\tracee}{\inpute\to\outpute}
  \newcommand*{\tracef}{\inputf\to\outputf}
  Let us revisit the example of the landing alarm system, \cf{} \refprog*{landing-alarm-system}[*-23], with program states $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$.
  For brevity, we refer to such program as program $\landingprogram$.
  The input variables are $\inputvariables = \{\texttt{angle},\texttt{speed}\}$, consequently the input space is the set of program states reduced to the input variables, \ie{}
  $\reducedstate=\{\inputa, \inputb, \inputc, \inputd, \inpute, \inputf\}$.
%
  We begin by considering $\definputvariables=\{\texttt{angle}\}$ and $\inputa$ as the first input configuration to be explored.
  Hence, we collect all traces that are
  starting from an input configuration that is a variation of $\inputa$, \ie, $\setdef{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram}
  }{
    \retrieveinput{\defseq} \stateeq{\inputvariables\setminus\{\texttt{angle}\}} \inputa
  }$, where $\inputvariables\setminus\{\texttt{angle}\} = \{\texttt{speed}\}$ and consequently $\retrieveinput{\defseq} \stateeq{\{\texttt{speed}\}} \inputa$ holds whenever the initial state of $\defseq$ has $\texttt{speed}=1$. A possible trace (with the intermediate states and the value of all the 4 variables) of this set is $\langle 1, 1, 0, 0\rangle \to \langle 1, 1, 2, 0\rangle\to\langle 1, 1, 2, 0\rangle$ where, at the beginning, we randomly assign $\texttt{landing\_risk}=0$ and $\texttt{risk}=0$, respectively the third and fourth component of the initial state.
%
  We collect the output values of this set of traces, $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \tracesemanticsnoparam\semanticsof{\landingprogram} \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }$.
  As a result, we obtain the set of output values $\{0, 3\}$.
  For instance, the output value $0$ is the result of the trace we exhibited previously, where the last state is $\langle 1, 1, 2, 0\rangle$ and thus the $\texttt{risk}$ variable of this trace is the last component with value $0$.
%
  Finally, the cardinality operator returns the value $2$, $\cardinalitynospaces{\{0, 3\}} = 2$.
  By doing so for all possible input configurations in $\reducedstate$, we obtain $\outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=2$.
  \reftab{overview-outcomes-angle} illustrate the steps for $\outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-outcomes-speed} for $\outcomesname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

The $\outcomesname$ quantifier above is monotone in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\outcomesname{} is Monotonic]
  \lablemma{outcomes-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is based on the observation that, fixed an input state $\retrieveinput\defstate \in \state$, the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ is a subset of $\setdef{
    \outputobs(\retrieveoutput{\defseq})
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the cardinality of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\outcomes(\defsetoftraces) \le \outcomes(\defsetoftraces')$.
\end{proof}

Let $\boundedoutcomes$ be the $\defbound$-bounded impact property when instantiated with the $\outcomesname$ impact quantifier.
The output semantics $\outputsemanticsnoparam$ is sound and complete for validating $\boundedoutcomes$.

\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{abstraction-dependency-semantics}
\siderefbox{def}{abstraction-output-abstraction-semantics}
\begin{lemma}[$\boundedoutcomes$ Validation]\lablemma{outcomes-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDOUTCOMES \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDOUTCOMES))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\boundedoutcomes$:
  \begin{eqnarray*}
    \lefteqn{\outputabstraction(\dependencyabstraction(\boundedoutcomes)) =} \\
    & \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{
      \sup_{\definput\in\state}
      \cardinality{\setdef{
        \defoutput
      }{
        \tuple{\retrieveinput{\defstate}}{\defoutput} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }} \comparison \defbound
    }
  \end{eqnarray*}
  Note that, all the intermediate states from the trace semantics are abstracted to input-output dependencies.
  The $\outcomesname$ impact quantifier does not consider the intermediate states, thus the abstraction to dependencies does not affect the validation of the property.
  Furthermore, even handling the output abstraction at the semantic level, by abstracting output states to abstract output states, does not affect the validation of the property as the $\outcomesname$ impact quantifier already abstracts the output values before counting them.
\end{proof}

For the \outcomesname{} quantifier, an impact quantity of zero implies that the input variables of interest have no impact on the program outcomes, \ie, the set of input variables is unused, provided that the given program semantics \emph{is deterministic}.
On the other hand, non-deterministic statements in the program may mislead $\outcomesname$ to account for differences in the program output as a result of variations in the input variables.

\begin{example}\labexample{outcomes-nondeterminism}
  % \marginnote[*3]{
  %   \begin{tikzpicture}[scale=0.8]
  %     \node (linit) at (-0.9,2) {$\locinit:$};
  %     \node (lend) at (-0.9,0) {$\loc{10}:$};
  %     % Define the positions of the nodes
  %     \node (TT) at (0,2) {${\tuple\true\true}$};
  %     \node (TF) at (1,2) {${\tuple\true\false}$};
  %     \node (FT) at (2,2) {${\tuple\false\true}$};
  %     \node (FF) at (3,2) {${\tuple\false\false}$};
  %     \node (outTT) at (0,0) {${\tuple\true\true}$};
  %     \node (outTF) at (1,0) {${\tuple\true\false}$};
  %     \node (outFT) at (2,0) {${\tuple\false\true}$};
  %     \node (outFF) at (3,0) {${\tuple\false\false}$};
  %     % Draw the edges
  %     \draw[->] (TT) -> (outTT);
  %     \draw[->] (TF) -> (outTT);
  %     \draw[->] (TT) -> (outTF);
  %     \draw[->] (TF) -> (outTF);
  %     \draw[->] (FT) -> (outFT);
  %     \draw[->] (FF) -> (outFT);
  %     \draw[->] (FT) -> (outFF);
  %     \draw[->] (FF) -> (outFF);
  %     \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{sci}}$};
  % \end{tikzpicture}
  % }
Consider the \refprog*{syntactic-vs-semantic-usage} used in \refsec{input-data-usage} to illustrate the differences between syntactic and semantic input data usage. Notably: it contains a non-deterministic statement.
Assuming input values are $\N$, the $\outcomesname_{\texttt{x}}$ impact quantifier (for the variable $\texttt{x}$) is $+\infty$ as for any possible input value, the program can output any value in $\N$.
Due to the non-deterministic statement, the variable \texttt{x} has an infinite impact on the output values, even though the program does not use the input variable \texttt{x}, \cf{} \refexample{syntactic-vs-semantic-usage}.
\end{example}

Notably, the property $\boundedoutcomesle$ (with the operator $\le$) is subset-closed, \ie, if a program semantics satisfies the property, then all its subsets also satisfy the property.

\begin{lemma}[$\boundedoutcomesle$ is subset-closed]\lablemma{outcomes-subset-closed-le}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{gather*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces' \in \BOUNDEDOUTCOMESLE \ImplieS \defsetoftraces \in \BOUNDEDOUTCOMESLE
  \end{gather*}
\end{lemma}
\begin{proof}
  This proof follows directly from the monotonicity of the $\outcomes$ impact quantifier, \cf{} \reflemma{outcomes-monotonic}.
\end{proof}

Conversely, the property $\boundedoutcomesge$ (with the operator $\ge$) is superset-closed, \ie, if a program semantics satisfies $\boundedoutcomesge$, then all its supersets also satisfy $\boundedoutcomesge$.

\begin{lemma}[$\boundedoutcomesge$ is superset-closed]\lablemma{outcomes-superset-closed-ge}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{gather*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces \in \BOUNDEDOUTCOMESGE \ImplieS \defsetoftraces' \in \BOUNDEDOUTCOMESGE
  \end{gather*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{outcomes-subset-closed-le}, this proof follows directly from the monotonicity of the $\outcomes$ impact quantifier, \cf{} \reflemma{outcomes-monotonic}.
\end{proof}

\subsection{The \rangename{} Impact Quantifier}[\rangename]
\labsec{range}

The quantity $\range\in\tracetype\to\Rposplus$ determines the
size of the range of the output values for all the possible variations in the input variable $\definputvariables\in\setof\inputvariables$.
Let $\defoutputvariables$ be the set of output variables on which the impact is measured.
We are interested in the difference between the extreme values of the variables $\defoutputvariables$.
The difference of extreme values is computed by a distance measure $\distance$ computing the maximum distance between the set of given values. For instance, $\distance$ could be the Euclidean distance.

\begin{margintable}[*-10]
  \caption{Overview of the $\rangename$ impact quantifier for the variable $\texttt{angle}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-angle}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{\blue{-4}}{1}$ & \makecell{$\tuple{\blue{-4}}{1}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{1}\tracearrow\langle{0}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{-4}}{2}$ & \makecell{$\tuple{\blue{-4}}{2}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{2}\tracearrow\langle{1}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{-4}}{3}$ & \makecell{$\tuple{\blue{-4}}{3}\tracearrow\langle{3}\rangle$, \\ $\tuple{\blue{1}}{3}\tracearrow\langle{2}\rangle$} & 1 \\
    \hline
    $\tuple{\blue{1}}{1}$ & \makecell{$\tuple{\blue{1}}{1}\tracearrow\langle{0}\rangle$, \\ $\tuple{\blue{-4}}{1}\tracearrow\langle{3}\rangle$} & 3 \\
    \hline
    $\tuple{\blue{1}}{2}$ & \makecell{$\tuple{\blue{1}}{2}\tracearrow\langle{1}\rangle$, \\ $\tuple{\blue{-4}}{2}\tracearrow\langle{3}\rangle$} & 2 \\
    \hline
    $\tuple{\blue{1}}{3}$ & \makecell{$\tuple{\blue{1}}{3}\tracearrow\langle{2}\rangle$, \\ $\tuple{\blue{-4}}{3}\tracearrow\langle{3}\rangle$} & 1 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}
\begin{margintable}[*5]
  \caption{Overview of the $\rangename$ impact quantifier for the variable $\texttt{speed}$ of \nrefprog{landing-alarm-system}.}
  \labtab{overview-range-speed}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{c|c|c}
    \textsc{Input} & \textsc{Traces} & \rangename \\
    \hline
    \hline
    $\tuple{-4}{\blue{1}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{2}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{-4}{\blue{3}}$ & \makecell{$\tuple{-4}{\blue{1}}\tracearrow\langle{3}\rangle$, \\ $\tuple{-4}{\blue{2}}\tracearrow\langle{3}\rangle$ \\ $\tuple{-4}{\blue{3}}\tracearrow\langle{3}\rangle$} & 0 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 2 \\
    \hline
    $\tuple{1}{\blue{1}}$ & \makecell{$\tuple{1}{\blue{1}}\tracearrow\langle{0}\rangle$, \\ $\tuple{1}{\blue{2}}\tracearrow\langle{1}\rangle$ \\ $\tuple{1}{\blue{3}}\tracearrow\langle{2}\rangle$} & 2 \\
    \hline
    \hline
  \end{tabular}}
\end{margintable}

\begin{example}
  \labexample{range}
  We revisit again the example of the landing alarm system, program $\landingprogram$.
  Assuming $\definputvariables=\{\texttt{angle}\}$, $\tuple{-4}{1}$ is the first input configuration to be explored, we collect all traces that are
  starting from an input configuration that is a variation of $\tuple{-4}{1}$.
  As before, we obtain $\setdef{
    \retrieveoutput\defseq(\texttt{risk})
  }{
    \defseq \in \defsetoftraces \land
      \retrieveinput{\defseq}(\texttt{speed}) = 1
  }=\{0,3\}$ as the set of output values for the output variable \texttt{risk}.
%
  Here, we are interested in the difference between the extreme values of the outcomes. Hence, we apply the size function: $\distance(\{0,3\})=3$.
  By doing so for all possible input configurations $\reducedstate$, we obtain $\rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})=3$.
  Respectively, \reftab{overview-range-angle} illustrates the steps for $\rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$ and \reftab{overview-range-speed} for $\rangename_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram})$.
\end{example}

  Formally, the $\rangename$ impact quantifier is defined as follows:

\begin{definition}[\rangename]\labdef{range}
  Given the set of input variables of interest $\definputvariables\in\setof\inputvariables$ and the output variables $\defoutputvariables$,
  the impact quantifier $\range\in\tracetype\to\Rposplus$ is defined as
  %
  \begin{align*}
    \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
      \distance(\setdef{
        \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
      }{
        \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      })
  \end{align*}
\end{definition}

The above quantifier employs the auxiliary function $\distance$. For instance, such distance could be instantiated as the Euclidean distance: $\distance(X) \defeq \max_{x, x' \in X} \sqrt{\sum_k (x - x')^2}$ if $X$ is non-empty, otherwise $\distance(X) \defeq 0$. From here, we consider the Euclidean distance as the default distance measure.

We note that also $\rangename$ is monotonic in the amount of traces in $\defsetoftraces$.

\begin{lemma}[\rangename{} is Monotonic]
  \lablemma{range-monotonic}
For all set of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{align*}
    \defsetoftraces \subseteq \defsetoftraces' \ImplieS \range(\defsetoftraces) \le \range(\defsetoftraces')
  \end{align*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{outcomes-monotonic}, the proof is based on the observation that the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
  }{
    \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ is a subset of the set of output values $\setdef{
    \outputobs(\retrieveoutput{\defseq})(\defoutputvariables)
  }{
    \defseq \in \defsetoftraces' \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
  }$ since by hypothesis we have that $\defsetoftraces \subseteq \defsetoftraces'$.
  Hence, the size of the first set is less than or equal to the cardinality of the second set.
  We conclude that $\range(\defsetoftraces) \le \range(\defsetoftraces')$.
\end{proof}


Let $\boundedrange$ be the $\defbound$-bounded impact property when instantiated with the $\rangename$ impact quantifier.
The output semantics $\outputsemanticsnoparam$ is sound and complete for validating $\boundedrange$.
\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{abstraction-dependency-semantics}
\siderefbox{def}{abstraction-output-abstraction-semantics}
\begin{lemma}[$\boundedrange$ Validation]\lablemma{range-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDRANGE \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDRANGE))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the (double) abstraction of the $\defbound$-bounded impact property $\boundedrange$:
  \begin{align*}
    & \outputabstraction(\dependencyabstraction(\boundedrange)) = \\
    &\quad
    \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{ \\ & \qquad
      \sup_{\definput\in\state}
      \distance({\setdef{
        \retrieveoutput{\defstate}(\defoutputvariables)
      }{
        \inputoutputtuple{\defstate} \in \defsetofdependencies \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
      }}) \comparison \defbound
    }
  \end{align*}
  As noticed before, the $\rangename$ impact quantifier does not consider the intermediate states and abstracts the output states before applying the size function.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

\reflemma{range-monotonic} and \reflemma{range-validation} show that the $\rangename$ impact quantifier can be used to certify that a program has impact of \emph{at most} $\defbound$. In the present of deterministic systems, an impact quantity of zero implies that the input variable is unused.
Otherwise, similarly to $\rangename$, the input variable may have an impact on the program computation even if not used.\sidenote{See \refexample{outcomes-nondeterminism} for a similar discussion of the \outcomesname{} impact quantifier when applied to programs containing nondeterministic statements.}

Notably, the property $\boundedrangele$ (with the operator $\le$) is subset-closed, \ie, if a program semantics satisfies the property, then all its subsets also satisfy the property.

\begin{lemma}[$\boundedrangele$ is subset-closed]\lablemma{range-subset-closed-le}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{gather*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces' \in \BOUNDEDRANGELE \ImplieS \defsetoftraces \in \BOUNDEDRANGELE
  \end{gather*}
\end{lemma}
\begin{proof}
  This proof follows directly from the monotonicity of the $\range$ impact quantifier, \cf{} \reflemma{range-monotonic}.
\end{proof}

Conversely, the property $\boundedrangege$ (with the operator $\ge$) is superset-closed, \ie, if a program semantics satisfies $\boundedrangege$, then all its supersets also satisfy $\boundedrangege$.

\begin{lemma}[$\boundedrangege$ is superset-closed]\lablemma{range-superset-closed-ge}
  For any two sets of traces $\defsetoftraces, \defsetoftraces'\in\tracetype$, it holds that:
  \begin{gather*}
    \defsetoftraces \subseteq \defsetoftraces' \land \defsetoftraces \in \BOUNDEDRANGEGE \ImplieS \defsetoftraces' \in \BOUNDEDRANGEGE
  \end{gather*}
\end{lemma}
\begin{proof}
  Similarly to \reflemma{range-subset-closed-le}, this proof follows directly from the monotonicity of the $\range$ impact quantifier, \cf{} \reflemma{range-monotonic}.
\end{proof}

\subsection{The \qusedname{} Impact Quantifier}[\qusedname]
\labsec{qused}

The quantifier $\qused\in\tracetype\to\Nplus$ counts the number of input states for the variables in $\definputvariables\in\setof\inputvariables$ that are \emph{not} used to produce the program outcomes.
Unlike \outcomesname{} and \rangename{}, even in the presence of non-deterministic statements, the impact of an input variable is zero \wrt{} \qusedname{} if and only if the input variable is not used to produce any outcome.

Given a set of traces $\defsetoftraces$, for each possible outcome of a trace $\deftrace\in\defsetoftraces$, \qusedname{} collects the traces $\deftrace'\in\defsetoftraces$ that share the same output abstraction, \ie, $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput\defstate)$. Then, it gathers the set of input states of the variables in $\definputvariables$ that correspond to these traces, called $I_\deftrace(\defsetoftraces)$.
The number of missing input states is obtained by subtracting
the set $I_\deftrace(\defsetoftraces)$,
from
the set of input states that can produce the outcome $\retrieveoutput\defstate$ by variations of the variables in $\definputvariables$, called $Q_\definputvariables(I_\deftrace(\defsetoftraces))$.
Finally, $\qused$ yields the maximum number of input values that are not used to produce the outcomes.


Formally, the $\qusedname$ impact quantifier is defined as follows:

\begin{definition}[\qusedname]\labdef{qused}
  Given an input variable $\definputvariables\in\setof\inputvariables$,
  the impact quantifier $\qused\in\tracetype\to\Nplus$ is defined as
  %
  % \begin{eqnarray*}
  %   \qused(\defsetoftraces) \DefeQ
  %   \sup_{\deftrace \in \defsetoftraces}
  %     \spacer\left|
  %       \begin{array}{l}
  %         \setdef{\retrieveinput\defstate(\definputvariables)}{\retrieveinput\defstate \in \state} \setminus \\
  %         \quad \setdef{
  %           \retrieveinput{\defseq'}(\definputvariables)
  %           }{
  %             \deftrace' \in \defsetoftraces \LanD
  %                 \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput{\deftrace'})
  %           }
  %       \end{array}
  %     \right|
  % \end{eqnarray*}
  \begin{align*}
    \qused(\defsetoftraces) &\DefeQ \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      } \\
      I_{\deftrace}(\defsetoftraces) &\spacearound= \setdef{
        \retrieveinput{\defseq'}
      }{
        \defseq' \in \defsetoftraces \land
        \outputobs(\retrieveoutput{\deftrace}) = \outputobs(\retrieveoutput{\defseq'})
      } \\
      Q_\definputvariables(\defsetofstates) &\spacearound= \setdef{
        \defstate' \in \state
      }{
        \defstate \in \defsetofstates \land
          \defstate' \stateeq{\inputvariableswithoutw} \defstate
      }
  \end{align*}
  where $I_{\deftrace}(\defsetoftraces)$ is the set of input states of traces in $\defsetoftraces$ that share the same output abstraction as $\deftrace$ and $Q_\definputvariables(\defsetofstates)$ is the set of states that are variations from states in $\defsetofstates$ only in the variables $\definputvariables$.
\end{definition}


\begin{example}
  To demonstrate the $\qusedname$ impact quantifier, we employ four simple programs.
  The first program we consider, \refprog{id}, returns the value of the only input variable $\texttt{x}$ without any modification.
  The second program, \refprog{random}, returns a random value.
  The last two, \refprog{mix1} and \refprog{mix2}, combine together non-deterministic and deterministic statements.
  For simplicity, variables are assumed to range in $\{0, 1, 2\}$.

  \begin{marginlisting}[*-2]
    \caption{The identity program.}
    \labprog{id}
    \vspace{15pt}
  \begin{lstlisting}[style=mystyle,language=customPython, escapechar=\%]
%\textcolor{black}{id}%(x):
  return x;
 \end{lstlisting}
  \end{marginlisting}
  The trace semantics of \refprog{id} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{id}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\tracearrow\tracetuple{\loc{3}}{\langle 0\rangle},\\
        \tracetuple{\locinit}{\langle 1\rangle}\tracearrow\tracetuple{\loc{3}}{\langle 1\rangle},\\
        \tracetuple{\locinit}{\langle 2\rangle}\tracearrow\tracetuple{\loc{3}}{\langle 2\rangle}
      \end{array}
    \right\}
  \end{align*}
  \begin{marginfigure}[*-4]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{3}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{id}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{id}.}
  \labfig{id-traces}
  \end{marginfigure}
  As explained above, for any $\deftrace\in \tracesemanticsnoparam\semanticsof{\texttt{id}}$ we collect the set of input states that belong to traces $\deftrace'\in\tracesemanticsnoparam\semanticsof{\texttt{id}}$ that share the same output abstraction as $\deftrace$, \cf{} $I_{\deftrace}(\tracesemanticsnoparam\semanticsof{\texttt{id}})$.
  In this case, the set of input states that can produce the outcome $0$ is $\{\tracetuple{\locinit}{\langle 0\rangle}\}$, for the outcome $1$ is $\{\tracetuple{\locinit}{\langle 1\rangle}\}$, and for the outcome $2$ is $\{\tracetuple{\locinit}{\langle 2\rangle}\}$, all singletons.
  Hence, the set of states that are variations, \cf{} $Q_{\{\texttt{x}\}}(I_{\deftrace}(\tracesemanticsnoparam\semanticsof{\texttt{id}}))$, is the complement of each singleton.
  Hence, for the three set of input states, we obtain the values $2$, $2$, and $2$, respectively.
  Thus, $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{id}})=2$, meaning that the input variable $\texttt{x}$ is used.

\begin{marginlisting}[*-3]
  \caption{The random program.}
  \labprog{random}
  \vspace{15pt}
\begin{lstlisting}[style=mystyle,language=customPython]
random(x):
  return rand();
  \end{lstlisting}
\end{marginlisting}
  The trace semantics of \refprog{random} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{random}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 1\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 2\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \anyvalue\rangle}
      \end{array}
    \right\}
  \end{align*}

  \begin{marginfigure}[*-5]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{3}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (0) -> (out1);
      \draw[->] (0) -> (out2);
      \draw[->] (1) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (1) -> (out2);
      \draw[->] (2) -> (out0);
      \draw[->] (2) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{random}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{random}.}
  \labfig{random-traces}
  \end{marginfigure}
  In this case, any outcome can be produced by any input value, thus the set of input states is $\{\tracetuple{\locinit}{\langle 0\rangle}, \tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$ for all outcomes.
  Since all possible permutations of the variable \texttt{x} are already in each set of input states from outcomes, we obtain the value $0$.
  Thus, $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{random}})=0$, meaning that the input variable $\texttt{x}$ is not used.

  \begin{marginlisting}[*-4]
    \caption{First example combining random and constant value.}
    \labprog{mix1}
    \vspace{25pt}
  \begin{lstlisting}[style=mystyle,language=customPython]
mix1(x):
  if x > 0:
    return rand();
  else:
    return 0;
  \end{lstlisting}
\end{marginlisting}
  The trace semantics of \refprog{mix1} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix1}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle 0\rangle}\tracearrow\tracetuple{\loc{6}}{\langle 0\rangle}, \\
        \tracetuple{\locinit}{\langle 1\rangle}\tracearrow\tracetuple{\loc{6}}{\langle \anyvalue\rangle}, \\
        \tracetuple{\locinit}{\langle 2\rangle}\tracearrow\tracetuple{\loc{6}}{\langle \anyvalue\rangle}
      \end{array}
      \right\}
  \end{align*}
  \begin{marginfigure}[*-2]
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{6}:$};

      % Define the positions of the nodes
      \node (0) at (0,2) {${\langle 0 \rangle}$};
      \node (1) at (1,2) {${\langle 1 \rangle}$};
      \node (2) at (2,2) {${\langle 2 \rangle}$};

      \node (out0) at (0,0) {${\langle 0 \rangle}$};
      \node (out1) at (1,0) {${\langle 1 \rangle}$};
      \node (out2) at (2,0) {${\langle 2 \rangle}$};

      % Draw the edges
      \draw[->] (0) -> (out0);
      \draw[->] (1) -> (out0);
      \draw[->] (1) -> (out1);
      \draw[->] (1) -> (out2);
      \draw[->] (2) -> (out0);
      \draw[->] (2) -> (out1);
      \draw[->] (2) -> (out2);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{mix1}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{mix1}.}
  \labfig{mix1-traces}
  \end{marginfigure}
  In this case, the set of input states that can produce the outcome $0$ is $\{\tracetuple{\locinit}{\langle 0\rangle}, \tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$, for the outcome $1$ is $\{\tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$, and for the outcome $2$ is $\{\tracetuple{\locinit}{\langle 1\rangle}, \tracetuple{\locinit}{\langle 2\rangle}\}$.
  Respectively, the input state $\tracetuple{\locinit}{\langle 0 \rangle}$ is missing from both sets of input states that can produce the outcomes $1$ and $2$.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix1}})=1$.


  \begin{marginlisting}
    \caption{Second example combining random and constant value.}
    \labprog{mix2}
    \vspace{25pt}
  \begin{lstlisting}[style=mystyle,language=customPython]
mix2(x, y):
  if (not x) and y:
    return rand()
  return y
 \end{lstlisting}
  \end{marginlisting}
  For this last program we introduce another variable \texttt{y}, we simplify even further the variable to boolean values $\{\true, \false\}$.
  The trace semantics of \refprog{mix2} is:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{mix2}}
    =
    \left\{
      \begin{array}{l}
        \tracetuple{\locinit}{\langle \true, \true\rangle}\tracearrow\tracetuple{\loc{5}}{\langle \true\rangle}, \\
        \tracetuple{\locinit}{\langle \true, \false\rangle}\tracearrow\tracetuple{\loc{5}}{\langle \false\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{5}}{\langle \true\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{5}}{\langle \false\rangle}, \\
        \tracetuple{\locinit}{\langle \false, \false\rangle}\tracearrow\tracetuple{\loc{5}}{\langle \false\rangle}
      \end{array}
      \right\}
  \end{align*}
  \begin{marginfigure}
    \begin{tikzpicture}[scale=0.8]
      \node (linit) at (-0.9,2) {$\locinit:$};
      \node (lend) at (-0.9,0) {$\loc{5}:$};

      % Define the positions of the nodes
      \node (TT) at (0,2) {${\tuple\true\true}$};
      \node (TF) at (1,2) {${\tuple\true\false}$};
      \node (FT) at (2,2) {${\tuple\false\true}$};
      \node (FF) at (3,2) {${\tuple\false\false}$};

      \node (T) at (0.5,0) {${\langle \true \rangle}$};
      \node (F) at (2.5,0) {${\langle \false \rangle}$};

      % Draw the edges
      \draw[->] (TT) -> (T);
      \draw[->] (TF) -> (F);
      \draw[->] (FT) -> (T);
      \draw[->] (FT) -> (F);
      \draw[->] (FF) -> (F);

      \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{mix2}}$};
  \end{tikzpicture}
  \caption{Graphical representation of the trace semantics of \refprog{mix2}.}
  \labfig{mix2-traces}
  \end{marginfigure}
  In this case, the set of input states that can produce the outcome $\true$ is $\{\tracetuple{\locinit}{\langle \true, \true\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}\}$, for the other outcome $\false$ the set of input states is $\{\tracetuple{\locinit}{\langle \true, \false\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}, \tracetuple{\locinit}{\langle \false, \false\rangle}\}$.
  In case $\definputvariables=\{\texttt{x}\}$, the state $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is missing from the set of input states that can produce the outcome $\false$, obtained by permuting the variable \texttt{x} on the input state $\tracetuple{\locinit}{\langle \false, \true\rangle}$.
  Instead, the set of states $\{\tracetuple{\locinit}{\langle \true, \true\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}\}$ already contains all the possible permutations of the variable \texttt{x}.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{x}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix2}})=1$.
  On the other hand, if $\definputvariables=\{\texttt{y}\}$, the states $\tracetuple{\locinit}{\langle \false, \false\rangle}$ and $\tracetuple{\locinit}{\langle \true, \false\rangle}$ are missing from the set of input states that can produce the outcome $\true$. No state is missing from the set of input states that can produce the outcome $\false$.
  Thus, we yield the highest value of missing states, obtaining $\qusedname_{\{\texttt{y}\}}(\tracesemanticsnoparam\semanticsof{\texttt{mix2}})=2$.

  From these examples we notice that the $\qusedname$ impact quantifier is able to capture that a variable is not used in a program, even in the presence of non-deterministic statements, \cf{} \refprog{random}.
  Moreover, $\qusedname$ also discriminates between different amount of impact.
  Indeed, \refprog{id} is, intuitively, the program where the input variable has the highest impact possible as the output is exactly its value, while \refprog{random} the lowest as the output is random.
\end{example}

Next, we show the validation of the $\defbound$-bounded impact property when instantiated with the $\qusedname$ impact quantifier.
% Note the use of the $\ge$ operator\sidenote{Previously, for the \outcomesname{} and \rangename{} impact quantifiers, the $\defbound$-bounded impact property employed the $\le$ comparison operator.} in our property $\boundedqused$. This design choice is due to the fact that the $\qusedname$ impact quantifier is neither monotonic nor anti-monotonic in the amount of traces in $\defsetoftraces$. Thus, the same way the syntactic dependency analysis consider an under-approximation of dependencies among variables to return a sound result, the static analysis for $\qusedname$ considers an under-approximation of the ``missing'' input values. In detail, it considers an under-approximation of the set of input values $Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)$ for the given set of traces $\defsetoftraces$. This under-approximation may lead to a lower value of $\qusedname$ than the actual value, hence the use of the $\ge$ operator as the concrete bound is always higher.

\siderefbox{def}{output-abstraction-semantics}
\siderefbox{def}{abstraction-dependency-semantics}
\siderefbox{def}{abstraction-output-abstraction-semantics}
\begin{lemma}[$\boundedqused$ Validation]\lablemma{qused-validation}
  \begin{align*}
    \collectingsemantics \subseteq \BOUNDEDQUSED \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\BOUNDEDQUSED))
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  Let us consider the $\outputabstraction \circ \dependencyabstraction$ abstraction of the $\defbound$-bounded impact property $\boundedqused$:
  \marginnote{
    \begin{align*}
      &I_{\retrieveoutput{\defstate}}(\defsetofdependencies) \spacearound= \\
      &\quad \seTDef{
        \retrieveinput{\defstate'}
      }{
        \inputoutputtuple{\defstate'} \in \defsetofdependencies \land
        \outputobs(\retrieveoutput{\defstate}) = \outputobs(\retrieveoutput{\defstate'})
      } \\
      &Q_\definputvariables(\defsetofstates) \spacearound= \\
      &\quad\setdef{
        \defstate' \in \state
      }{
        \defstate \in \defsetofstates \land
          \defstate' \stateeq{\inputvariableswithoutw} \defstate
      }
    \end{align*}
  }
  \begin{eqnarray*}
    \lefteqn{\outputabstraction(\dependencyabstraction(\boundedqused)) =} \\
    &
    \setdef{
      \defsetofdependencies \in \setof\pairofstates
    }{
      \sup_{\inputoutputtuple{\defstate} \in \defsetofdependencies}
    \cardinality*{
        Q_\definputvariables(I_{\retrieveoutput{\defstate}}(\defsetofdependencies)) \setminus I_{\retrieveoutput{\defstate}}(\defsetofdependencies)
      } \comparison \defbound
    }
  \end{eqnarray*}
  As noticed before, the $\qusedname$ impact quantifier does not consider the intermediate states and abstracts the output states before any computation.
  Hence, neither the abstraction to dependencies nor the abstraction to output values affect the validation of the property.
\end{proof}

The next example shows that $\qusedname$ is neither monotonic nor anti-monotonic in the amount of traces, meaning that, by adding or removing traces from a given set $\defsetoftraces\in\tracetype$ the quantity $\qused(\defsetoftraces)$ may increase or decrease.
Notably, the major consequence is that $\boundedqused$ is neither subset- nor superset-closed. Thus, not all the subsets, respectively supersets, of a potential over-approximation, respectively under-approximation, of the trace semantics satisfy the $\boundedqused$ property.
% To address this issue, from the result of the abstract analysis we compute an under-approximation of the input values that are definitely missing from the set of input values that can produce the outcomes. This under-approximation provides a lower bound on the $\qusedname$ impact quantifier, hence the use of the $\ge$ operator in the $\defbound$-bounded impact property.

\begin{example}\labexample{qused-not-monotonic}
In this example, we show that the $\qusedname$ impact quantifier is neither monotonic nor anti-monotonic in the amount of traces.
Specifically, we consider two input variables with boolean values $\{\true, \false\}$, the \refprog{id2} returns the second component of the input without any modification.
\begin{marginlisting}[*-2]
  \caption{Identity function on the second component.}
  \labprog{id2}
  \vspace{25pt}
\begin{lstlisting}[style=mystyle,language=customPython]
id2(x, y):
  return y
 \end{lstlisting}
\end{marginlisting}
The trace semantics of \refprog{id2} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{id2}}
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}[*-4]
  \begin{tikzpicture}[scale=0.8]
    \node (linit) at (-0.9,2) {$\locinit:$};
    \node (lend) at (-0.9,0) {$\loc{3}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{id2}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of \refprog{id2}.}
\labfig{id2-traces}
\end{marginfigure}
For the set of traces $\tracesemanticsnoparam\semanticsof{\texttt{id2}}$, we have that $\qusedname_{\{\texttt{x} \}}(\tracesemanticsnoparam\semanticsof{\texttt{id2}})=0$ as no input state is missing from both the sets that can produce the outcomes $\true$ and $\false$. In fact, the variable \texttt{x} is \emph{not used} in the program.
Let us consider the bigger set of traces $\defsetoftraces \supseteq \tracesemanticsnoparam\semanticsof{\texttt{id2}}$:
\begin{align*}
  \defsetoftraces
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}[*-8]
  \begin{tikzpicture}[scale=0.8]
    % \node (linit) at (-0.9,2) {$\locinit:$};
    % \node (lend) at (-0.9,0) {$\loc{3}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FT) -> (F);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-0.5,2.2) -- (-0.5,-0.2) node [black,midway,xshift=-0.7cm] {$\defsetoftraces$};
\end{tikzpicture}
\caption{Graphical representation of $\defsetoftraces$.}
\labfig{defsetoftraces-traces}
\end{marginfigure}
This set of traces could be obtained by the \refprog*{mix2}[*-1].
In this case, $\qusedname_{\{\texttt{x} \}}(\defsetoftraces)=1$ as the input value $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is missing from the set of input values that can produce the outcome $\false$, \cf, the set $\{ \tracetuple{\locinit}{\langle \true, \false\rangle}, \tracetuple{\locinit}{\langle \false, \true\rangle}, \tracetuple{\locinit}{\langle \false, \false\rangle} \}$.
Note that, in this case, the variable \texttt{x} is \emph{used} in the program.
Lastly, let us enlarge again the set of traces to $\defsetoftraces' \supseteq \defsetoftraces$:
\begin{align*}
  \defsetoftraces'
  =
  \left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\langle \true, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \true, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \true\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \true\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}, \\
      \tracetuple{\locinit}{\langle \false, \false\rangle}\tracearrow\tracetuple{\loc{3}}{\langle \false\rangle}
    \end{array}
    \right\}
\end{align*}
\begin{marginfigure}[*-6]
  \begin{tikzpicture}[scale=0.8]
    \node (linit) at (-0.9,2) {$\locinit:$};
    \node (lend) at (-0.9,0) {$\loc{6}:$};

    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};

    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};

    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TT) -> (F);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FT) -> (F);
    \draw[->] (FF) -> (F);

    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=-0.1pt] (-1.1,2.2) -- (-1.1,-0.2) node [black,midway,xshift=-0.7cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{false\_or\_rand}}$};
\end{tikzpicture}
\caption{Graphical representation of the trace semantics of \refprog{false-or-rand}.}
\labfig{false-or-rand-traces}
\end{marginfigure}
In this case, $\qusedname_{\{\texttt{x} \}}(\defsetoftraces')=0$ as the input $\tracetuple{\locinit}{\langle \true, \true\rangle}$ is not missing anymore in the set of input values that can produce the outcomes $\false$.
For instance, a program that may generate such a set of traces is the \refprog{false-or-rand}.
\begin{marginlisting}
  \caption{False or random program.}
  \labprog{false-or-rand}
  \vspace{15pt}
\begin{lstlisting}[style=mystyle,language=customPython]
false_or_rand(x, y):
  if not y:
    return False
  else:
    return rand()
 \end{lstlisting}
\end{marginlisting}
This example shows that \[\qusedname_{\{\texttt{x} \}}(\tracesemanticsnoparam\semanticsof{\texttt{id2}}) \LE \qusedname_{\{\texttt{x} \}}(\defsetoftraces) \GE \qusedname_{\{\texttt{x} \}}(\defsetoftraces')\] where $\tracesemanticsnoparam\semanticsof{\texttt{id2}} \subseteq \defsetoftraces \subseteq \defsetoftraces'$.
Thus, the $\qusedname$ impact quantifier is neither monotonic nor anti-monotonic in the amount of traces, as the quantifier $\qusedname$ may increase or decrease by adding or removing traces from a given set.
\end{example}





Unlike for the previous impact quantifiers, it holds that, whenever $\qused(\tracesemantics)$ is 0, the program $\defprogram$ does not use the input variable $\definputvariables$, even in the presence of non-determinism.
Thus, we can establish the following equivalence:

\siderefbox{def}{abstract-unused}
\siderefbox{def}{qused}
\begin{lemma}[Unused Equivalence]\lablemma{qualitative-quantitative-equivalence}
  For all program $\defprogram$, it holds that:
  \begin{gather*}
    \unusediowrapper(\tracesemantics) \IfF \qused(\tracesemantics) = 0
  \end{gather*}
\end{lemma}
\begin{proof}
  To show ($\Rightarrow$) we assume that $\unusediowrapper(\tracesemantics)$.
  As a consequence, we have that any outcome either is not reachable or is reachable from every input value of the variables $\definputvariables$.
  Thus, for any $\deftrace\in\defsetoftraces$, the set of input values that can produce that outcome is the set of all input values, \ie{}, $I_{\deftrace}(\defsetoftraces) = \values$.
  Since we remove from $Q_{\definputvariables}(I_{\deftrace}(\defsetoftraces))$ the set of input values, we obtain a value of 0 for all traces, hence $\qused(\tracesemantics) = 0$.

  To show ($\Leftarrow$) we assume that $\qused(\tracesemanticsnoparam) = 0$.
  By definition, for all $\retrieveoutput\defstate$, the set of input values that can produce the outcome $\retrieveoutput\defstate$ is the set of all input values, otherwise $\qused(\tracesemanticsnoparam)$ would not be 0.
  Thus, for all traces $\deftrace\in\tracesemantics$ and input values $\defvalue\in\values$ such that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, we have that it exists a trace $\deftrace'$ such that $\outputobs(\retrieveoutput{\deftrace'}) = \outputobs(\retrieveoutput{\deftrace})$ and $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, otherwise it would not be possible that the set of input values that can produce any outcome is the set of all input values. Hence, $\unusediowrapper(\tracesemantics)$.
\end{proof}


\begin{marginfigure}
  % shows on top a bar going from $\defbound=0$ (left) to $\defbound=1$, $\defbound=2$, and finally $\defbound=\dots$ (right); this is a dashed bar with a bigger dot for numbers, label ar above.
  % Below, we have a dotted vertical line going from each dot to the bottom of the figure.
  % Here we have four layers, each one with two curly braces, splitting in two the layer.
  \centering
  \begin{tikzpicture}[scale=0.9]
    \def\first{0};
    \def\fourth{3.9};
    \def\second{\fourth/3*1};
    \def\third{\fourth/3*2};

    \def\slack{0.3};
    \def\beforefirst{\first-\slack};
    \def\beforesecond{\second-\slack};
    \def\beforethird{\third-\slack};
    \def\beforefourth{\fourth-\slack};
    \def\afterfirst{\first+\slack};
    \def\aftersecond{\second+\slack};
    \def\afterthird{\third+\slack};
    \def\afterfourth{\fourth+2*\slack};

    \def\layerheight{1.1};
    \def\firstlevel{-0.3};
    \def\secondlevel{\firstlevel-\layerheight};
    \def\thirdlevel{\secondlevel-\layerheight};
    \def\fourthlevel{\thirdlevel-\layerheight};

    \draw[dashed] (\first,0) -- (\fourth + 0.5,0);
    \foreach \x in {\first, \second, \third, \fourth}
    \draw (\x cm,3pt) -- (\x cm,-3pt);
    \draw (\first,0) node[above=4pt] {$\defbound=0$};
    \draw (\second,0) node[above=4pt] {$\defbound=1$};
    \draw (\third,0) node[above=4pt] {$\defbound=2$};
    \draw (\fourth,0) node[above=4pt] {$\defbound=\cdots$};
    \draw[dotted] (\first,0) -- (\first,\fourthlevel);
    \draw[dotted] (\second,0) -- (\second,\fourthlevel);
    \draw[dotted] (\third,0) -- (\third,\fourthlevel);
    \draw[dotted] (\fourth,0) -- (\fourth,\fourthlevel);

    % horizontal curly brackets, two each level
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterfirst,\firstlevel) -- (\beforefirst,\firstlevel) node [black,midway,yshift=-0.4cm,xshift=0.7cm] {$\boundedqusedle[0] = \unused$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterfourth,\firstlevel) -- (\beforesecond,\firstlevel) node [black,midway,yshift=-0.4cm, xshift=0.5cm] {$\boundedqusedge[1] = \neg\unused$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\aftersecond,\secondlevel) -- (\beforefirst,\secondlevel) node [black,midway,yshift=-0.4cm] {$\boundedqusedle[1]$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterfourth,\secondlevel) -- (\beforethird,\secondlevel) node [black,midway,yshift=-0.4cm] {$\boundedqusedge[2]$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterthird,\thirdlevel) -- (\beforefirst,\thirdlevel) node [black,midway,yshift=-0.4cm] {$\boundedqusedle[2]$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterfourth,\thirdlevel) -- (\beforefourth,\thirdlevel) node [black,midway,yshift=-0.4cm] {$\boundedqusedge[3]$};
    \draw [decorate,decoration={brace,amplitude=4pt},xshift=0pt,yshift=0pt] (\afterfourth,\fourthlevel) -- (\beforefirst,\fourthlevel) node [black,midway,yshift=-0.4cm] {$\boundedqusedle[+\infty] = \boundedqusedge[0]$};
  \end{tikzpicture}
  \caption{Graphical comparison between the unused $\unused$ and the $\defbound$-bounded impact property $\boundedqused$.}
  \labfig{unused-bounded}
\end{marginfigure}

As a consequence of \reflemma{qualitative-quantitative-equivalence}, we obtain an equivalence between the (un)used property (\cf{} \refdef*{unused}) and the $\defbound$-bounded impact property (\cf{} \refdef{bounded}) instantiated with the $\qusedname$ quantifier:
\begin{align*}
  \BOUNDEDQUSEDLE[0]\spacearound{=}\unused  && \text{if } {} \comparison {} = {} \le {}\\
  \BOUNDEDQUSEDGE[1]\spacearound{=}  \neg\unused&& \text{if } {} \comparison {} = {} \ge {}
\end{align*}
meaning that if a program semantics does not utilize the variables $\definputvariables$, then it has an impact of \emph{at most} $0$ (and vice versa).
Conversely, if a program semantics utilizes the variables $\definputvariables$, then it has an impact of \emph{at least} $1$ (and vice versa).
\reffig{unused-bounded} depicts an overview of the relationship between the unused property $\unused$ and the various $\defbound$-bounded impact properties $\boundedqused$ instantiated with different thresholds and comparison operators.
\marginnote{The $\defbound$-bounded impact property instantiated with the $\qusedname$ quantifier:
\[
\BOUNDEDQUSED \DefeQ \setdef{\tracesemanticsnoparam}{\qused(\tracesemanticsnoparam)\comparison \defbound}
\]}

In the rest of this chapter, we present the static analysis to verify the $\defbound$-bounded impact property of a program and show the abstract version of the quantifiers introduced in this chapter.

\section{Abstract Quantitative Input Data Usage}
\labsec{abstract-quantitative-input-data-usage}

In this section, we introduce a sound and computable static analysis to verify the $\defbound$-bounded impact property of a program.
The soundness of the approach leverages two elements: (1) a backward abstract semantics, and (2) sound and computable implementations of the quantifiers \outcomesname{}, \rangename{}, and \qusedname{} (written as $\abstractoutcomesname$, $\abstractrangename$, and $\abstractqusedname$ respectively).


To quantify the usage of the input variables $\definputvariables$, we need to determine the input configurations leading to specific output values.
As our impact quantifiers measure over the reachable output values (more precisely, over their abstraction by $\outputobs$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is a parameter of the analysis and a \emph{good} choice is essential for obtaining a precise and meaningful analysis result.
\marginnote{
  An indexed set $F\in X^n$ where $n\in\N$, is a map from the set of indices $N_{\le n}$ to the set of elements $X$.
}

For each output bucket $\bucket\in\abstractdomain$, where $1 \le j \le n$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
% More formally, the reduction of the output-abstraction semantics $\outputsemanticsnoparam$ to the dependencies with abstraction of a final state in $X$ is defined as:
% \[
%   \reduce[\outputsemanticsnoparam]{X} \DefeQ \setdef{
%     \setdef{
%       \tuple{\retrieveinput\defstate}{\outputobs(\retrieveoutput{\defstate})}\in\defsetofdependencies
%     }{
%       \retrieveoutput{\defstate} \in X
%       }
%   }{
%     \defsetofdependencies\in \outputsemanticsnoparam
%   }
% \]
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote[][*-2]{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemanticsnoparam\in\backwardtype$ which computes the backward semantics $\backwardsemanticsnoparam(\bucket)$ from a given output bucket $\bucket\in\abstractdomain$.
For instance, we could use the backward semantics of \refdef*{backward-semantics} to compute $\backwardsemanticsnoparam(\bucket)$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\outputtype$ employs the concretization of the abstract domain $\abstractdomainconcretization$ to restore all possible dependencies from input states to output values.

\begin{definition}[Concretization $\backwardconcretization$]\labdef{backward-concretization}
  Given a backward semantics $\backwardsemanticsnoparam\in\backwardtype$ and $\numberofbuckets$ output buckets $\buckets$, the \emph{concretization} $\backwardconcretization$ is defined as:
  \begin{align*}
  \backwardconcretization&\IN(\backwardtype)\to\abstractdomain\to\outputtype \\
  \backwardconcretization(\backwardsemanticsnoparam)\bucket &\DefeQ
  \setof{\setdef{
    \inputoutputtuple{\defstate}
  }{
    \retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemanticsnoparam(\bucket))\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)
    }
  }
  \end{align*}

\end{definition}

In words, $\backwardconcretization$ collects all the input-output dependencies from the application of the backward semantics to each output bucket $\bucket$.
Since the abstract semantics may discover more dependencies than the concrete ones, the concretization returns all possible subsets of dependencies.
In such a way, we ensure that the (restriction of the) output-abstraction semantics is a subset of the abstract one.
%
We can thus define the soundness condition for the backward semantics with respect to the reduction of the output-abstraction semantics.

\siderefbox{def}{output-reduction}

\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\labdef{sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reducedoutputsemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$ as follows:

\begin{definition}[Multi-Bucket Semantics \texorpdfstring{$\multisemanticsnoparam$}{}]\labdef{multi-semantics}
  We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is:
\begin{align*}
\multisemantics\buckets \DefeQ (\backwardsemantics\bucket)_{j\le n}
\end{align*}
\end{definition}


The concretization function $\multiconcretization$ maps the multi-bucket semantics $\multisemanticsnoparam$ from a given set of output buckets $\buckets$ to a set of sets of dependencies in $\outputtype$.
Specifically, for each output bucket $\bucket\in\buckets$, $\multiconcretization$ concretizes the output from $\abstractdomainconcretization(\bucket)$ and the input states from the application of the backward semantics to $\bucket$, \ie, $\abstractdomainconcretization((\multisemantics\buckets)_j)$.
Hence, all the possible input-output dependencies are collected for all buckets.
% Lastly, to account for the fact that the abstract semantics may discover more dependencies than the concrete ones, the concretization returns all combinations of dependencies.
\begin{definition}[Multi-Bucket Concretization \texorpdfstring{$\multiconcretization$}{}]\labdef{multi-concretization}
  We define the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\outputtype$ as:
\begin{gather*}
  \multiconcretization(\multisemantics)\buckets \DefeQ
  \bigsetjoin_{j\le n} \backwardconcretization(\backwardsemantics)\bucket
\end{gather*}
\end{definition}

Next, we show the soundness of the multi-bucket semantics with respect to the output-abstraction semantics.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the Multi-Bucket Semantics}]\lablemma{sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin\limits_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}
\begin{proof}
  From \refdef{multi-semantics} we have that $\multiconcretization(\multisemanticsnoparam)\buckets = \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$.
  Then, from \refdef{sound-over-approximation}, we obtain that $\foralldef{j \le n}{\reducedoutputsemanticsnoparam \subseteq \backwardconcretization(\backwardsemanticsnoparam(\bucket))}$.
  Thus, by monotonicity of the union operator over set inclusion, it holds that $\bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam \subseteq \bigsetjoin_{j\le n}\backwardconcretization(\backwardsemanticsnoparam(\bucket))$. We conclude by:
  \begin{align*}
    \bigsetjoin_{j\le n}\reducedoutputsemanticsnoparam &= \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$} \\
    &= \setdef{\inputoutputtuple{\defstate}\in\outputsemanticsnoparam}{\retrieveoutput{\defstate}\in\bigsetjoin_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by set definition} \\
    &= \reducenoparam{\bigsetjoin\limits_{j \le n}\abstractdomainconcretization(\bucket)}
      && \text{by $\reducenoparam{X}$}
  \end{align*}
  \end{proof}

We introduce the concept of \emph{covering} for output buckets to ensure that no potential final state is missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  Let $\outputobs\in\stateandbottom\to\stateandbottom$ be the output observer, we say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the subset of potential outcomes whenever it holds that:
  \[
    \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput{\defstate} \in \stateandbottom} \SubseteQ \setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}
  \]
\end{definition}


Whenever the output buckets \textit{cover} the subset of outcomes abstracted by $\outputobs$, $\multisemanticsnoparam$ is a sound over-approximation of $\outputsemanticsnoparam$.

\begin{lemma}\lablemma{sound-approximation-covering}
  Let $\buckets\in\vectorbuckets$ be the set of output buckets such that it covers the subset of potential outcomes of a program $\defprogram$.Then, it holds that the semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the output-abstraction semantics $\outputsemanticsnoparam$:
  \[
    \outputsemantics \SubseteQ \multiconcretization(\multisemantics)\buckets
  \]
\end{lemma}
\begin{proof}
  Follows directly from \reflemma{sound-over-approximation-multi-bucket} and \refdef{covering}. The covering of the output buckets ensures that no potential final state is missed and thus let the reduction of the output-abstraction semantics unnecessary, as it holds that $\outputsemantics = \reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)}$.
\end{proof}



% Additionally, the output buckets needs to be compatible with the concrete outcomes of the program, meaning that two output states cannot map to the same output abstraction if they belong to different output buckets.

% \begin{definition}[Compatibility]\labdef{compatibility}
%   Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\valuesinf$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
%   \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
% \end{definition}

So far, we presented the semantics $\multisemanticsnoparam$ as an abstraction of the output-abstraction semantics $\outputsemanticsnoparam$ via \reflemma{sound-approximation-covering}.
Next, this section shows the concept of sound implementation of the impact quantifiers.
We expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher (or always lower depending on the ordering operator $\comparison$ of $\genbounded$) than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\labdef{sound-implementation}
  For all output buckets $\buckets$ and family of semantics $\multisemanticsnoparam$,
  whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-4], and
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering},
  \end{enumerate}
  we say that $\impactinstance$ is a \textup{sound implementation} of $\impactwrapper$ if and only if:
  \begin{eqnarray*}
  \impactwrapper(
    \tracesemantics
    ) \ComparisoN \impactinstance(\multisemantics\buckets, \buckets)
  \end{eqnarray*}
\end{definition}

\refdef{sound-implementation} ensures that the soundness of the static analysis is preserved when computing the quantity $\defbound$.
Then, we define $\boundconcretization \in \valuesinf \to \collectingtype$, \ie, the concretization of the bound measured by the abstract impact $\impactinstance(\multisemantics\buckets, \buckets)$.
The idea behind the concretization $\boundconcretization$ is to filter the set of sets of traces concretized by $\multiconcretization$ that yield an impact lower, respectively higher, than the bound computed in the abstract, \cf{} $\impactinstance(\multisemantics\buckets, \buckets)$.
Before defining the concretization, we show an example where not all subsets of $\multiconcretization$ satisfy the property $\genbounded$.
% \marginnote[*7]{The operator $\singletonelimination \in \setof A \to \setof A$ removes the set around a singleton set, \ie, $\singletonelimination(\{a\}) = a$.}

\marginnote{
  \begin{tikzpicture}[scale=0.9]
    \node (linit) at (-0.7,2) {$\locinit:$};
    \node (lend) at (-0.7,0) {$\loc{3}:$};
    % Define the positions of the nodes
    \node (TT) at (0,2) {${\tuple\true\true}$};
    \node (TF) at (1,2) {${\tuple\true\false}$};
    \node (FT) at (2,2) {${\tuple\false\true}$};
    \node (FF) at (3,2) {${\tuple\false\false}$};
    \node (T) at (0.5,0) {${\langle \true \rangle}$};
    \node (F) at (2.5,0) {${\langle \false \rangle}$};
    % Draw the edges
    \draw[->] (TT) -> (T);
    \draw[->] (TF) -> (F);
    \draw[->] (FT) -> (T);
    \draw[->] (FT) -> (F);
    \draw[->] (FF) -> (F);
    \draw[decorate,decoration={brace,amplitude=8pt,mirror,raise=4pt},yshift=0pt,xshift=0pt] (-0.8,2.2) -- (-0.8,-0.2) node [black,midway,xshift=-0.6cm,rotate=90] {$\tracesemanticsnoparam\semanticsof{\texttt{mix2}}$};
\end{tikzpicture}
}
\begin{example}
  We assume we are interested in the validation of the property $\boundedqusedge$, where the impact quantifier is $\qusedname$ and the comparison operator for quantity bounds is $\ge$.
  We consider the trace semantics of the program \refprog*{mix2}, \ie, $\tracesemanticsnoparam\semanticsof{\texttt{mix2}}$, depicted on the side.
  Consider an abstract semantics $\multisemanticsnoparam\semanticsof{\texttt{mix2}}$ that concretize to the following sets of dependencies:
  \begin{align*}
    \multiconcretization(\multisemanticsnoparam\semanticsof{\texttt{mix2}})\buckets \spacearound{=}
    \setof*{\left\{
    \begin{array}{l}
      \tuple{\tracetuple{\locinit}{\langle \true, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \true, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \true\rangle}}{\tracetuple{\loc{3}}{\langle \anyvalue\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}
    \end{array}
    \right\}}
  \end{align*}
  % where the dependency $\tuple{\tracetuple{\locinit}{\langle \false, \true\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}$ is the result of the over-approximation.
  As noted in \refexample{qused-not-monotonic}, the $\qusedname_{\{\texttt{x}\}}$ applied to the biggest set of the concretized dependencies above is 1.
  If we assume the abstract impact returns the bound 1, \ie, $\impactinstance(\multisemanticsnoparam\semanticsof{\texttt{mix2}}, \buckets) = 1$, then $\boundconcretization$ should filter from $\multiconcretization(\multisemantics)\buckets$ the sets of dependencies that yield an impact lower than the bound 1 as the validation of the property $\boundedqusedge$ employs the $\ge$ operator in this example.
  In particular, the following set of dependencies is removed:
  \begin{align*}
    \defsetoftraces \spacearound{=}
    \left\{
    \begin{array}{l}
      \tuple{\tracetuple{\locinit}{\langle \true, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \true, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \true\rangle}}{\tracetuple{\loc{3}}{\langle \true\rangle}}, \\
      \tuple{\tracetuple{\locinit}{\langle \false, \false\rangle}}{\tracetuple{\loc{3}}{\langle \false\rangle}}
    \end{array}
    \right\}
  \end{align*}
  as $\qusedname_{\{\texttt{x}\}}(\defsetoftraces)$ is 0 in such case (\cf{} \refexample{qused-not-monotonic}).
  % Note that, there is a contradiction here, as the abstract impact $\impactinstance(\multisemanticsnoparam\semanticsof{\texttt{mix2}}, \buckets)$ is assumed to be $1$ and should be smaller that the concrete one, which is $0$.
  % In fact, to be sound, the abstract impact should return a number not greater than $0$, and the concretization $\boundconcretization$ should not filter any set of dependencies.
\end{example}

\begin{definition}[Concretization of the Measured Quantity]\labdef{concretization-quantitative}
  The concretization of a measured quantity $\defbound$ is $\boundconcretization\in\valuesinf\to\collectingtype$, defined as:
  \begin{align*}
    &\boundconcretization(\impactinstance(\multisemantics\buckets, \buckets)) \DefeQ \\
    & \quad
    \setdef{\defsetoftraces \in \dependencyconcretization \circ \outputconcretization \circ \multiconcretization(\multisemantics)\buckets}{
      \impactwrapper(\defsetoftraces) \comparison \impactinstance(\multisemantics\buckets, \buckets)
    }
  \end{align*}
\end{definition}

% Note that, it holds an equivalence with the $\defbound$-bounded impact property:
% \[
%   \boundconcretization(\defbound) = \genbounded
% \]

% Additionally, we note that the concretization $\boundconcretization$ is monotonically increasing, respectively decreasing, depending on comparison operator $\comparison$.

% \begin{lemma}[Monotonicity of $\boundconcretization$]\lablemma{monotonicity-bound-concretization}
%   Depending on the comparison operator $\comparison$, for all quantities $\defbound',\defbound\in\valuesposplus$ measured by the abstract impact $\impactinstance$ it holds that:
%   \begin{enumerate}[label=(\roman*)]
%     \item $\defbound' \le \defbound \ImplieS \leconcretization(\defbound') \subseteq \leconcretization(\defbound)$
%     \item $\defbound' \ge \defbound \ImplieS \geconcretization(\defbound') \supseteq \geconcretization(\defbound)$
%   \end{enumerate}
% \end{lemma}
% \begin{proof}
%   The proof follows directly from the definition of the concretization $\boundconcretization$. By increasing the bound $\defbound'$, the set of traces in $\leconcretization(\defbound')$ can only increase as we weaken the condition. On the other hand, $\geconcretization(\defbound')$ can only decrease as we strengthen the condition.
% \end{proof}

The concretization $\boundconcretization$ maintains the set of traces concretized by $\multiconcretization$, $\outputconcretization$ (\cf{} \refdef*{concretization-dependency-semantics}), and $\dependencyconcretization$ (\cf{} \refdef*{concretization-output-abstraction-semantics}) that yield an impact lower, respectively higher, than the bound computed in the abstract, \cf, $\impactinstance(\multisemantics\buckets, \buckets)$.

\begin{remark}
  Based on the impact quantifier $\impactwrappername$, the $\defbound$-bounded impact property $\genbounded$ can be subset-closed, meaning that whenever a set of traces satisfies the property, all its subsets also satisfy the property.
In this case, it would hold that
\begin{align*}
  \multiconcretization(\multisemantics)\buckets
  \SubseteQ \boundconcretization(\impactinstance(\multisemantics\buckets, \buckets))
\end{align*}
However, this is not always the case.
Indeed, some subsets of traces may not satisfy the property $\genbounded$.
\end{remark}


The concretization $\boundconcretization$ is used to prove that the abstract semantics $\multisemanticsnoparam$ is sound for proving the property $\genbounded$.


\siderefbox{def}{concretization-quantitative}
\siderefbox{def}{bounded}
\begin{lemma}\lablemma{soundness-boundconcretization}
  A program $\defprogram$ has an impact of at most $\defbound$ (respectively, at least $\defbound$ depending on the comparison operator $\comparison$) only if the set of dependencies concretized from the quantity $\impactwrapper(\tracesemantics)$
  are a subset of the semantics in $\genbounded$.
  \begin{align*}
    \boundconcretization(
      \impactwrapper(\tracesemantics)
    ) \SubseteQ \GENBOUNDED  \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{lemma}
\begin{proof}
  By hypothesis, we assume that $\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(
    \defbound'
  ) \subseteq \genbounded$ where $\defbound' = \impactwrapper(\tracesemantics)$.
  We have that $\outputsemantics \subseteq \boundconcretization(\defbound')$ by definition of $\boundconcretization$, \cf{} \refdef{concretization-quantitative}.
  Then, by monotonicity of $\outputconcretization$ and $\dependencyconcretization$, \cf{} \refdef{right-left-adjoints-for-the-output-abstraction-semantics} and \refdef{right-left-adjoints-for-the-dependency-semantics} respectively, we have that $\dependencyconcretization(\outputconcretization(\outputsemantics)) \subseteq \dependencyconcretization(\boundconcretization(\defbound'))$.
  Thus, since $\dependencyconcretization \circ \outputconcretization \circ \boundconcretization(
    \defbound'
  ) \subseteq \genbounded$, we have that $\dependencyconcretization(\outputconcretization(\outputsemantics)) \subseteq \genbounded$.
  Depending on the instantiation of the impact quantifier, we conclude the proof by \reflemma{outcomes-validation} for the $\outcomesname$ impact quantifier, \reflemma{range-validation} for the $\rangename$ impact quantifier, and \reflemma{qused-validation} for the $\qusedname$ impact quantifier.
\end{proof}

Finally, the next result shows that our static analysis is sound when employed to verify the property of interest $\genbounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\comparison\defbound$, then the program $\defprogram$ satisfies the property $\genbounded$, \cf{} $\defprogram \satisfies \genbounded$.

\begin{theorem}[Soundness] \labthm{soundness}
  Let $\genbounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item \label{p:first} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-12],
    \item \label{p:second} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-8.5], and
    \item \label{p:third} $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef*{sound-implementation}[*-4],
\end{enumerate}
  the following implication holds:
  \begin{align*}
    \impactinstance(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \comparison \defbound \ImplieS \defprogram \satisfies \GENBOUNDED
  \end{align*}
\end{theorem}
\begin{proof}
  From \ref{p:first}, \ref{p:second}, and \ref{p:third}, we have that:
  \begin{align*}
    \impactwrapper(\tracesemantics) \ComparisoN \impactinstance(\multisemantics\buckets, \buckets) \ComparisoN \defbound'
  \end{align*}
  From the hypothesis $\defbound' \comparison \defbound$, we obtain $\impactwrapper(\tracesemantics)\comparison \defbound$.
  By \refdef{concretization-quantitative}, we have that $\boundconcretization(\impactwrapper(\tracesemantics)) \subseteq \genbounded$.
  We conclude by \reflemma{soundness-boundconcretization}.
\end{proof}


Next,
we define $\abstractrangename$, $\abstractoutcomesname$, and $\abstractqusedname$
as possible implementations for $\rangename$, $\outcomesname$, and $\qusedname$, respectively.

%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variables $\definputvariables$, that is, the reduction in dimensionality of the abstract element by projecting its image to the reduced variable space.
\begin{example}
In the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainprojecti(\langle\definputvariable \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariable \mapsto [-\infty, +\infty], j \mapsto [2, 4] \rangle$
  removes the constraints related to the variables in $\{\definputvariable\}$.
  Often, whenever a variable maps to $\abstractdomaintop$, or equivalently in the interval domain to $[-\infty, +\infty]$, we hide it from the abstract element, \eg, instead of $\langle \definputvariable \mapsto [-\infty, +\infty], j \mapsto [2, 4] \rangle$ we often write $\langle j \mapsto [2, 4] \rangle$.
\end{example}
%
% We define the soundness condition on the project operator to ensure that $\abstractdomainproject(\defstate^\natural)$ represents all the concrete states result of perturbations on the variable $\definputvariables$ from a state represented by an abstract value $\defstate^\natural$.
We define the condition a sound projection operator $\abstractdomainproject$ must satisfy to ensure that no concrete state is missed by the projection.

The projection operator is sound whenever the projection of the variables $\definputvariables$ from the abstract value $\defstate^\natural$ contains all the concrete states that can be obtained by perturbing the variables $\definputvariables$ from a concrete state represented by $\defstate^\natural$.
In fact, we could define the \emph{concrete} project operator $\project\in\setof\state\to\setof\state$ as it follows:
\[
  \project(\defsetofstates) \DefeQ \setdef{\defstate'}{\defstate\in\defsetofstates \land \defstate \stateeq{\definputvariables} \defstate'}
\]

It follows the classic definition of soundness.
\begin{definition}[Sound Projection Operator]\labdef{soundness-project}
  For all abstract states $\defstate^\natural$, the projection of the abstract state $\abstractdomainproject(\defstate^\natural)$ is sound whenever it holds that:
  \[
    \project(\abstractdomainconcretization(\defstate^\natural)) \subseteq \abstractdomainproject(\defstate^\natural)
    \]
\end{definition}

\subsection{Abstract Implementation \texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}}[Abstract \texorpdfstring{$\abstractoutcomes$}{Outcomes}]
\labsec{abstract-outcomes}


The definition of $\abstractoutcomes$ first projects away the input variables $\definputvariables$ from all the given abstract values ($\abstractdomainproject$ in the definition below), then it collects the set of indices of abstract values resulting from the meet operation over any two resulting abstract domain elements ($\intersectallfunction$ in the definition below).
These intersections represent concrete input configurations where variations on the values of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersect after projections:
\begin{definition}[\texorpdfstring{$\abstractoutcomes$}{Abstract Outcomes}]\labdef{abstract-outcomes}
  Let $\definputvariables\in\setof\inputvariables$ be the input variables,  $\numberofbuckets\in\N$ be the number of output buckets, and $\buckets\in\vectorbuckets$ the set of output buckets.
  We define $\abstractoutcomes\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ as:
  \begin{equation*}
  \abstractoutcomes(\presfrombuckets, \buckets) \DefeQ \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\prefrombucket))_{j\le\numberofbuckets})}
  \end{equation*}
  where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$ and $\cardinalitynospaces{J}$ is the cardinality of the set of indices $J$.
\end{definition}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refdef*{outcomes}[*-5]) since the number of intersecting abstract values is finite and bounded by $n$, \cf{} the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:

\begin{definition}[\texorpdfstring{$\intersectallfunction$}{Intersect Function}]\labdef{intersect-all-function}
  Given a vector of $\numberofbuckets$ abstract elements $\presfrombuckets\in\vectorbuckets$, we define $\intersectallfunction\in\vectorbuckets\to\setof\N$ as:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction(\presfrombuckets) \DefeQ} \\
    & \setdef{J \subseteq \N}{\forall j\le n, p\le n.~ j\in J \land p\in J \LanD \prefrombucket \abstractdomainmeet \prefrombucket[p]}
  \end{eqnarray*}
\end{definition}


Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidetextcite{Bron1973}.
All together, the abstract implementation $\abstractoutcomes$ returns the value of the maximum among all the sizes of the maximum cliques for each projection.
%

\begin{example}\labexample{abstract-outcomes}
  Consider \refprog*{landing-alarm-system}[*-3] with program states defined as $\state=\setdef{\langle a, b, c, d \rangle}{a\in\{-4,1\}\land b\in\{1,2,3\}\land c\in\N \land d\in\Nle{3}}$. The output buckets represent the four levels of landing risk: low, medium-low, medium-high, and high. Using the interval domain: $\buckets \in \vectorbuckets[4]$ such that $\bucket[\textup{low}] = \langle \texttt{risk} \mapsto 0 \rangle$, $\bucket[\textup{mid\-/low}] = \langle \texttt{risk} \mapsto 1 \rangle$, $\bucket[\textup{mid\-/high}] = \langle \texttt{risk} \mapsto 2 \rangle$, and $\bucket[\textup{high}] = \langle \texttt{risk} \mapsto 3 \rangle$.
  \nrefdef{covering} is satisfied as the output buckets cover all the possible outcomes of the program for the variable \texttt{risk}.
  We assume the backward analysis to return the following intervals:
  \begin{align*}
    \backwardsemanticsnoparam(\bucket[\textup{low}]) \spacearound{&=} \prefrombucket[\textup{low}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [1, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/low}]) \spacearound{&=} \prefrombucket[\textup{mid\-/low}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [2, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/high}]) \spacearound{&=} \prefrombucket[\textup{mid\-/high}] \spacearound{=} \langle \texttt{angle} \mapsto 1, \texttt{speed} \mapsto [2, 3] \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{high}]) \spacearound{&=} \prefrombucket[\textup{high}] \spacearound{=} \langle \texttt{angle} \mapsto -4, \texttt{speed} \mapsto [1, 3] \rangle \\
  \end{align*}
  Note that, the backward analysis over-approximates the concrete semantics as, for example, the input configuration $\texttt{angle} = 1$ and $\texttt{speed} = 3$ does not lead to a low risk of approach.
  We are interested in the input variable \texttt{angle}, thus the projections are:
  \begin{align*}
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]) \spacearound{&=} \langle \texttt{speed} \mapsto [1, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{mid\-/low}]) \spacearound{&=} \langle \texttt{speed} \mapsto [2, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{mid\-/high}]) \spacearound{&=} \langle \texttt{speed} \mapsto [2, 3] \rangle \\
    \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]) \spacearound{&=} \langle \texttt{speed} \mapsto [1, 3] \rangle \\
  \end{align*}
  It is easy to see that the abstract elements resulting from the projection intersect between each other. Therefore, we obtain that the set of indices of buckets that intersect is:
  \begin{eqnarray*}
  \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]))) ={}} \\
& \setof{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}
\end{eqnarray*}
  The maximum size is $4$ at $\cardinalitynospaces{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}$.
  Therefore, $\abstractoutcomesname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 4$, meaning that variations of the input variable \texttt{angle} may lead to changes of program outcome from four different buckets.
  On the other hand, projecting away the variable \texttt{speed} from the abstract intervals results in:
  \begin{align*}
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{mid\-/low}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{mid\-/high}]) \spacearound{&=} \langle \texttt{angle} \mapsto 1 \rangle \\
    \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]) \spacearound{&=} \langle \texttt{angle} \mapsto -4 \rangle \\
  \end{align*}
  In this case, only a few abstract elements intersect, specifically:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]))) ={}} \\
  & \left\{
    \begin{array}{l}
    \{\textup{low}\}, \{\textup{mid\-/low}\}, \{\textup{mid\-/high}\}, \{\textup{high}\}, \\
    \{\textup{low}, \textup{mid\-/low}\}, \{\textup{low}, \textup{mid\-/high}\},
    \{\textup{mid\-/low}, \textup{mid\-/high}\}\\
    \{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}
    \end{array}
    \right\}
  \end{eqnarray*}
  The maximum clique is of size $3$, \cf{} \cardinalitynospaces{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}}, hence $\abstractoutcomesname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 3$. This means that variations of the input variable \texttt{speed} may lead to changes of program outcome in three different buckets.
\end{example}

In order to prove that the abstract impact $\abstractoutcomesname$ is a sound over-approximation of the concrete impact $\outcomesname$, we require the output buckets $\buckets$ to be \textit{compatible} with the output observer $\outputobs$.
That is, any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different output readings, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) $, $ \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) $, and $ \bucket \neq \bucket[p]$.
Intuitively, compatibility ensures that the counting intersecting buckets in the abstract does not miss any concrete outcome.
%
\begin{definition}[Compatibility]\labdef{compatibility}
  Given the output buckets $\buckets\in\vectorbuckets$ and the output observer $\outputobs\in\stateandbottom\to\stateandbottom$, we say that $\buckets$ is \textup{compatible} with $\outputobs$, whenever it holds:
  \[ \foralldef{\defstate_j \in \abstractdomainconcretization(\bucket), \defstate_p \in \abstractdomainconcretization(\bucket[p])}{\outputobs(\defstate_j) \neq \outputobs(\defstate_p)} \ImplieS \bucket \neq \bucket[p] \]
\end{definition}
%
Note that, $\outcomes$ is bounded by the number of buckets when the conditions of covering and compatibility hold for the output buckets.
\begin{lemma}[$\outcomes$ Upper Bound]\lablemma{outcomes-upper-bound}
  When the $\numberofbuckets$ output buckets $\buckets\in\vectorbuckets$ are compatible, \cf{} \refdef{compatibility}, and cover the subset of potential outcomes, \cf{} \refdef*{covering}, it holds that
  $\outcomes(\tracesemanticsnoparam) \le n$.
\end{lemma}
\begin{proof}
  We notice that $\outcomes(\tracesemanticsnoparam) \le \cardinalitynospaces{\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\stateandbottom}}$ as the set of outputs for the trace semantics is always bigger than any set of outputs.
  It is easy to note that the cardinality of $\setdef{\outputobs(\retrieveoutput\defstate)}{\retrieveoutput\defstate\in\stateandbottom}$ is bounded from above by $n$ since any two output states $\retrieveoutput\defstate, \retrieveoutput\defstate'$ that produce different outputs, \ie, $\outputobs(\retrieveoutput\defstate) \neq \outputobs(\retrieveoutput\defstate')$, belong to different buckets, \ie, $\retrieveoutput\defstate \in \abstractdomainconcretization(\bucket) \land \retrieveoutput\defstate' \in \abstractdomainconcretization(\bucket[p]) \land \bucket \neq \bucket[p]$ (by compatibility, \cf{} \refdef{compatibility}).
  Where the existence of the two buckets is guaranteed by covering (\cf{} \refdef{covering}).
  Therefore, there are at most $n$ different outputs.
\end{proof}

We designed $\abstractoutcomesname$ to over-approximates the concrete quantifier $\outcomesname$.
Hence, the next result shows that the abstract impact $\abstractoutcomes$ is a sound over-approximation of the concrete $\outcomes$ \wrt{} the $\le$ operator.

\refdef@{outcomes}[*-4]
\begin{lemma}[$\abstractoutcomes$ is a Sound Implementation of $\outcomes$]\lablemma{abstractoutcomes-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    % \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation},
    \item \label{proof:b2} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-3.5],
    \item \label{proof:b1} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*1], and
    \item \label{proof:d} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*5];
  \end{enumerate}
  then, $\abstractoutcomes$ is a sound implementation of $\outcomes$ \wrt{} the $\le$ operator:
  \begin{align*}
    \outcomes(\tracesemanticsnoparam) \LE \abstractoutcomes(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets)
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  We need to prove that
  \begin{gather*}
    \outcomes(\tracesemanticsnoparam) = \sup_{\definput\in\reducedstate}
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput}} \\
    \LE \\
    \abstractoutcomes(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \\
    \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}
  \end{gather*}
  Let $\overline{\definput}\in\reducedstate$ be such that:
  \begin{gather*}
    \sup_{\definput\in\reducedstate}
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput}}
    \spacearound{=} \\
    \cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}}
  \end{gather*}
  Let $\overline{J} \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})$ be such that:
  \begin{gather*}
    \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}
    \spacearound{=}
    \cardinalitynospaces{\overline{J}}
  \end{gather*}
  We need to show that $\cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}} \le \cardinalitynospaces{\overline{J}}$.
  By contradiction, we assume that $\cardinality{\setdef{\outputobs(\retrieveoutput{\deftrace})}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}} > \cardinalitynospaces{\overline{J}}$, meaning that the number of distinct output abstraction from states in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ is higher than the number of indices in the abstract. Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{dsa1} there exist output abstractions that are not matched by any output bucket,
    \item \label{dsa2} some output abstractions are matched by the same output bucket, or
    \item \label{dsa3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract.
  \end{enumerate}
  By \ref{proof:b1}, the first case \ref{dsa1} is not possible as covering, \cf{} \refdef{covering}, ensures that all the output abstractions are matched by the output buckets.
  By \ref{proof:b2}, the second case \ref{dsa2} is not possible as compatibility, \cf{} \refdef{compatibility}, ensures that any two output abstractions that produce different outputs belong to different output buckets.
  The third case \ref{dsa3} is not possible by \ref{proof:d} as the soundness of the projection operator ensures that all the concrete states result of perturbations on the variable $\definputvariables$ from a state represented by an abstract value $\defstate^\natural$ are considered in the abstract.
  Therefore, the assumption is false, and we conclude that $\abstractoutcomes$ is a sound implementation of $\outcomes$.
\end{proof}

\begin{example}
  Regarding the \refprog*{landing-alarm-system}[*-8], we show that the result of the abstract implementation $\abstractoutcomes$ in \refexample{abstract-outcomes} is a sound over-approximation of the concrete implementation $\outcomes$.
  \marginnote{
    \[
  \outputobs(\defstate) \DefeQ \left\{\begin{array}{l}
    \langle \top, \top, \top, d \rangle \\
    \qquad \text{if } \defstate = \langle a, b, c, d \rangle \\
    \langle \top, \top, \top, \top \rangle \\
    \qquad \text{otherwise}
  \end{array}\right.
  \]
  }
  We assume the output observer $\outputobs$ is defined as in \refexample{output-observer-landing}, where the fourth component of the state represents the value of the output variable \texttt{risk}.
  Indeed, the output buckets of \refexample{abstract-outcomes} are compatible with the output observer $\outputobs$ as any two output states are mapped to different output buckets.
  \marginnote{
    \begin{align*}
      \bucket[\textup{low}] \spacearound{&=} \langle \texttt{risk} \mapsto 0 \rangle \\
      \bucket[\textup{mid\-/low}] \spacearound{&=} \langle \texttt{risk} \mapsto 1 \rangle \\
      \bucket[\textup{mid\-/high}] \spacearound{&=} \langle \texttt{risk} \mapsto 2 \rangle \\
      \bucket[\textup{high}] \spacearound{&=} \langle \texttt{risk} \mapsto 3 \rangle
    \end{align*}}
  As expected by \refthm*{soundness}[*6], the bound computed by the abstract implementation $\abstractoutcomes$ is always greater or equal to the concrete one:
  \begin{align*}
    & \outcomesname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 2 \\
    &\qquad\LE \abstractoutcomesname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 4
  \end{align*}
  \begin{align*}
    & \outcomesname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 3 \\
    &\qquad\LE \abstractoutcomesname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 3 \\
  \end{align*}
  where $\landingprogram$ is the program of the landing alarm system, \cf{} \refprog{landing-alarm-system}.
\end{example}

Next, we show \nrefthm{soundness} instantiated with the abstract implementation $\abstractoutcomes$ and the comparison operator $\le$.

\begin{theorem}[Soundness of $\boundedoutcomesle$] \labthm{soundness-boundedoutcomesle}
  Let $\boundedoutcomesle$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-5], and
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-1.5],
\end{enumerate}
  the following implication holds:
  \begin{align*}
    \abstractoutcomes(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \le \defbound \ImplieS \defprogram \satisfies \BOUNDEDOUTCOMESLE
  \end{align*}
\end{theorem}
\begin{proof}
  \reflemma{abstractoutcomes-is-sound} shows that $\abstractoutcomes$ is a sound implementation of $\outcomes$, the proof follows directly by application of the \refthm{soundness} instantiated with the abstract implementation $\abstractoutcomes$ and comparison operator $\le$.
\end{proof}

\subsection{Abstract Implementation \texorpdfstring{$\abstractrange$}{Abstract Range}}[Abstract \texorpdfstring{$\abstractrange$}{Range}]
\labsec{abstract-range}

We define $\abstractrange$ as the maximum distance of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomaindistance\in\abstractdomain\to\valuesposplus$, which returns the size of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.

\begin{example}
  In the context of the interval domain, where each input variable is related to a (possibly infinite) lower and upper bound, $\abstractdomaindistance(\langle \defvariable \mapsto [2, 4]\rangle) = 2$.
  On the other hand, whenever the input abstract element is unbounded, the size is $+\infty$, \eg, $\abstractdomaindistance(\langle \defvariable \mapsto [0, +\infty]\rangle) = +\infty$.
  % The function $\abstractdomaindistance$ expects only a single variable to be constrained in the abstract domain, or in other words, only one variable is allowed to be not $\top$.
\end{example}

Let $\definputvariables$ be the set of input variables of interest and $\defoutputvariables$ be the set of output variables.
The abstract range $\abstractrange$ first projects away the input variables $\definputvariables$ from all the given abstract values (\cf{} $\abstractdomainproject$).
Then, it collects the indices of all possible intersections among the projected abstract values (\cf{} $\intersectallfunction$).
These intersections represent concrete input configurations where variations on the values of $\definputvariables$ \emph{may} lead to changes of program outcome, from a bucket to another.
All the buckets of corresponding intersections are joined together.
Thus, all but the output variables (\cf{} $\abstractdomainproject[\inputvariables \setminus \defoutputvariables]$) are projected away to find the maximum range of the extreme values of the buckets.

\siderefbox{def}{range}
\begin{definition}[\texorpdfstring{$\abstractrange$}{Abstract Range}]\labdef{abstract-range}
  Let $\definputvariables\in\setof\inputvariables$ be the input variables,  $\numberofbuckets\in\N$ be the number of output buckets, and $\buckets\in\vectorbuckets$ the set of output buckets.
  Let $\defoutputvariables$ be the output variables of interest.
We define $\abstractrange\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
\begin{align*}
\abstractrange(\presfrombuckets, \buckets) \DefeQ& \max~\seTDef{\abstractdomaindistance(\abstractdomainproject[\inputvariables \setminus \defoutputvariables](K))}{K \in I} \\
\text{where}~
I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(\prefrombucket))_{j\le\numberofbuckets})}
\end{align*}
where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$.
\end{definition}

\begin{example}\labexample{abstract-range}
  Similarly to \refexample{abstract-outcomes}, we show the computation of $\abstractrange$ for the program \refprog*{landing-alarm-system}.
  The computation of $\abstractrange$ works as for $\abstractoutcomes$ until the computation of the intersections.
  Hence, we obtain the same projections for the variable \texttt{angle}:
  \begin{align*}
    &\intersectallfunction((\abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{angle}\}}](\prefrombucket[\textup{high}]))) ={} \\
  &\quad \setof{\{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}, \textup{high}\}}
  \end{align*}
  Next, $\abstractrangename_{\{\texttt{angle}\}}$ computes the size of the output buckets joined together for any combination of bucket indices.
  The maximum is achieved whenever both the low and high buckets, respectively buckets $\bucket[\textup{low}]$ and $\bucket[\textup{high}]$, are joined together, as they yield the minimum and maximum value for the variable \texttt{risk}. The size of bucket $\bucket[\textup{low}]$ joined with $\bucket[\textup{high}]$ is $3$, \ie, $\abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{high}]) = \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 3] \rangle) = 3$.
  Therefore, $\abstractrangename_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3$.
  On the other hand, projecting away the variable \texttt{speed} from the abstract intervals results in:
  \begin{eqnarray*}
    \lefteqn{\intersectallfunction((\abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{low}]), \dots, \abstractdomainproject[{\{\texttt{speed}\}}](\prefrombucket[\textup{high}]))) ={}} \\
  & \left\{
    \begin{array}{l}
    \{\textup{low}\}, \{\textup{mid\-/low}\}, \{\textup{mid\-/high}\}, \{\textup{high}\}, \\
    \{\textup{low}, \textup{mid\-/low}\}, \{\textup{low}, \textup{mid\-/high}\},
    \{\textup{mid\-/low}, \textup{mid\-/high}\}\\
    \{\textup{low}, \textup{mid\-/low}, \textup{mid\-/high}\}
    \end{array}
    \right\}
  \end{eqnarray*}
  In this case, we obtain the following sizes for the combination of buckets:
  \begin{align*}
    \abstractdomaindistance(\bucket[\textup{low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 0 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 1 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 2 \rangle) \spacearound{=} 0 \\
    \abstractdomaindistance(\bucket[\textup{high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto 3 \rangle) \spacearound{=} 0 \\
    %
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/low}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 1] \rangle) \\ \spacearound{&=} 1 \\
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 2] \rangle) \\ \spacearound{&=} 2 \\
    \abstractdomaindistance(\bucket[\textup{mid\-/low}] \abstractdomainjoin \bucket[\textup{mid\-/high}]) \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [1, 2] \rangle) \\ \spacearound{&=} 1 \\
    \abstractdomaindistance(\bucket[\textup{low}] \abstractdomainjoin \bucket[\textup{mid\-/low}] \abstractdomainjoin \bucket[\textup{mid\-/high}])
     \spacearound{&=} \abstractdomaindistance(\langle \texttt{risk} \mapsto [0, 2] \rangle) \\ \spacearound{&=} 2
  \end{align*}
  Therefore, $\abstractrangename_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2$.
\end{example}

To prove that $\abstractrange$ is a sound implementation of $\range$, we require the classic soundness condition on the abstract operator $\abstractdomaindistance$, ensuring that the abstract distance is always greater than the concrete one.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaindistance$}{Size}]\labdef{soundness-size}
  Given an abstract value $\defstate^\natural\in\abstractdomain$ and the output variables of interest $\defoutputvariables$, it holds that:
  \[\distance(\setdef{\outputobs(\defstate)(\defoutputvariables)}{\defstate\in\abstractdomainconcretization(\defstate^\natural)}) \LE \abstractdomaindistance(\defstate^\natural)\]
\end{definition}

We designed $\abstractrangename$ to over-approximates the concrete quantifier $\rangename$.
Hence, the next result shows that the abstract impact $\abstractrangename$ is a sound over-approximation of the concrete impact $\rangename$, \cf{} \refdef*{range}[*-16.2], \wrt{} the $\le$ operator.

\refdef@{range}[*-4]
\begin{lemma}[$\abstractrange$ is a Sound Implementation of $\range$]\lablemma{abstractrange-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    % \item \label{proof:a} $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation},
    \item \label{proof:ab} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-3.5],
    \item \label{proof:ac} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*1],
    \item \label{proof:ad} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*5], and
    \item \label{proof:ae} $\abstractdomaindistance$ is sound, \cf{} \refdef*{soundness-size}[*10];
  \end{enumerate}
  then, $\abstractrange$ is a sound implementation of $\range$ \wrt{} the $\le$ operator:
  \begin{align*}
    \range(\tracesemanticsnoparam) \LE \abstractrange(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets)
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  We need to prove that
  \begin{gather*}
    \range(\tracesemanticsnoparam) = \sup_{\definput\in\reducedstate}
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariable)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput})
    \LE \\
    \abstractrange(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \max~\setdef{\abstractdomaindistance(\abstractdomainproject[\inputvariables \setminus \defoutputvariables](K))}{K \in I}
  \end{gather*}
  where $I = \setdef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})}$.
  Let $\overline{\definput}\in\reducedstate$ be such that:
  \begin{gather*}
    \sup_{\definput\in\reducedstate}
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \definput})
    \spacearound{=} \\
    \distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}})
  \end{gather*}
  Let $\overline{K} \in I$ be such that:
  \begin{gather*}
    \max~\setdef{\abstractdomaindistance(K)}{K \in I}
    \spacearound{=}
    \abstractdomaindistance(\overline{K})
  \end{gather*}
  where $\overline{K} = \abstractdomainjoin\seTDef{\bucket}{j\in J}$ and $J \in \intersectallfunction((\abstractdomainproject(\backwardconcretization(\backwardsemanticsnoparam)\bucket))_{j\le\numberofbuckets})$.
  We need to show that $\distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}) \le \abstractdomaindistance(\overline{K})$.
  By contradiction, we assume that $\distance(\setdef{\outputobs(\retrieveoutput{\deftrace})(\defoutputvariables)}{\deftrace\in\tracesemanticsnoparam\land\retrieveinput{\deftrace} \stateeq{\inputvariableswithoutw} \overline{\definput}}) > \abstractdomaindistance(\overline{K})$, meaning that the size of output abstraction over the variable $\defoutputvariables$ from states in $\tracesemanticsnoparam$ is higher than the size of $\overline{K}$ in the abstract. Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{au1} there exist output abstractions that are not matched by any output bucket,
    \item \label{au2} some output abstractions are matched by the same output bucket,
    \item \label{au3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract, or
    \item \label{au4} the size of the abstract element is not greater than the size of the output abstraction.
  \end{enumerate}
  Similarly to the proof of \reflemma{abstractoutcomes-is-sound}, we can show that the first three cases are not possible by \ref{proof:ab}, \ref{proof:ac}, and \ref{proof:ad}.
  The fourth case \ref{au4} is not possible by \ref{proof:ae} as the soundness of the size operator ensures that the size of the abstract element is always greater than the size of the output abstraction.
  Therefore, the assumption is false, and we conclude that $\abstractrange$ is a sound implementation of $\range$.
\end{proof}

\begin{example}
  Let \texttt{risk} be the output variable of interest.
  Regarding the program \refprog*{landing-alarm-system}[*-3], we show that the quantities computed by the abstract implementation $\abstractrange$ in \refexample{abstract-range} are sound over-approximations of the concrete implementation $\range$.
  \begin{align*}
    & \rangename_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\textup{landing-alarm-system}}) = 3 \\
    &\qquad\LE \abstractrangename_{\{\texttt{angle}\}}(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = 3
  \end{align*}
  \begin{align*}
    & \rangename_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\textup{landing-alarm-system}}) = 2 \\
    &\qquad\LE \abstractrangename_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2
  \end{align*}
  as expected by \refthm*{soundness}[*-4].
\end{example}

Next, we show \nrefthm{soundness} instantiated with the abstract implementation $\abstractrange$ and the comparison operator $\le$.

\begin{theorem}[Soundness of $\boundedrangele$] \labthm{soundness-boundedrangele}
  Let $\boundedrangele$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-5], and
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-1.5],
\end{enumerate}
  the following implication holds:
  \begin{align*}
    \abstractrange(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \le \defbound \ImplieS \defprogram \satisfies \BOUNDEDRANGELE
  \end{align*}
\end{theorem}
\begin{proof}
  \reflemma{abstractrange-is-sound} shows that $\abstractrange$ is a sound implementation of $\range$, the proof follows directly by application of the \refthm{soundness} instantiated with the abstract implementation $\abstractrange$ and comparison operator $\le$.
\end{proof}

\subsection{Abstract Implementation \texorpdfstring{$\abstractqused$}{Abstract QUsed}}[Abstract \texorpdfstring{$\abstractqused$}{QUsed}]
\labsec{abstract-qused}

We define $\abstractqused$ as the number of input values that are missing from perturbation to the input variables $\definputvariables$ to reach the same outcomes. We assume the abstract domain $\abstractdomain$ is equipped with an abstract counting operator $\abstractdomaincount\in\abstractdomain\to\valuesposplus$ that returns the number of possible values of the given abstract element, \eg, $\abstractdomaincount(\langle \defvariable \mapsto \{2, 3, 4\}\rangle) = 3$.
As well as an abstract complement operator $\abstractdomaincomplement_{\defabstractvalue}\in\abstractdomain\to\abstractdomain$ that returns the complement of the given abstract element \wrt{} $\defabstractvalue$, which we assume to represent the whole space.
For example, $\abstractdomaincomplement_{\langle \defvariable \mapsto \{0, 1, 2, 3\}\rangle}(\langle \defvariable \mapsto \{2, 3\}\rangle) = \langle \defvariable \mapsto \{0, 1\} \rangle$.
In general, we use top ($\abstractdomaintop$) for the abstract element representing the whole space.
This operator is useful to count missing states as those can be obtained as result from the complement of the states we do have.

Specifically, $\abstractqused$ first computes the number (\cf{} $\abstractdomaincount$) of input values of the variable in $\definputvariables$ (\cf{} $\abstractdomainprojectothers$) that are missing (\cf{} $\abstractdomaincomplement_\abstractdomaintop$) coming from the same output bucket.
These values represent missing partial input configurations that the concrete impact quantifier $\qused$ may count.
To compute the number of missing (total) input configurations, we multiply the number of missing input values for the number of possible values of the other input variables (\cf{} $\prod_{\defvariable\in \definputvariables} l_{\defvariable}$).
This number of possible values of the other input variables is computed by projecting away all the variables but one from the abstract element (\cf{} $\abstractdomainproject[\inputvariables \setminus \{\defvariable\}]$) and then applying the abstract counting operator $\abstractdomaincount$ from the whole input space $\abstractdomaintop\in\abstractdomain$.
The result is a measure of the influence of the input variables on the output of the program, \ie, the number of input configurations that \emph{may} lead to different outcomes.
\marginnote{
  The symbol $\abstractdomaintop$ refers to ``top,'' \ie, the abstract element representing the whole space.
}
\begin{definition}[\texorpdfstring{$\abstractqused$}{Abstract QUsed}]\labdef{abstract-qused}
  Let $\definputvariables\in\setof\inputvariables$ be the input variables,  $\numberofbuckets\in\N$ be the number of output buckets, and $\buckets\in\vectorbuckets$ the set of output buckets.
  We define $\abstractqused\in\pair\vectorbuckets\vectorbuckets\to\valuesposplus$ as:
  \begin{align*}
    \abstractqused(\presfrombuckets, \buckets) \DefeQ& \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaincomplement_\abstractdomaintop(\prefrombucket))) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{align*}
  where $\presfrombuckets\in\vectorbuckets$ is the result of the abstract semantics $\multisemanticsnoparam$ and $l$ is the total number of input values a variable takes:
  \begin{align*}
    l_{\defvariable} \DefeQ& \abstractdomaincount(\abstractdomainproject[\inputvariables \setminus \{\defvariable\}](\abstractdomaintop))
  \end{align*}
\end{definition}

\begin{example}\labexample{abstract-qused}
  We show the computation of $\abstractqused$ for the program \refprog*{landing-alarm-system}.
  For the sake of the example, we consider as abstract domain the set of values for each variable, otherwise with the use of interval abstract domain, the result would be too imprecise.
  The backward analysis returns the following set of values:
  \begin{align*}
    \backwardsemanticsnoparam(\bucket[\textup{low}]) \spacearound{&=} \prefrombucket[\textup{low}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/low}]) \spacearound{&=} \prefrombucket[\textup{mid\-/low}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{mid\-/high}]) \spacearound{&=} \prefrombucket[\textup{mid\-/high}] \spacearound{=} \langle \texttt{angle} \mapsto \{1\}, \texttt{speed} \mapsto \{2, 3\} \rangle \\
    \backwardsemanticsnoparam(\bucket[\textup{high}]) \spacearound{&=} \prefrombucket[\textup{high}] \spacearound{=} \langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle
  \end{align*}
  We are interested in the impact of the input variable \texttt{angle}, hence we project away the other variables from the complement of the given abstract intervals, obtaining:
  \begin{align*}
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{low}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \emptyset\rangle) \spacearound{=}\abstractdomainbottom \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{mid\-/low}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{angle} \mapsto \{-4\} \rangle \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{mid\-/high}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{angle} \mapsto \{-4\} \rangle \\
    &\abstractdomainproject[{\{\texttt{speed}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{high}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{speed}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{high}]) \spacearound{=} \abstractdomainbottom
  \end{align*}
  Then, $\abstractqusedname_{\{\texttt{angle}\}}$ counts the number of input configurations:
  \begin{align*}
    \abstractdomaincount(\abstractdomainbottom) \spacearound{&=} 0 \\
    \abstractdomaincount(\langle \texttt{angle} \mapsto \{-4\} \rangle) \spacearound{&=} 1
  \end{align*}
  This value has to be multiplied by the number of possible values for the other input variable \texttt{speed}, which is $3$.
  The total number of missing input configurations is $3$ for the variable \texttt{angle}, hence $\abstractqusedname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3$.
  On the other hand, when interested in the variable \texttt{speed} we project away the variable \texttt{angle} from the abstract intervals, obtaining:
  \begin{align*}
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{low}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \emptyset\rangle) \spacearound{=}\abstractdomainbottom \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{mid\-/low}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/low}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{speed} \mapsto \{1\} \rangle \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{mid\-/high}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{mid\-/high}]) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4\}, \texttt{speed} \mapsto \{1\}\rangle) \\
    &\quad\spacearound{=} \langle \texttt{speed} \mapsto \{1\} \rangle \\
    &\abstractdomainproject[{\{\texttt{angle}\}}](\abstractdomaincomplement_\abstractdomaintop(\prefrombucket[\textup{high}])) \\
    &\quad\spacearound{=} \abstractdomainproject[{\{\texttt{angle}\}}](\langle \texttt{angle} \mapsto \{-4, 1\}, \texttt{speed} \mapsto \{1, 2, 3\} \rangle \setminus \prefrombucket[\textup{high}]) \spacearound{=} \abstractdomainbottom
  \end{align*}
  Then, $\abstractqusedname_{\{\texttt{speed}\}}$ counts the number of input configurations:
  \begin{align*}
    \abstractdomaincount(\abstractdomainbottom) \spacearound{&=} 0 \\
    \abstractdomaincount(\langle \texttt{speed} \mapsto \{1\} \rangle) \spacearound{&=} 1 \\
  \end{align*}
  As before, we multiply such value by the number of possible values for the other input variable \texttt{angle}, \cf{} 2.
  The total number of missing input configurations is then $2$ for the variable \texttt{speed}, hence $\abstractqusedname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2$.
\end{example}

To prove that $\abstractqused$ is a sound implementation of $\qused$, we require the soundness condition on the abstract operators $\abstractdomaincount$ and $\abstractdomaincomplement$, ensuring that the abstract count of the complement of an abstract element is always lower than the concrete one.
%
Note that, the concrete counterpart of the abstract $\abstractdomaincount$ is the cardinality operator $\cardinalitynospaces{\cdot}$.

\begin{definition}[Soundness of \texorpdfstring{$\abstractdomaincount$}{Count}]\labdef{soundness-count}
  Given an abstract value $\defstate^\natural\in\abstractdomain$ and the set of input variables of interest $\definputvariables\in\setof\inputvariables$, it holds that:
  \[\cardinality{\setdef{\retrieveinput{\defstate}(\definputvariables)}{\defstate\in\state \land \defstate \notin \abstractdomainconcretization(\defstate^\natural)}} \GE \abstractdomaincount(\abstractdomaincomplement_\abstractdomaintop(\defstate^\natural)) \]
\end{definition}

We designed $\abstractqused$ to under-approximate the concrete quantifier $\qusedname$.
Hence, the next result shows that the abstract impact $\abstractqusedname$ is a sound over-approximation of the concrete impact $\qusedname$, \cf{} \refdef*{qused}[*-9] \wrt{} the $\ge$ operator.

\begin{lemma}[$\abstractqused$ is a Sound Implementation of $\qused$]\lablemma{abstractqused-is-sound}
  Let $\definputvariables\in\setof\inputvariables$ be the input variable of interest, $\abstractdomain$ the abstract domain, $\backwardsemanticsnoparam$ the family of semantics, and $\buckets\in\vectorbuckets$ the starting output buckets.
  Whenever the following conditions hold:
  \begin{enumerate}[label=(\roman*)]
    \item \label{pp1} $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-2.5],
    \item \label{pp2} $\buckets$ is compatible with $\outputobs$, \cf{} \refdef*{compatibility}[*2],
    \item \label{pp3} $\abstractdomainproject[]$ is sound, \cf{} \refdef*{soundness-project}[*6], and
    \item \label{pp4} $\abstractdomaincount$ is sound, \cf{} \refdef*{soundness-count}[*10.8];
  \end{enumerate}
  then, $\abstractqused$ is a sound implementation of $\qused$ \wrt{} the $\ge$ operator:
  \begin{align*}
    \qused(\tracesemanticsnoparam) \GE \abstractqused(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets)
  \end{align*}
\end{lemma}
\begin{proof}[Proof (Sketch)]
  We need to prove that
    \begin{gather*}
      \qused(\tracesemanticsnoparam) \DefeQ
      \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      } \\
    \GE \\
    \abstractqused(\multiconcretization(\multisemanticsnoparam)\buckets, \buckets) = \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaincomplement_\abstractdomaintop(\prefrombucket))) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{gather*}
  Let $\overline{\defseq}\in\tracesemanticsnoparam$ be such that:
  \begin{gather*}
    \sup_{\deftrace \in \defsetoftraces}
    \cardinality{
        Q_\definputvariables(I_\deftrace(\defsetoftraces)) \setminus I_\deftrace(\defsetoftraces)
      }
    \spacearound{=} \\
    \cardinality{
        Q_\definputvariables(I_{\overline{\deftrace}}(\defsetoftraces)) \setminus I_{\overline{\deftrace}}(\defsetoftraces)
      }
  \end{gather*}
  Let $\overline{j} \le \numberofbuckets$ be such that:
  \begin{gather*}
    \max_{j \le \numberofbuckets}\spacer
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaincomplement_\abstractdomaintop(\prefrombucket))) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
    \spacearound{=} \\
    \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaincomplement_\abstractdomaintop(\prefrombucket)[\overline{j}])) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}
  \end{gather*}
  By contradiction, we assume that \[\cardinality{
    Q_\definputvariables(I_{\overline{\deftrace}}(\defsetoftraces)) \setminus I_{\overline{\deftrace}}(\defsetoftraces)
  } < \abstractdomaincount(\abstractdomainprojectothers(\abstractdomaincomplement_\abstractdomaintop(\prefrombucket)[\overline{j}])) \cdot \prod_{\defvariable\in \definputvariables} l_{\defvariable}\] meaning that the number of missing input configurations is lower than the number of missing input values for the variable $\definputvariables$ coming from the same output bucket.
  Hence, either:
  \begin{enumerate}[label=(\alph*)]
    \item \label{qq1} there exist output abstractions that are not matched by any output bucket,
    \item \label{qq2} some output abstractions are matched by the same output bucket,
    \item \label{qq3} there are output abstractions in $\tracesemanticsnoparam$ from perturbation of the input $\retrieveinput\defstate$ that are not considered in the abstract, or
    \item \label{qq4} counting the number of input configurations in the abstract is not greater than the number of input configurations in the concrete.
  \end{enumerate}
  Again, we can show that the first three cases are not possible by hypothesis \ref{pp1}, \ref{pp2}, and \ref{pp3}. By hypothesis \ref{pp4}, the soundness of the count operator ensures that the number of input configurations in the abstract is always greater than the number of input configurations in the concrete. Therefore, the assumption is false, and we conclude that $\abstractqused$ is a sound implementation of $\qused$.
\end{proof}


\begin{example}
  Regarding the program \refprog*{landing-alarm-system}, we show that the quantities computed by the abstract implementation $\abstractqused$ in \refexample{abstract-qused} are sound over-approximations of the concrete implementation $\qused$:
  \begin{align*}
    & \qusedname_{\{\texttt{angle}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 3 \\
    &\qquad\GE \abstractqusedname_{\{\texttt{angle}\}}(\presfrombuckets, \buckets) = 3
  \end{align*}
  \begin{align*}
    & \qusedname_{\{\texttt{speed}\}}(\tracesemanticsnoparam\semanticsof{\landingprogram}) = 2 \\
    &\qquad\GE \abstractqusedname_{\{\texttt{speed}\}}(\presfrombuckets, \buckets) = 2
  \end{align*}
  as expected by \refthm*{soundness}, where $\landingprogram$ is the program of the landing alarm system, \cf{} \refprog{landing-alarm-system}.
  In this case, the bound computed in the abstract is the same as the concrete one, as the abstract domain is precise enough to capture the exact number of missing input configurations.
\end{example}


Next, we show \nrefthm{soundness} instantiated with the abstract implementation $\abstractqused$ and the comparison operator $\ge$.

\begin{theorem}[Soundness of $\boundedqusedge$] \labthm{soundness-boundedqusedge}
  Let $\boundedqusedge$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\outputsemanticsnoparam$, \cf{} \refdef*{sound-over-approximation}[*-5], and
    \item $\buckets$ covers the subset of potential outcomes, \cf{} \refdef*{covering}[*-1.5],
\end{enumerate}
  the following implication holds:
  \begin{align*}
    \abstractqused(\multisemantics\buckets, \buckets) = \defbound' \land \defbound' \ge \defbound \ImplieS \defprogram \satisfies \BOUNDEDQUSEDGE
  \end{align*}
\end{theorem}
\begin{proof}
  \reflemma{abstractqused-is-sound} shows that $\abstractqused$ is a sound implementation of $\qused$, the proof follows directly by application of the \refthm{soundness} instantiated with the abstract implementation $\abstractqused$ and comparison operator $\le$.
\end{proof}

Interestingly, the abstract implementation $\abstractqused$ under-approximates the \emph{used} variables, whereas the syntactic dependency analysis $\synsemanticsnoparam$ (\cf{} \refsec{syntactic-dependency-analysis}) under-approximates the \emph{unused} variables.
Let us define the syntactic dependency analysis as an abstract implementation:
\begin{align*}
\synunused(\defprogram) \DefeQ \begin{cases}
  \true &\text{if } \forall \definputvariable\in\definputvariables.\spacer \synsemanticsnoparam\semanticsof{\defprogram}(\definputvariable) \in \{ \unusedtag, \overwrittentag \} \\
  \false &\text{otherwise}
\end{cases}
\end{align*}
returning $\true$ if the syntactic dependency analysis $\synsemanticsnoparam$ found that all the input variables $\definputvariables$ are unused, \ie, unused ($\unusedtag$) or overwritten ($\overwrittentag$), in the program $\defprogram$.
It holds that, whenever $\abstractqused = 0$ we cannot conclude anything about $\synunused$. Respectively, whenever $\synunused$ does not hold we cannot conclude anything about $\abstractqused$.
However, it holds that:
\begin{align*}
  \abstractqused \neq 0 &\ImplieS \neg\synunused \\
  \synunused &\ImplieS \abstractqused = 0
\end{align*}
In words, whenever the abstract implementation $\abstractqused$ returns a strictly positive quantity, it means that the input variables $\definputvariables$ are definitely used in the program $\defprogram$, and thus also syntactically used.\sidenote{Note the double negation in the predicate $\neg\synunusedname$: being not syntactically unused is equivalent to be syntactically used} Whenever the syntactic dependency analysis $\synunused$ holds, it means that the input variables $\definputvariables$ are definitely not used in the program $\defprogram$, and thus also not used in the abstract implementation $\abstractqused$.

\section{Related Work}
\labsec{nfm24-related-work}


This chapter draws inspiration from \sidetextcite{Barowy2014}, where an empirical analysis explores the use of data for debugging spreadsheet applications through stochastic sampling.
\sidetextcite{Urban2018} proposed a unified view of existing information flow analyses based on abstract interpretation, establishing the theoretical foundations for understanding the use of input variables.
Our approach introduces a novel quantitative perspective on input data usage.
In this section, we compare our work with the existing literature, including non-interference, a foundational property for information flow analysis, entropy measures of quantitative information flow, and probabilistic programming languages.

\newcommand*{\entropypartitions}[1][\defprogram]{\Pi(#1)}
\newcommand*{\exampleinput}{\textsc{Input}_\defprogram}

\paragraph{Abstract Non-Interference.}

Quantitative input data usage, which evolves from its qualitative counterpart, is inspired by work on abstract non-interference \sidecite{Giacobazzi2018}.
Notably, \sidetextcite{Giacobazzi2004} introduced a domain-theoretic characterization of the most precise attacker who cannot violate abstract non-interference.
Later, \sidetextcite{Mastroeni2013} instantiated various policies, leading to different notions of abstract non-interference for language-based security.
This work paved the way for the development of a unifying framework that weakens the non-interference property into abstract non-interference \cite{Giacobazzi2018}.
More recently, \sidetextcite{Mastroeni2023} explored the connection between domain completeness and narrow abstract non-interference, where domain transformers can be characterized using monotonicity within the weak framework of abstract interpretation.
From abstract non-interference, our work adopts the concept of state abstractions, \cf{} \nrefdef{output-observer}.

\paragraph{Quantitative Information Flow.}
Given the connection between \emph{qualitative} input usage and information flow analysis \sidecite[][{Chapters 8, 9, and 10}]{Urban2018}, to design a quantitative input usage analysis that fits our purposes, it may come natural to look into \emph{quantitative} information flow, formerly introduced by \sidetextcite{Denning1982,Gray1991}.
Such analyses measure information leakage about a secret through the concept of entropy, based on observations of the program's output values.
Remarkably, this similarity between entropy and our notion of impact is even more evident
in the work proposed by \sidetextcite{K_opf2013} which quantifies an upper bound of the entropy of a program's input variables by computing an over-approximation of the set of input-output observations, sometimes called equivalence classes. They employ Shannon entropy, min-entropy, and other entropies through the enumeration of these equivalence classes and their respective sizes. The equivalence classes are partitions of the input space in which two input assignments belong to the same class whenever the program produces an equivalent output.
For example, the equivalence classes of the \refprog*{landing-alarm-system}, referred to as program $\landingprogram$, are $\entropypartitions[\landingprogram]=\setdef{\setdef{\tuple{x}{y}}{\landingprogram(x, y)=\defoutput}}{\defoutput\in\{0, 1, 2, 3\}}
=\{\{\tuple{1}{1}\}, \{\tuple{1}{2}\}, \{\tuple{1}{3}\}, \{\tuple{-4}{1}, \tuple{-4}{2}, \tuple{-4}{3}\}\}$.
Next, we show how our impact quantifiers arose from the adaptation of entropy measures to our needs in three successive attempts.

\newcommand{\shannonentropy}{H}
\newcommand{\probability}{E_\defprogram}
Initially, we notice that Shannon-entropy computes the average uncertainty of input values based on observations of the program's outcomes, while min-entropy, defined as:
\newcommand{\minentropy}{{H_\infty}}
\begin{align}
  \labeq{min-entropy}
  \minentropy(\defprogram) \DefeQ
  \log_2 \frac{\cardinalitynospaces{\exampleinput}}{\cardinalitynospaces{\entropypartitions}}
\end{align}
computes the worst-case uncertainty,
where $\exampleinput$ is the set of all input values of a given program \defprogram.
As a first attempt, we consider min-entropy as closer to our needs since our aim is to discover the worst-case impact, \ie, the case in which a variable contributes the most.
By computing min-entropy on the program \landingprogram, we obtain $\minentropy(\landingprogram)=0.58$, indicating that the input is highly guessable.
Indeed, when the risk level is 3, the potential values of input variables are ${\texttt{angle}}=-4$ and ${\texttt{speed}}\in{1, 2, 3}$; for all other output values, the input values are completely determined.
Unfortunately, min-entropy lacks granularity and measures the uncertainty of the input variables collectively. Instead, our aim is to quantify the individual contributions.

To address the previous issue, as a second attempt we exploit low and high labels for input variables, where the former are considered as public, available to the attacker, and the latter as secret \sidecite{K_opf2010}.
To assess the impact of each input variable, we prioritize one high variable at a time, considering all others as low variables.
Subsequently, we compute the min-entropy of the labelled program to quantify the extent of the impact.
We define $\landingprogram^{\texttt{angle}}(x)\defeq \langle\landingprogram(x, 1), \landingprogram(x, 2), \landingprogram(x, 3)\rangle$ which represents the sequence of programs where ${\texttt{angle}}$ is high and ${\texttt{speed}}$ is low.
Similarly, $\landingprogram^{\texttt{speed}}(y)\defeq\langle\landingprogram(-4, y), \landingprogram(1, y)\rangle$ where ${\texttt{speed}}$ is high and ${\texttt{angle}}$ is low.
Computing $\minentropy(\landingprogram^{\texttt{angle}})$ and $\minentropy(\landingprogram^{\texttt{speed}})$ yields 0 on both because all equivalence classes consist of singletons, meaning the number of inputs equals the number of outputs. Thus, there's no uncertainty in the value of ${\texttt{angle}}$ given outputs of $\landingprogram^{\texttt{angle}}$, or in the value of ${\texttt{speed}}$ given outputs of $\landingprogram^{\texttt{speed}}$.
Indeed, observing the output $\langle 3, 3, 3\rangle$ from the program $\landingprogram^{\texttt{angle}}$ implies that ${\texttt{angle}}$ is $-4$, while observing $\langle 0, 1, 2 \rangle$ implies that ${\texttt{angle}}$ is $1$. The same applies to $\landingprogram^{\texttt{speed}}$ where observing $\langle 3, 0 \rangle$ implies ${\texttt{speed}}=1$, $\langle 3, 1\rangle$ implies ${\texttt{speed}}=2$, and $\langle 3, 2\rangle$ implies ${\texttt{speed}}=3$.
However, this approach does not isolate the contributions of high variables; these outcomes are combined into a tuple of values through the return statement and thus evaluated together. Consequently, min-entropy cannot distinguish the contribution of each input variable independently.

\newcommand{\outcomesentropy}{{H_\textsc{O}}}
An immediate solution is to develop a similar approach to the one used for the high-low variables, but instead of using min-entropy for the derived programs ($\landingprogram^{\texttt{angle}}$ and $\landingprogram^{\texttt{speed}}$), we count the number of outcomes of the partially-applied programs, \cf{} programs
$\landingprogram(x, 1), \landingprogram(x, 2),$ and $\landingprogram(x, 3)$ for $\landingprogram^{\texttt{angle}}$; $\landingprogram(-4, y)$ and $\landingprogram(1, y)$ for $\landingprogram^{\texttt{speed}}$.
These programs are referred to as $\landingprogram^{\texttt{angle}}_y$ and $\landingprogram^{\texttt{speed}}_x$ respectively.
Therefore, the third attempt defines $\outcomesentropy(\landingprogram^{\texttt{angle}})\DefeQ \max \setdef{ \cardinalitynospaces{\entropypartitions[\landingprogram^{\texttt{angle}}_y]}}{y\in\{1, 2, 3\}}$ and $\outcomesentropy(\landingprogram^{\texttt{speed}})\DefeQ \max \setdef{\cardinalitynospaces{\entropypartitions[\landingprogram^{\texttt{speed}}_x]}}{x\in\{-4, 1\}}$ retaining the maximum to obtain the worst-case scenario.
As a result, $\outcomesentropy(\landingprogram^{\texttt{angle}})=2$ and $\outcomesentropy(\landingprogram^{\texttt{speed}})=3$. This means that variations of the value of ${\texttt{angle}}$ result in at most 2 different outputs, while variations of the value of ${\texttt{speed}}$ result in at most 3.
Effectively, this is the first notion of impact derived from min-entropy capable of discriminating the contribution of each input variable on the program computation, exploiting the number of reachable outcomes from variations of the value of the input variable under consideration.
Indeed, $\outcomesentropy(\defprogram^\definputvariables)=\outcomes(\defprogram)$ holds for a generic program $\defprogram$.

Overall, entropy measures and the approach proposed by \sidetextcite{K_opf2013,K_opf2010} can be adapted to our needs. Nevertheless, their analysis grows exponentially with the number of low variables, which in our adaptation corresponds to the number of inputs, minus one. To address this limitation, we leverage an over-approximation of input-output observations of the program, focusing solely on the low variables. By doing so, we obtain the set of input configurations that lead to the same output value by variation on the value of high variables.
As a result, our approach performs the backward analysis only one time per output bucket, independently of the number of low variables.
A similar technique could also be used to mitigate such explosion in their work.

In quantitative information flow, other notable works include \sidetextcite{Chothia2014}, who proposed a statistical approach to quantify information leakage in Java programs.
\sidetextcite{Phan2012,Phan2014,Saha2023} employed symbolic execution techniques and model counting to obtain sound bounds on program entropy.
Other static analyses, such as those by \sidetextcite{Assaf2017} and \sidetextcite{Clark2007}, are based on abstract interpretation.
\sidetextcite{Girol2024} introduced a quantitative version of non-exploitability called robust reachability, measuring the difficulty of triggering bugs via symbolic execution and model counting.

The key difference between our framework and existing work lies in the type of information we measure.
Our analysis quantifies the effect of each input variable on the program's outcome, focusing on numerical properties.
In contrast, quantitative information flow typically measures the amount of information (in bits) transferred from input variables to the program's outcome, a metric more relevant to security properties.
For example, \sidetextcite{Assaf2017} counts how many bits of input information are used to compute the result; \sidetextcite{Smith2009} calculates the probability of guessing a private variable's value from input variables; and \sidetextcite{McCamant2008} retrieves the channel capacity, which represents the worst-case potential for information leakage.
Most of these approaches are based on entropy measures, which are orthogonal to our approach.
Recent developments include \sidetextcite{Zhang2022}, who developed a calculus based on the strongest-postcondition style for quantitative reasoning about information flow, and \sidetextcite{Henzinger2023}, who generalized the hierarchy of safety and liveness properties to quantitative safety and liveness.
Our framework, inspired by the qualitative input data usage property, diverges in that it assesses the numerical impact of input variables on program outcomes, distinguishing it from traditional information flow approaches that focus on counting bits or probabilities.

Qualitative input data usage and non-interference also relate to \textit{Data Leakage} \sidecite[][Chapter~4]{Brownlee2020}.
This concept is particularly relevant to data science software, addressing leakage issues that arise from the training and test datasets during the process of training neural networks.
A series of papers by \sidetextcite{Drobnjakovic2024,Subotic2022a,Subotic2022b} focus on verifying data leakage within code notebooks and external libraries such as NumPy or pandas, presenting new challenges in formal verification.
An adaptation of their work could potentially encompass a notion of quantitative data leakage, which would be a valuable direction for further research.

\paragraph{Hyperproperties.}

\sidetextcite{Clarkson2010} defined properties of program semantics as``hyperproperties.''
Hyperproperties relate different sets of program executions and can express security policies or input data usage properties, as discussed in this thesis.
\textcite{Clarkson2010} categorized hyperproperties into safety and liveness, respectively termed hypersafety and hyperliveness.
The $k$-hypersafety properties are those that require sets of $k$ traces to be disproved, a category verifiable with traditional safety property techniques by $k$-times self-composition \sidecite{Barthe2011,Terauchi2005}.
Note, however, that direct approaches using self-composition can be computationally expensive \sidecite{Antonopoulos2017}.
In our work, we avoid categorizing program properties as hyperproperties because a different abstract interpretation theory is not needed to verify them \sidecite{Cousot2019},
the classical approach \sidecite{Cousot1977} is sufficient.
However, it is worth noting that the $\defbound$-bounded impact property is a hyperproperty.
More specifically, when applied to the \rangename{} quantifier, $\boundedrange$ is a 2-hypersafety property, as it requires 2 traces to be disproved, \ie, two traces yielding extreme values for the output variable.
Conversely, when applied to the \outcomesname{} quantifier, $\boundedoutcomes$ is a $(k+1)$-hypersafety property, as it requires $k+1$ traces to be disproved, \ie, where the $k+1$ trace all yield a different output value.


\paragraph{Probabilistic Programming.}
Quantitative analyses are typically closely associated with probabilistic programming.
Probabilistic programs \sidecite{Gordon2014, Meent2018} are conventional imperative (or functional) programs with additional constructs to model random variables and probabilistic choices.
The problem of computing an explicit representation of the probability distribution specified by a probabilistic program is known as probabilistic inference, with probabilistic programming aiming to decouple modeling from inference.
Recent advances in verifying probabilistic programs have been significant.
Martingale theory certificates have played a crucial role in automating the proof of quantitative termination and safety in probabilistic programs \sidecite{Chatterjee2017,Chatterjee2022,Takisaka2021,Wang2024}.
Probabilistic programs have also been studied in the context of cost analyses \sidecite{Chatterjee2024,Wang2021a}.
Other approaches involve the weakest pre-expectation calculus \sidecite{Kaminski2016}, a probabilistic extension of the classical weakest precondition calculus.
Symbolic execution techniques have been adapted for probabilistic programs, enabling a detailed exploration of program paths under various stochastic scenarios \sidecite{Sankaranarayanan2013,Beutner2022}.
In our work, we assume non-determinism is uniformly distributed, which simplifies the settings.
However, by applying probabilistic semantics \sidecite{Cousot2012a}, we could extend our quantifiers to probabilistic measures, providing statistical bounds on the impact of input variables on the probabilistic program's output.


\section{Summary}
\labsec{quantitative-input-data-usage-summary}

In this chapter, we introduced the quantifiers $\outcomes$, $\range$, and $\qused$ to measure the impact of input variables on the output of a program.
We developed a theoretical framework to verify the $\defbound$-bounded impact property of a program and showed the abstract version of the quantifiers.
In the next chapter, we present the evaluation of the quantifiers on a set of use cases.
Later, we will show how we handle the quantification of the impact of input variables in the context of neural network models.


\frenchdiv

\emph{Dans ce chapitre, nous avons introduit les mesures quantitatives $\outcomes$, $\range$ et $\qused$ pour quantifier l'impact des variables d'entrée sur la sortie d'un programme. Nous avons développé un cadre théorique pour vérifier la propriété d'impact bornée par $\defbound$ d'un programme et montré la version abstraite des mesures quantitatives. Dans le prochain chapitre, nous présenterons l'évaluation des mesures quantitatives sur un ensemble de scénarios. Plus tard, nous montrerons comment nous gérons la quantification de l'impact des variables d'entrée dans le contexte des modèles de réseaux neuronaux.}
