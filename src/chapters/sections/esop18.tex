\chapter{Input Data Usage}
\labch{input-data-usage}


In this chapter, we introduce the notion of input data usage as proposed by \textcite{Urban2018}.
In particular, we include output abstractions in the definition of an unused input variable, obtaining a more general definition.
Then, we present a \emph{sound and complete} hierarchy of semantics that contains only, and exactly, the information needed to reason about the usage of input variables.
Later in the next chapters, we will define a quantitative measure of usage of input variables, extending the qualitative notion presented in this chapter.

\emph{Dans ce chapitre, nous introduisons la notion d'utilisation des données d'entrée comme proposé par \sidetextcite{Urban2018}. En particulier, nous incluons des abstractions de sortie dans la définition d'une variable d'entrée inutilisée, obtenant ainsi une définition plus générale. Ensuite, nous présentons une hiérarchie \emph{correcte et complète} de sémantiques qui contiennent uniquement et exactement les informations nécessaires pour raisonner sur l'utilisation des variables d'entrée. Plus tard, dans les chapitres suivants, nous définirons une mesure quantitative de l'utilisation des variables d'entrée, en étendant la notion qualitative présentée dans ce chapitre.}

\section{Input Data Usage}
\labsec{input-data-usage}

\marginnote{
  The set $\inputvariables$ contains all the input variables of the program $\defprogram$, \cf{} \refsec{syntax}.
}
\marginnote[*2]{Given a program $\defprogram$, its semantics is defined by the trace semantics $\tracesemantics\in\tracetype$, that is, the set of finite and infinite traces of the program $\defprogram$, \cf{} \refsec{maximal-trace-semantics}.}
Originally introduced by \textcite{Urban2018}, the notion of input data usage consists in the predicate $\unusedwrapper$ to determine whether the input variables $\definputvariables\in\setof\inputvariables$ are used in the computation of the program's output. The predicate
\[
  \unusedwrapper \in \tracetype \to \B
\]
holds whenever all the input variables in $\definputvariables$ are not used by the program under evaluation.

\marginnote{
  Let $\deftrace\in\finiteinfinitesequences$ be a trace, $\retrieveinput{\deftrace}\in\state$ refers to the initial state and $\retrieveoutput{\deftrace}\in\stateandbottom$ to the final one if $\deftrace$ is of finite length, otherwise $\statebottom$ for non-terminating traces.
}
\marginnote{
  Given a set of variables $\definputvariables\in\setof\inputvariables$, the notation $\retrieveinput{\deftrace}(\definputvariables)\in\valuesofvariables$ refers to the initial values of the variables in $\definputvariables$ in the trace $\deftrace$, where $\valuesofvariables$ is the vector of values for $\cardinalitynospaces{\definputvariables}$ variables.
}
\marginnote{
  From two states $\defstate, \defstate'\in\state$, the notation $\defstate \stateeq{\inputvariableswithoutw} \defstate'$ denotes that the values of the variables in $\inputvariableswithoutw$ are equal in both states, \ie, $\forall \defvariable\in\inputvariableswithoutw.\spacer \defstate(\defvariable) = \defstate'(\defvariable)$.
}
\begin{definition}[Unused]\labdef{unused-predicate}
  Given a program $\defprogram$ and the set of input variables of interest $\definputvariables\in\setof\inputvariables$, the variables $\definputvariables$ are \emph{unused} if and only if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusedwrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\valuesofvariables
    .\spacer
      \retrieveinput{\defseq}(\definputvariables) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithoutw} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariables) = \defvalue
        \LanD
        \retrieveoutput{\defseq} = \retrieveoutput{\defseq'}
  \end{eqnarray*}
\end{definition}

Intuitively, an input variable $\definputvariable\in \definputvariables$ is unused if all feasible outcomes $\retrieveoutput{\defseq}$ are feasible from all possible initial values of $\definputvariable$.
That is, for all possible initial values $\defvalue$ that differ from the initial value of $\definputvariable$ in the trace $\defseq$, there exists another trace $\defseq'$ with initial value $\defvalue$ for $\definputvariable$ that leads to the same output $\retrieveoutput\defseq$.

\begin{example}\labexample{school-year}
Let us consider the example program presented in \textcite{Urban2018}, \cf{} \refprog{school-year}.
Based on the boolean-valued input variables \texttt{eng}, \texttt{math}, \texttt{science}, and \texttt{bonus}.
The program should determine whether a student has passed the year or not, and store the result in the variable \texttt{passing}. Additionally, the student is allowed a bonus to help with math and science.
However, there are two mistakes in the program: the statement inside the first conditional should be \texttt{passing = False} (\cf{} \refline{err1}), and the third condition should be \texttt{not science} instead of \texttt{not math} (\cf{} \refline{err2}).
These two mistakes cause the variables \texttt{eng} and \texttt{science} to be unused by \refprog{school-year}.
Let us consider the input variable \texttt{science}.
The trace semantics of the program simplified to consider only the variables \texttt{science} and \texttt{passing} and omitting intermediate state computations is:
\marginnote[*3]{
  The notation \[
  \tracetuple{\locinit}{\tuple{\defvalue_1}{\defvalue_2}}\tracearrow\tracetuple{\locend}{\tuple{\defvalue'_1}{\defvalue'_2}}
  \]
  denotes a trace that starts with the state $\tuple{\defvalue_1}{\defvalue_2}$ at the initial location $\locinit$, referring to the initial values of the variables \texttt{science} and \texttt{passing} respectively, and ends with the final state $\tuple{\defvalue'_1}{\defvalue'_2}$ at the last program location $\locend$. For brevity, we omit the intermediate states of the trace.
}
\begin{align*}
  &{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  =}\\
  &\quad\left\{
    \begin{array}{l}
      \tracetuple{\locinit}{\tuple{\true}{\anyvalue}}\tracearrow\tracetuple{\loc{10}}{\tuple{\true}{\true}}, \\
      \tracetuple{\locinit}{\tuple{\true}{\anyvalue}}\tracearrow\tracetuple{\loc{10}}{\tuple{\true}{\false}}, \\
      \tracetuple{\locinit}{\tuple{\false}{\anyvalue}}\tracearrow\tracetuple{\loc{10}}{\tuple{\false}{\true}}, \\
      \tracetuple{\locinit}{\tuple{\false}{\anyvalue}}\tracearrow\tracetuple{\loc{10}}{\tuple{\false}{\false}}
    \end{array}
  \right\}
\end{align*}
where the symbol $\anyvalue$ denotes any boolean value, the location $\locinit$ is the initial location (\refline{initial}), and $\loc{10}$ is the last location (\refline{last}).
The input variable \texttt{science} is unused, since each result value for \texttt{passing} is feasible from all possible initial values of \texttt{science}.

Instead, if we consider the variable \texttt{math}, the simplified trace semantics considering only the variables \texttt{math} and \texttt{passing} is:
\begin{align*}
  &{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
  =}\\
  &\quad\left\{
    \begin{array}{l}
    \tracetuple{\locinit}{\tuple\true\anyvalue}\tracearrow\tracetuple{\loc{10}}{\tuple\true\true}, \\
    \tracetuple{\locinit}{\tuple\false\anyvalue}\tracearrow\tracetuple{\loc{10}}{\tuple\false\true}, \\
    \tracetuple{\locinit}{\tuple\false\anyvalue}\tracearrow\tracetuple{\loc{10}}{\tuple\false\false}
  \end{array}
  \right\}
\end{align*}
The input variable \texttt{math} is used, since the result value for \texttt{passing} is not feasible from all possible initial values of \texttt{math}.
Indeed, only the initial state $\tuple\false\anyvalue$ yields the result value $\false$ for \texttt{passing} (in the final state $\tuple\false\false$).
\end{example}
\begin{marginlisting}[*-35]
  \caption{Program to check if a student passed the school year.}
  \labprog{school-year}
  \vspace{2\lineheight}
\begin{lstlisting}[language=Python,escapechar=|]
is_passed(eng, math, science,
    bonus):
  passing = True;|\labline{initial}|
  if not eng:
    eng = False;|\labline{err1}|
  if not math:
    passing = bonus;
  if not math:|\labline{err2}|
    passing = bonus;
|\labline{last}|
\end{lstlisting}
\end{marginlisting}

\begin{example}
  \begin{marginlisting}
    \caption{Syntactic versus semantic usage of the input variable \texttt{x}.}
    \labprog{syntactic-vs-semantic-usage}
    \vspace{2\lineheight}
  \begin{lstlisting}[language=Python]
x_plus_rand(x):
  return x + rand();
 \end{lstlisting}
  \end{marginlisting}
With this second example we highlight the difference between the syntactic and semantic meaning of using a variable. Indeed, a variable could be syntactically used in the program, \ie, present in the code, but it could be semantically unused, \ie, it does not affect the computation of the program.
Consider \refprog{syntactic-vs-semantic-usage}, where the input variable \texttt{x} is a non-negative integer.
The variable \texttt{x} is syntactically used by the program, as it is present in the return statement.
However, the variable \texttt{x} is semantically unused if we consider machine integers wrapped up to $\texttt{max\_int}\in\N$.
This difference can be clearly seen by studying the trace semantics of the program. In case of machine integers the trace semantics is:
\begin{align*}
  &\tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}}
  =\\
  &\quad\setdef{
    \tracetuple{\locinit}{\langle{x}}\rangle\tracearrow\tracetuple{\loc{3}}{\langle{x+r \mod \texttt{max\_int}}\rangle}
  }{x, r \in \N}
\end{align*}
where $x\in\N$ denotes the value of the input variable \texttt{x} and $r\in\N$ a random integer from the \texttt{rand()} function.
In this case, any outcome value $x+r \mod \texttt{max\_int}$ is feasible from any initial value of \texttt{x}.
Even if $x$ is bigger than a given outcome $z$, the result is still feasible as we can take a positive $r = \texttt{max\_int} - x + z$ to make the wrapped sum $x + r \mod \texttt{max\_int} = z$.

On the other hand, if we consider unbounded positive integers, the trace semantics is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}}
  =
  \setdef{
    \tracetuple{\locinit}{\langle{x}\rangle}\tracearrow\tracetuple{\loc{3x}}{\langle{x+r}\rangle}
  }{x, r \in \N}
\end{align*}
In such instance, for any outcome value $x+r$, only initial values of \texttt{x} that are equal or smaller than $x+r$ may generate such outcome.
For instance, if the outcome is 42, an initial value of 41 is feasible as it exists a random value $r = 1$ that makes the sum $41 + 1 = 42$. Instead, an initial value of 43 is not feasible as there is no positive random value $r$ that makes the sum $43 + r = 42$.
% \pgfplotstableread[]{
% x y
% 0 81
% 1 15
% 2 5
% 3 97
% 4 39
% 5 36
% 6 34
% 7 24
% 8 102
% 9 22
% 10 96
% 11 105
% 12 81
% 13 24
% 14 89
% 15 69
% 16 20
% 17 20
% 18 29
% 19 46
% 20 49
% 21 85
% 22 99
% 23 26
% 24 95
% 25 50
% 26 117
% 27 110
% 28 117
% 29 98
% 30 83
% 31 59
% 32 89
% 33 108
% 34 69
% 35 35
% 36 133
% 37 57
% 38 127
% 39 93
% 40 83
% 41 76
% 42 61
% 43 70
% 44 141
% 45 88
% 46 59
% 47 58
% 48 96
% 49 61
% 50 95
% 51 95
% 52 129
% 53 86
% 54 59
% 55 148
% 56 114
% 57 125
% 58 73
% 59 107
% 60 70
% 61 131
% 62 99
% 63 143
% 64 143
% 65 111
% 66 139
% 67 91
% 68 158
% 69 77
% 70 75
% 71 155
% 72 101
% 73 171
% 74 111
% 75 85
% 76 105
% 77 89
% 78 126
% 79 114
% 80 138
% 81 162
% 82 128
% 83 103
% 84 131
% 85 130
% 86 112
% 87 172
% 88 122
% 89 178
% 90 177
% 91 173
% 92 101
% 93 170
% 94 175
% 95 116
% 96 164
% 97 190
% 98 129
% 99 119
% }\advdata
% \begin{figure}[H]
% \centering
% \caption{Scatterplot of Advertising versus Sales Data}
% \begin{tikzpicture}
% \begin{axis}[
% axis lines = left,
% xlabel = {Input Variable \texttt{x}},
% ylabel = {Program Outcome}
% ]
% \addplot[
% mark=*,only marks,
% point meta =explicit symbolic,
% nodes near coords,
% ]
% table[x=x,y=y]{\advdata};
% \end{axis}
% \end{tikzpicture}
% \end{figure}
\end{example}

\nrefdef{unused-predicate} determines whether a given input variable is used or not, even in the presence of non-deterministic programs%
\sidenote[][*-7]{%
  In \refexample{school-year} the trace semantics where we consider subsets of input variables, \cf{} $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ and $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}$, are two non-deterministic sets of traces.
  %
  This can be easily seen by considering the two traces:
  \begin{gather*}
    \tracetuple{\locinit}{\tuple\true\true}\tracearrow\tracetuple{\loc{10}}{\tuple\true\true} \\
       \in \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}} \\
    \tracetuple{\locinit}{\tuple\true\true}\tracearrow\tracetuple{\loc{10}}{\tuple\true\false} \\
       \in \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  \end{gather*}
  where both start from the same initial state $\tuple\true\true$ and have different outcomes.}.
Furthermore, the next example shows that the unused predicate is termination aware.
Indeed, termination is a possible outcome of a program, and thus a variable should be unused if it does not affect the termination as well as the result of the program.

\begin{example}\labexample{non-termination}
  \begin{marginlisting}
    \caption{Program that does not terminate for positive values of \texttt{x}.}
    \labprog{non-termination}
    \vspace{2\lineheight}
  \begin{lstlisting}
non_termination(x):
  while x > 0:
    x = x + 1;
 \end{lstlisting}
  \end{marginlisting}
  Consider the \refprog{non-termination} defined on the side. The program does not terminate for positive values of \texttt{x}. Instead, it terminates without modifying \texttt{x} if \texttt{x} is negative or equal to $0$. The trace semantics is the following:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{non\_termination}}
    =
    \left\{
    \begin{array}{l}
        \tracetuple{\locinit}{\langle{<}\rangle}\tracearrow\tracetuple{\loc{4}}{\langle{<}\rangle}, \\
        \tracetuple{\locinit}{\langle{0}\rangle}\tracearrow\tracetuple{\loc{4}}{\langle{0}\rangle}, \\
        \tracetuple{\locinit}{\langle{>}\rangle}\nonterminatingtracearrow\
    \end{array}
    \right\}
  \end{align*}
  where the symbol $<$ denotes a negative value and $>$ a positive one. When the program is provided a positive value for \texttt{x}, it does not terminate and the respective traces are all of infinite length.

  In this example we conclude that the variable \texttt{x} is used since the non-termination is feasible only from positive values of \texttt{x}.
\end{example}

Note that, the $\unusedwrapper$ predicate (\refdef{unused-predicate}) states that the set of variables $\definputvariables$ is unused in the given program.
Equivalently, the same could be achieved by checking whether each variable separately is unused in the program, we prefer the formalization using sets of variables as originally proposed in \sidetextcite{Urban2018,Urban2020}.

\begin{lemma}\lablemma{single-vs-set-of-variables}
  For all program $\defprogram$ and set of variables $\definputvariables\in\setof\inputvariables$, it holds that:
\[\unusedwrapper(\tracesemantics) \IfF \foralldef{\definputvariable \in \definputvariables}{\unusedwrapperi(\tracesemantics)}
\]
\end{lemma}
\begin{proof}
  Let $\defprogram$ be a program and $\definputvariables\in\setof\inputvariables$ the set of variables of interest.
  To show ($\implies$), we assume that $\unusedwrapper(\tracesemantics)$ holds.
  We need to prove that for all $\definputvariable\in\definputvariables, \deftrace\in\tracesemantics$, and $\defvalue\in\values$ such that $\retrieveinput\deftrace(\definputvariable) \neq \defvalue$, there exists a trace $\deftrace'\in\tracesemantics$ such that $\retrieveinput{\deftrace'}(\definputvariable) = \defvalue$, $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, and $\retrieveoutput\deftrace = \retrieveoutput{\deftrace'}$ hold.
  By the definition of $\unusedwrapper(\tracesemantics)$, we have that $\forall \deftrace\in\tracesemantics, \defvalue\in\valuesofvariables.\spacer \retrieveinput{\deftrace}(\definputvariables) \neq \defvalue \implies \exists \deftrace'\in\tracesemantics.\spacer \retrieveinput{\deftrace'} \stateeq{\inputvariableswithoutw} \retrieveinput{\deftrace} \land \retrieveinput{\deftrace'}(\definputvariables) = \defvalue \land \retrieveoutput{\deftrace} = \retrieveoutput{\deftrace'}$. By expanding the definition we obtain:
  \marginnote{
    Given a vector of $n$ values $\defvalue\in\values^n$, we denote the $j$-th value as $\defvalue_j$.
  }
  \begin{align*}
    &\forall \deftrace\in\tracesemantics, \defvalue_1\in\values, \dots, \defvalue_{\cardinalitynospaces{\definputvariables}}\in\values.\\
    &\quad
      \exists j \le \cardinalitynospaces{\definputvariables}.\spacer \retrieveinput{\deftrace}(\definputvariables_j) \neq \defvalue_j \implies \\
    &\quad\quad
      \exists \deftrace'\in\tracesemantics.\spacer
      \forall j \le \cardinalitynospaces{\definputvariables}.\spacer
      \retrieveinput{\deftrace'}(\definputvariables_j) = \defvalue_j \land \\
    &\quad\quad\quad
      \retrieveinput{\deftrace'} \stateeq{\inputvariableswithoutw} \retrieveinput{\deftrace} \land \retrieveoutput{\deftrace} = \retrieveoutput{\deftrace'}
  \end{align*}
  Thus, to prove that it exists a trace $\deftrace'\in\tracesemantics$ such that $\retrieveinput{\deftrace'}(\definputvariable) = \defvalue$, $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, and $\retrieveoutput\deftrace = \retrieveoutput{\deftrace'}$ we can take the trace $\deftrace'$ that satisfies the above property where the $j$-th variable of $\definputvariables$ is $\definputvariable$, and we pick the values $\defvalue_1\in\values, \dots, \defvalue_{\cardinalitynospaces{\definputvariables}}\in\values$ such that $\retrieveinput{\deftrace}(\definputvariables_j) \neq \defvalue_j$ but $\retrieveinput{\deftrace}((\definputvariables)_l) = \defvalue_l$ for all the other indices $l$.
  As a consequence, from $\retrieveinput{\deftrace'}(\definputvariables_j) = \defvalue_j \land
    \retrieveinput{\deftrace'} \stateeq{\inputvariableswithoutw} \retrieveinput{\deftrace}$
  it follows that $\retrieveinput{\deftrace'}(\definputvariable) = \defvalue$, $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$ since all the values of variables in $\definputvariables\setminus{\{\definputvariable\}}$ and $\inputvariableswithoutw$ are equal in both $\deftrace$ and $\deftrace'$.
  Hence, $\deftrace'$ is the trace that satisfies $\unusedwrapperi$, concluding ($\implies$).

  To show ($\Leftarrow$), we assume that $\foralldef{\definputvariable \in \definputvariables}{\unusedwrapperi(\tracesemantics)}$ holds.
  We need to prove that for any trace $\deftrace\in\tracesemantics$ and value $\defvalue\in \valuesofvariables$ such that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$ it exists $\defseq'\in\tracesemantics$ such that $\retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}$, $
    \retrieveinput{\defseq'}(\definputvariables) = \defvalue$, and $
    \retrieveoutput{\defseq} = \retrieveoutput{\defseq'}$ hold.
  This direction of the implication is less intuitive than the previous one as it requires to show that no changes to multiple variables at the same time can affect the outcome of the program.
  Thus, we focus on values $\defvalue\in\valuesofvariables$ that differ from $\retrieveinput\deftrace(\definputvariables)$ in more than one index, let us call this set of indices that differ as $D\in\setof{\setdef{j\in\N}{j\le\cardinalitynospaces{\definputvariables}}}$. For each $j\in D$, by hypothesis it exists a trace $\defseq^j\in\tracesemantics$ such that $\retrieveinput{\defseq^j} \stateeq{\inputvariables \setminus{\{\definputvariables_j\}}} \retrieveinput{\defseq}$, $
  \retrieveinput{\defseq^j}(\definputvariables_j) = \defvalue_j$, and $
  \retrieveoutput{\defseq} = \retrieveoutput{\defseq^j}$.
  Then, by considering $\defseq^j$ it has to exist another trace $\defseq^{j,l}\in\tracesemantics$ such that $\retrieveinput{\defseq^{j,l}} \stateeq{\inputvariables \setminus{\{\definputvariables_j, (\definputvariables)_l\}}} \retrieveinput{\defseq}$, $
  \retrieveinput{\defseq^{j,l}}(\definputvariables_j, (\definputvariables)_l) = [\defvalue_j\spacer \defvalue_l]$, and $
  \retrieveoutput{\defseq} = \retrieveoutput{\defseq^{j,l}}$ where $l\in D$.
  By repeating this process for all the indices in $D$, we obtain a trace $\defseq'$ that satisfies the property of $\unusedwrapper$. Hence concluding ($\Leftarrow$).
\end{proof}

\section{Abstract Input Data Usage}
\labsec{abstract-input-data-usage}

Inspired by the definition of abstract non-interference (ANI) \sidecite{Giacobazzi2018,Mastroeni2023}, we introduce a generalized version of the unused predicate.
That is, a version of the unused predicate that abstracts the output states, allowing for a more general definition of the unused property.
Later, we will define the quantitative measure of input data usage, and use the abstraction of output states to determine numerical values from output states.

\marginnote[*-2]{
  \denis{The difference in style is due to the fact that this is a definition (unique in the document), while the other one two pages below is the reference to this definition.}
\begin{definition}[Abstract Non-Interference]\labdef{ani-predicate}
  The abstract non-interference predicate $\aniwrapper$ holds if, for any two traces $\defseq$ and $\defseq'$:
  \begin{gather*}
      \aniselect(\retrieveinput{\defseq}) = \aniselect(\retrieveinput{\defseq'})
      \ImplieS
       \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{gather*}
where $\aniselect$ and $\aniobserver$ are upper closure operators on program states to abstract input and output states respectively.
\end{definition}
% We assume that the objective of the input abstraction $\aniselect$ is to monitor the interference of the input variable $\definputvariables$.
}

We define the abstraction of output states, called output observer, as an upper closure operator over states.


\begin{definition}[Output Observer]\labdef{output-observer}
  Given a program $\defprogram$, an \emph{output observer} $\aniobserver\in \stateandbottom \to \stateandbottom$ is an upper closure operator (\refdef*{upper-closure-operator}[*2.7]) that abstracts the output states.
\end{definition}


We employ the output observer to define an abstract version of the unused predicate, called $\unusediowrapper$, as follows:


\begin{definition}[Abstract Unused]\labdef{abstract-unused}
  Given a program $\defprogram$, an output observer $\aniobserver\in \stateandbottom \to \stateandbottom$, and the input variables of interest $\definputvariables\in\setof\inputvariables$, the variables $\definputvariables$ are (abstractly) \emph{unused} if and only if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusediowrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\valuesofvariables
    .\spacer
      \retrieveinput{\defseq}(\definputvariables) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariables) = \defvalue
        \LanD
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{eqnarray*}
\end{definition}

This abstract unused predicate allows for further abstractions of the output states, which is weaker than the original definition of the unused property.
For instance, the output observer could identify which variable is to consider as the outcome of the program and abstract away the other variables. Another use case could be to abstract the output states into the parity of their variables, or even into the sign. In such case, a variable could be used with respect to \nrefdef{unused-predicate} but unused with respect to \nrefdef{abstract-unused}.

\begin{example}
  \begin{marginlisting}
    \caption{The variable \texttt{x} is used but not abstractly used.}
    \labprog{parity}
    \vspace{2\lineheight}
  \begin{lstlisting}
parity(x):
  return 2 * x;
\end{lstlisting}
  \end{marginlisting}
  The \refprog{parity} doubles the values of the input variable \texttt{x}. If we consider \nrefdef{unused-predicate}, the variable \texttt{x} is used as for any output value we consider, \eg, the output 4 from an input value of $\texttt{x}=2$, it does not exist a trace that starts with $x\neq 2$ and terminates with output 4. Instead, by considering the parity of the output value, the \refprog{parity} does not use the variable \texttt{x} as the only possible outcome is ``even''.
\end{example}

\nrefdef{abstract-unused} can also be seen as a potential abstract non-interference definition working with non-deterministic programs.
As a drawback, we lose the input abstraction: the tread-off allows non-determinism but does not permit input state abstractions in the sense of abstract non-interference.
The reason is that to take into account non-determinism, for any value of the input variables $\definputvariables$, we need to consider all possible traces that start from a different initial value.
Such low-level detail cannot be captured by the input abstraction employed in the definition of abstract non-interference.

The next result shows that the abstract unused predicate is equivalent to the original unused when the output observer is the identity function\sidenote{The identity function returns its parameter without any modification, \ie, $\identity(x) = x$.}.
\begin{proposition}[Unused Equivalence]\labprop{unused-predicate-equivalence}
  \marginnote{
    Note that, $\unusedwrapper$ is the unused predicate, \cf{} \nrefdef{unused-predicate}, and $\unusediowrapper$ is the abstract unused predicate, \cf{} \nrefdef{abstract-unused}.
  }
  Whenever $\aniobserver = \identity$, it holds that:
  \begin{gather*}
    \unusedwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{gather*}
\end{proposition}
\begin{proof}
  The proof is straightforward by the definition of the abstract unused predicate, \nrefdef{abstract-unused}, and the unused predicate, \nrefdef{unused-predicate}.
  Indeed, the output observer $\aniobserver = \identity$ does not abstract the output states, and thus the two predicates are equivalent.
\end{proof}

Next we show that abstract non-interference matches the abstract unused predicate when the program is deterministic, assuming the input abstraction forgets the values of the variables in $\definputvariables$, returning $\top$ otherwise.

\begin{proposition}[Abstract Non-Interference Equivalence]\labprop{ani-predicate-equivalence}
  \siderefbox{def}{ani-predicate}
  If $\defprogram$ is deterministic and the input abstraction is defined as:
  \begin{align*}
    \aniselecti(\defstate) \spacearound= \lambda \texttt{j}. \spacer
    \begin{cases}
      \defstate(\texttt{j}) & \text{if } \texttt{j} \not\in \definputvariables \\
      \top & \text{otherwise}
    \end{cases}
  \end{align*}
  then, it holds that:
  \begin{align*}
    \aniwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{align*}
\end{proposition}
\begin{proof}
  % By hypothesis, the program $\defprogram$ is deterministic. Thus, whenever two traces $\deftrace,\deftrace' \in \tracesemantics$ share the same input state, they also share the same output state, \ie, $\retrieveinput\deftrace = \retrieveinput\deftrace' \implies \retrieveoutput\deftrace = \retrieveoutput\deftrace'$.
  To show ($\implies$), we assume $\aniwrapper$.
  Thus, for any two traces $\deftrace, \deftrace'\in\tracesemantics$, it holds that whenever $\aniselecti(\retrieveinput\deftrace) = \aniselecti(\retrieveinput{\deftrace'})$, then $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$. By definition of $\aniselecti$, we obtain that the output abstractions match whenever $\retrieveinput\deftrace(\texttt{j}) = \retrieveinput{\deftrace'}(\texttt{j})$ for all variables $\texttt{j} \neq \definputvariables$. This hypothesis can be rewritten as $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$.
  To prove $\unusediowrapper$,
  let $\deftrace\in\tracesemantics$ be any trace and $\defvalue\in\valuesofvariables$ be any value.
  We assume $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, otherwise the implication is vacuously true.
  We need to show that there exists a trace $\deftrace'\in\tracesemantics$ such that: $(i)$ $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, $(ii)$ $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, and $(iii)$ $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$.
  The proof proceeds by absurd: we assume that for all traces $\deftrace'$ it holds that $\neg(i) \lor \neg(ii) \lor \neg(iii)$.
  By definition of the logical implication\sidenote{$\neg A \lor B \equiv A \implies B$.}, we have that $\neg(\neg(i) \lor \neg(ii)) \implies \neg(iii)$, thus $(i) \land (ii) \implies \neg(iii)$.
  Hence, for all traces $\deftrace'\in\tracesemantics$ we assume $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$ and $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, respectively $(i)$ and $(ii)$.
  As a consequence, to conclude ($\implies$) we need to show an absurd based on the hypothesis that the output abstraction does not match, \ie, $\aniobserver(\retrieveoutput\deftrace) \neq \aniobserver(\retrieveoutput{\deftrace'})$.
  Clearly, from $\aniwrapper$ applied to $(ii)$ we have that the outputs match, contradicting the hypothesis. Thus, $\unusediowrapper$ holds\sidenote{
  Note that, to show ($\implies$) we do not need the assumption that $\defprogram$ is deterministic.}.

  To show ($\Leftarrow$), we assume $\unusediowrapper$.
  For any trace $\deftrace\in\tracesemantics$ and value $\defvalue\in\valuesofvariables$, it holds that whenever $(a)$ $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, then it exists a trace $\deftrace'\in\tracesemantics$ such that $(b)$ $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, $(c)$ $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, and $(d)$ $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$ hold.
  To prove $\aniwrapper$, we assume that for any two traces $\deftrace, \deftrace'\in\tracesemantics$ it holds that $\retrieveinput{\deftrace} \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, otherwise $\aniwrapper$ vacuously holds. We need to show that the output abstraction of the two traces match, \ie, $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$.
  Let $\defvalue\in\valuesofvariables$ be any value.
  \begin{enumerate}
    \item If $\retrieveinput{\deftrace}(\definputvariables) = \retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, then by determinism of $\defprogram$ it follows that $(d)$, \cf{} $\retrieveoutput\deftrace = \retrieveoutput{\deftrace'}$, must hold.
    \item If $\retrieveinput{\deftrace}(\definputvariables) \neq \retrieveinput{\deftrace'}(\definputvariables)$, we let $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$ and $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$ without loss of generality, respectively proving $(a)$ and $(c)$. $(b)$ holds by hypothesis. Hence, from $\unusediowrapper$ it follows that $(d)$ must hold:
    \begin{align*}
      &\forall \deftrace\in\tracesemantics, \defvalue\in\valuesofvariables.\spacer \\
      &\quad (a) \implies \exists \deftrace'\in\tracesemantics.\spacer (b) \land (c) \land (d) && \iff \\
      &\quad \neg(a) \lor (\exists \deftrace'\in\tracesemantics.\spacer (b) \land (c) \land (d)) && \iff \\
      &\quad (\exists \deftrace'\in\tracesemantics.\spacer (b) \land (c) \land (d)) \lor \neg(a) && \iff \\
      &\quad  \neg(\exists \deftrace'\in\tracesemantics.\spacer (b) \land (c) \land (d)) \implies \neg(a) && \iff \\
      &\quad  (\forall \deftrace'\in\tracesemantics.\spacer \neg(b) \lor \neg(c) \lor \neg(d)) \implies \neg(a) && \iff \\
      &\quad  (\forall \deftrace'\in\tracesemantics.\spacer \neg(\neg(b) \lor \neg(c)) \implies \neg(d)) \implies \neg(a) && \iff \\
      &\quad  (\forall \deftrace'\in\tracesemantics.\spacer (b) \land (c) \implies \neg(d)) \implies \neg(a)
    \end{align*}
    Thus, everything resolves around whether $(d)$ holds or not.
    If $(d)$ does not hold, then $\neg(a)$ holds, but this contradicts the hypothesis that $(a)$ holds, hence $(d)$ must hold and so $\aniwrapper$.
    Otherwise, if $(d)$ holds, then $\aniwrapper$ holds.
    Concluding ($\Leftarrow$).
  \end{enumerate}
  % In such case, we also take into consideration that $\defprogram$ is deterministic.
  % Thus, whenever two traces $\deftrace,\deftrace' \in \tracesemantics$ share the same input state, they also share the same output state, \ie, $\retrieveinput\deftrace = \retrieveinput\deftrace' \implies \retrieveoutput\deftrace = \retrieveoutput\deftrace'$.
  % Let us fix the trace $\deftrace\in\tracesemantics$ and value $\defvalue\in\valuesofvariables$, either we assume that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$ \ref{ani-predicate-equivalence-0} or $\retrieveinput{\deftrace}(\definputvariables) = \defvalue$ \ref{ani-predicate-equivalence-1} holds.
  % \begin{enumerate}[label=(\roman*)]
  %   \item \label{ani-predicate-equivalence-0} In case we assume $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, then by $\unusediowrapper$ it exists a trace $\deftrace'\in\tracesemantics$ such that $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$, $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$, and $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$ hold. By assumption of $\aniwrapper$, for all two traces $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput{\deftrace'}$ holds, hence we need to show that any trace $\deftrace'\in\tracesemantics$ share the same output abstraction as $\deftrace$. It is easy to see that if $\retrieveinput{\deftrace'}(\definputvariables) = \defvalue$ by $\unusediowrapper$ then they also share the same output abstraction.
  %   \item \label{ani-predicate-equivalence-1} On the other hand, we assume that $\retrieveinput{\deftrace}(\definputvariables) \neq \defvalue$, hence $\unusediowrapper$ cannot prove our conclusion when applied to $\deftrace$ and $\defvalue$. However, either it exists a value $\defvalue'\in\valuesofvariables$ such that $\defvalue \neq \defvalue'$ or $\valuesofvariables=\{\defvalue\}$. In the latter, $\aniwrapper$ holds from the fact that any variable only input value is $\defvalue$ and the program $\defprogram$ is deterministic, thus $\tracesemantics$ contains only a single trace. Otherwise, we apply $\unusediowrapper$ to $\deftrace$ and the value $\defvalue'$.
  %   From here, it follows the same conclusion of the previous point \ref{ani-predicate-equivalence-0}
  % \end{enumerate}
\end{proof}

\begin{example}
Let us consider the simplified trace semantics of the program \refprog{school-year}, considering only the variables \texttt{science} and \texttt{passing}.
As this set of traces is non-deterministic, the predicate $\aniwrapper$ would discover that the variable \texttt{science} interferes with the output states.
In fact, assuming:
\marginnote[*-4]{
  \begin{eqnarray*}
    \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = } \\
    & \left\{
      \begin{array}{l}
        \tuple\true\anyvalue\tracearrow\tuple\true\true, \\
        \tuple\true\anyvalue\tracearrow\tuple\true\false, \\
        \tuple\false\anyvalue\tracearrow\tuple\false\true, \\
        \tuple\false\anyvalue\tracearrow\tuple\false\false
      \end{array}
    \right\}
  \end{eqnarray*}
}
\begin{align*}
  \eta_{\texttt{science}}(\defstate) \spacearound{&=} \lambda \texttt{j}. \spacer
  \begin{cases}
    \defstate(\texttt{j}) & \text{if } \texttt{j} \neq \texttt{science} \\
    \top & \text{otherwise}
  \end{cases}\\
  \aniobserver(\defstate) \spacearound{&=} \defstate
\end{align*}
the predicate of  abstract non-interference does not hold for the variable \texttt{science}.
This can be shown by the two traces
\begin{align*}
  \tuple\true\true&\tracearrow\tuple\false\true
  \\
  \tuple\true\true&\tracearrow\tuple\false\false
\end{align*}
where the output states are different, but the input states are the same.
Indeed, $\aniwrapper$ does not take into account that such variation in the outcome may be due to the non-determinism and classifies the variable \texttt{science} as an interfering variable.
\end{example}

We show that whenever some variables are not used, they are also abstractly unused.
In other words, the unused predicate is stronger than its abstract counterpart.
\begin{lemma}[Unused Implies Abstract Unused]\lablemma{unused-implies-abstract-unused}
  \marginnote{
    Note that, $\unusedwrapper$ is the unused predicate, \cf{} \nrefdef{unused-predicate}, and $\unusediowrapper$ is the abstract unused predicate, \cf{} \nrefdef{abstract-unused}.
  }
  \[\unusedwrapper(\tracesemantics) \ImplieS \unusediowrapper(\tracesemantics)\]
\end{lemma}
\begin{proof}
  The proof easily follows from the fact that $\aniobserver$ is an upper closure operator, \refdef*{upper-closure-operator}[*-2]. Hence, it relaxes the existential condition of the trace $\deftrace'$ on the output states, \ie, more traces are now able to satisfy $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput{\deftrace'})$.
\end{proof}

% The next result instead shows that whenever a set of variables is unused, it means that it exists a trace $\deftrace'$ starting
% Otherwise, that abstract output is not reachable by the program $\defprogram$.

% \begin{proposition}\labprop{abstract-unused-property}
%   If $\unusediowrapper(\tracesemantics)$ holds, then for any output state $\retrieveoutput{\defseq}\in\stateandbottom$ it holds that:
%   \begin{gather*}
%       \not\exists
%         \defseq'\in\tracesemantics.\spacer
%         \aniobserver(\retrieveoutput\defseq) = \aniobserver(\retrieveoutput{\defseq'}) \\
%       \lor \\
%       \foralldef{\defvalue\in\valuesofvariables}{\existsdef{\defseq'\in\tracesemantics}{
%         \retrieveinput{\defseq'}(\definputvariables) = \defvalue
%         \LanD
%         \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})}}
%   \end{gather*}
% \end{proposition}
% \begin{proof}
%   \denis{todo}
% \end{proof}


\section{The Unused Property}
\labsec{the-unused-property}

In this section, we state the \emph{unused property} as a property of programs.
Whenever a program does not use the input variables $\definputvariables$, the trace semantics of the program belongs to the unused property. The unused property is defined as follows:

\begin{definition}[Unused Property]\labdef{unused}
  Given a program $\defprogram$, and the set of input variables of interest $\definputvariables\in\setof\inputvariables$, the \emph{unused property} $\unused\in\setofsetof\finiteinfinitesequences$ is:
  \begin{align*}
    \unused\DefeQ&
    \setdef{\tracesemantics\in\tracetype}{\unusediowrapper(\tracesemantics)}
  \end{align*}
\end{definition}

Specifically, the unused property $\unused$ is the set of all the programs (or rather, their semantics) that do not use any of the variables in $\definputvariables$.
%
%
Thus a program $\defprogram$ satisfies the unused property if and only if $\defprogram$ does not use the set of input variables $\definputvariables$, formally:
\begin{align*}
  \defprogram \satisfies \unused \IfF \tracesemantics \subseteq \unused
\end{align*}

% The next result shows that the unused property is a sound and complete for a program to not use the set of variables $\definputvariables$.

% \begin{theorem}\labthm{unused-validation}
%   \begin{math}
%     \defprogram \satisfies \unused \IfF \collectingsemantics \subseteq \unused
%   \end{math}
% \end{theorem}
% \begin{proof}
%   The proof follows trivially from \refdef*{validation}[*-2] and the definition of the unused property $\unused$, \refdef{unused}.
% \end{proof}

Note that, the unused property is extensional, \ie, it does not depend on the intermediate states of the traces.
Indeed, given a set of traces generated by the trace semantics of a program $\defprogram$, the abstract unused predicate $\unusediowrapper$ only considers the input and output states of the given set of traces.

\section{Dependency Semantics}
\labsec{dependency-semantics}

Since the unused property $\unused$ is an extensional property, we can abstract away the intermediate states of traces without losing the information about the input-output dependencies.
Specifically, we abstract the collecting semantics $\collectingsemanticsnoparam\in\collectingtype$ (\refdef*{collecting-semantics}[*-2]) into a set of dependencies between initial and output states of finite traces and between initial and $\statebottom$ for infinite traces.
Formally, the pair of right-left adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ is defined as follows:
\marginnote[*2]{
  The notion $\retrieveinput{\deftrace}\in\state$ refers to the initial state of a trace $\deftrace$ and $\retrieveoutput{\deftrace}\in\stateandbottom$, where $\stateandbottom \defeq \state \setjoin \{\statebottom\}$ to the final one if $\deftrace$ is of finite length, otherwise $\statebottom$ for non-terminating traces.
}
\begin{definition}[Right-Left Adjoints for the Dependency Semantics]\labdef{right-left-adjoints-for-the-dependency-semantics}
\begin{align*}
  \dependencyabstraction \IN& \collectingtype \to \dependencytype \\
  \dependencyabstraction(\defsetofsetoftraces) \DefeQ& \setdef{
    \setdef{\inputoutputtuple{\defseq}}{\defseq\in\defsetoftraces}
  }{
    \defsetoftraces\in\defsetofsetoftraces
  }\\
  \dependencyconcretization \IN& \dependencytype \to \collectingtype \\
  \dependencyconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \defsetoftraces\in\setof\finiteinfinitesequences
  }{
    \setdef{\inputoutputtuple\defseq}{\defseq\in\defsetoftraces} \in \defsetofsetofdependencies
  }
\end{align*}
\end{definition}
The function $\dependencyabstraction$ abstracts away all intermediate states of any trace, preserving the set-structure of $\defsetofsetoftraces$.
The concretization $\dependencyconcretization$ yields all the semantics that share the same output observations of, at least, one of the set of semantics in $\defsetofsetofdependencies$.


\begin{theorem}\labthm{collecting-dependency-galois-connection}
The two adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ form a \emph{Galois insertion}:
\begin{align*}
  \galoisinjbetweensemantics{collecting}{dependency}
\end{align*}
\end{theorem}
\begin{proof}
  % Given a set of semantics $\defsetofsetoftraces\in\setofsetof\finiteinfinitesequences$ and a set of sets of input-output observations $\defsetofsetofdependencies\in\setofsetof\pairofstates$ implied by the abstraction of $\defsetofsetoftraces$, $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies$, we obtain that $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$ since the concretization $\dependencyconcretization$ builds all the possible semantics with the same set of input-output observations of at least one of the starting semantics.
  % Moreover, it is easy to note that $\dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
  We need to show that $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies \iff \defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$.
  First, we show the direction $(\implies)$.
  Assuming $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies$, we have that $\dependencyconcretization(\defsetofsetofdependencies)$ contains all the possible semantics that share the same set of input-output observations of at least one of the semantics in $\defsetofsetofdependencies$. Thus, $\dependencyconcretization(\defsetofsetofdependencies)$ also contains all the semantics in $\defsetofsetoftraces$, \ie, $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$.
  To show $(\Leftarrow)$, we assume $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$.
  It is easy to note that $\dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
  Hence, by monotonicity of $\dependencyabstraction$, we obtain $\dependencyabstraction(\defsetofsetoftraces)\subseteq \dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$.
\end{proof}

We now derive the \emph{dependency semantics} $\dependencysemantics$ as an abstraction of the collecting semantics.

\begin{definition}[Dependency Semantics]\labdef{dependency-semantics}
  The \emph{dependency semantics} $\dependencysemanticsnoparam\in\dependencytype$ is defined as:
  \begin{align*}
    \dependencysemanticsnoparam\DefeQ& \dependencyabstraction(\collectingsemanticsnoparam) \\
    % \spacearound{=}& \dependencyabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    % \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=}& \{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

The next result shows that the dependency semantics $\dependencysemantics$ allows a sound and complete verification that a set of input variables $\definputvariables$ is unused by the program $\defprogram$, \refdef*{unused}.

\begin{theorem}\labthm{dependency-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \dependencysemantics \subseteq \dependencyabstraction(\unused)
  \end{math}
\end{theorem}
\begin{proof}
  The implication $(\implies)$ follows from the monotonicity of $\dependencyabstraction$, as an implication from the fact that the two adjoints $\tuple\dependencyabstraction\dependencyconcretization$ form a Galois connection (\cf{} \refthm{collecting-dependency-galois-connection}), and \refdef{dependency-semantics} of $\dependencysemanticsnoparam$.
  Obtaining
  $
    \collectingsemanticsnoparam \subseteq \unused \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\unused)\implies \dependencysemanticsnoparam \subseteq \dependencyabstraction(\unused)
  $.
%
  Regarding the other implication $(\Leftarrow)$, from \refdef{dependency-semantics} of $\dependencysemanticsnoparam$ and the property of \refthm{collecting-dependency-galois-connection}, we obtain $\dependencysemanticsnoparam \subseteq \dependencyabstraction(\unused) \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\unused)\implies \collectingsemanticsnoparam \subseteq \dependencyconcretization(\dependencyabstraction(\unused))$, which can be written as $\tracesemanticsnoparam \in \dependencyconcretization(\dependencyabstraction(\unused))$ by the definition of $\collectingsemanticsnoparam$.
  By \refdef{right-left-adjoints-for-the-dependency-semantics} of $\dependencyconcretization$ it follows that $\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\tracesemanticsnoparam}\in\dependencyabstraction(\unused)$.
  Finally, by application of \refdef{right-left-adjoints-for-the-dependency-semantics} of $\dependencyabstraction$ we obtain $\tracesemanticsnoparam\in\unused$.
  The conclusion $\collectingsemanticsnoparam \subseteq \unused$ trivially follows from the definition of the subset inclusion $(\subseteq)$.
\end{proof}

\begin{example}
  \marginnote{
  \begin{eqnarray*}
    \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = } \\
    & \left\{
      \begin{array}{l}
        \tuple\true\anyvalue\dots\tuple\true\true, \\
        \tuple\true\anyvalue\dots\tuple\true\false, \\
        \tuple\false\anyvalue\dots\tuple\false\true, \\
        \tuple\false\anyvalue\dots\tuple\false\false
      \end{array}
    \right\}
  \end{eqnarray*}
}
  We show how the dependency semantics abstracts the trace semantics $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ of \refprog{school-year}.
  First, as required by \refthm{unused-validation}, the trace semantics should be abstracted first by the collecting semantics, obtaining $\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}$.
  The dependency semantics is then:
  \begin{align*}
     \dependencysemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    \spacearound{&=} \dependencyabstraction(\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}) \\
    \spacearound{&=} \left\{\left\{
      \begin{array}{l}
        \tuple{\tuple\true\anyvalue}{\tuple\true\true}, \\
        \tuple{\tuple\true\anyvalue}{\tuple\true\false}, \\
        \tuple{\tuple\false\anyvalue}{\tuple\false\true}, \\
        \tuple{\tuple\false\anyvalue}{\tuple\false\false}
      \end{array}
    \right\}\right\}
  \end{align*}
  The dependency semantics abstracts the trace semantics, preserving the input-output dependencies.
\end{example}

\section{Output Abstraction Semantics}
\labsec{output-abstraction-semantics}

We further abstract the dependency semantics $\dependencysemanticsnoparam$ into the output-abstraction semantics $\outputsemanticsnoparam$ as the unused property $\unused$ never considers output states without first abstracting them via the output observer $\aniobserver$, \refdef*{output-observer}[*-5].
Formally, the pair of right-left adjoints $\tuple{\outputabstraction}{\outputconcretization}$ is defined as:
%
\begin{definition}[Right-Left Adjoints for the Output Abstraction Semantics]\labdef{right-left-adjoints-for-the-output-abstraction-semantics}
\begin{align*}
  \outputabstraction \IN& \dependencytype \to \outputtype \\
  \outputabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setdef{
      \tuple{\retrieveinput{\defstate}}{\outputobs(\retrieveoutput{\defstate})}
    }{
      \inputoutputtuple{\defstate}\in\defsetofdependencies
    }
  }{
    \defsetofdependencies \in \defsetofsetofdependencies
  }\\
  \outputconcretization \IN& \outputtype \to \dependencytype \\
  \outputconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setjoin \setdef{
      \defsetofdependencies' \subseteq
      \setdef{
        \tuple{\retrieveinput\defstate}{\retrieveoutput\defstate'}
      }{
        \retrieveoutput{\defstate} = \outputobs(\retrieveoutput{\defstate'})
      }
    }{
      \inputoutputtuple{\defstate} \in \defsetofdependencies
    }
  }{
    \defsetofdependencies\in\defsetofsetofdependencies
  }
\end{align*}
\end{definition}
The function $\outputabstraction$ abstracts the output states of the dependencies and $\outputconcretization$ concretizes the set of dependencies that share the same set of output observations.
Note that, the abstraction function $\outputabstraction$ is well-defined as it preserves set joins, \ie, $\forall \defsetofdependencies, \defsetofdependencies' \in\outputtype.\spacer \outputabstraction(\defsetofdependencies \setjoin \defsetofdependencies') = \outputabstraction(\defsetofdependencies) \setjoin \outputabstraction(\defsetofdependencies')$ as $\outputabstraction$ preserves the set structure of its parameters.

\begin{theorem}\labthm{dependency-output-galois-connection}
  The two adjoints $\tuple{\outputabstraction}{\outputconcretization}$ form a \emph{Galois insertion}:
\begin{align*}
  \galoisinjbetweensemantics{dependency}{output}
\end{align*}
\end{theorem}
\begin{proof}
  Given two sets of sets of input-output observations $\defsetofsetofdependencies, \defsetofsetofdependencies\in\dependencytype$ such that $\outputabstraction(\defsetofsetofdependencies)\subseteq\defsetofsetofdependencies'$, we obtain that $\defsetofsetofdependencies\subseteq\outputconcretization(\defsetofsetofdependencies')$ since the concretization $\outputconcretization$ builds all the possible sets of sets of dependencies enhanced with the any amount of output states that result in an output abstraction of $\defsetofsetofdependencies'$.
  On the other hand, we assume that $\defsetofsetofdependencies\subseteq\outputconcretization(\defsetofsetofdependencies')$.
  By the monotonicity of $\outputabstraction$, \cf{} consequence of \refthm{dependency-output-galois-connection}, we obtain that $\outputabstraction(\defsetofsetofdependencies)\subseteq\outputabstraction(\outputconcretization(\defsetofsetofdependencies'))$.
  We note that the concretization $\outputconcretization(\defsetofsetofdependencies')$ builds all the possible sets of dependencies that may have generated the same output observations of each set of dependencies in $\defsetofsetofdependencies'$. By applying the abstraction $\outputabstraction$, for each of the sets of dependencies concretized by $\outputconcretization$, the abstraction returns the original set in $\defsetofsetofdependencies'$. Thus, we have that $\outputabstraction(\outputconcretization(\defsetofsetofdependencies')) = \defsetofsetofdependencies'$, so we conclude with $\outputabstraction(\defsetofsetofdependencies)\subseteq\defsetofsetofdependencies'$.
\end{proof}

We now derive the \emph{output-abstraction semantics} $\outputsemantics$ as an abstraction of the dependency semantics.

\begin{definition}[Output Abstraction Semantics]\labdef{output-abstraction-semantics}
  The \emph{output-abstraction semantics} $\outputsemanticsnoparam\in\outputtype$ is defined as:
  \begin{align*}
    \outputsemanticsnoparam\DefeQ&\outputabstraction(\dependencysemanticsnoparam) \\
    % \spacearound{=}&\outputabstraction(\{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}) \\
    \spacearound{=}&
    \{\spacearound{
      \setdef{
        \tuple{\retrieveinput{\deftrace}}{\outputobs(\retrieveoutput{\deftrace})}
      }{
        \deftrace \in \tracesemanticsnoparam
      }
    }\}
  \end{align*}
\end{definition}

Additionally, the reduction of the output-abstraction semantics $\outputsemanticsnoparam$ to the dependencies with abstraction of a final state in $X$ is defined as follows.
\begin{definition}[Output Reduction]\labdef{output-reduction}
  Let $X\in\setof\stateandbottom$ be a set of output states.
  The \emph{output reduction} $\reduce[\outputsemanticsnoparam]{X}\in\outputtype$ of the output-abstraction semantics $\outputsemanticsnoparam$ is defined as:
\begin{align*}
\reduce[\outputsemanticsnoparam]{X} \DefeQ \setdef{
  \setdef{
    \tuple{\retrieveinput\defstate}{\outputobs(\retrieveoutput{\defstate})}\in\defsetofdependencies
  }{
    \retrieveoutput{\defstate} \in X
  }
}{
  \defsetofdependencies\in \outputsemanticsnoparam
}
\end{align*}
\end{definition}
Such reduction is useful to analyze the dependencies that lead to a specific set of output states.
Note that, in case no dependency in $\outputsemanticsnoparam$ ends in an output state in $X$, the reduction is $\{\emptyset\}$.
The next result shows that the output-abstraction semantics $\outputsemantics$ allows a sound and complete verification for proving that an input variable $\definputvariables$ is unused in the program $\defprogram$, \refdef*{unused}.

\begin{theorem}\labthm{output-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\unused))
  \end{math}
\end{theorem}
\begin{proof}
  Similarly to the proof of \refthm{dependency-validation}, the implication $(\implies)$ follows from the monotonicity of $\outputabstraction$ and \refdef{output-abstraction-semantics} of $\outputsemanticsnoparam$.
  The implication $(\Leftarrow)$ follows from the definition of the output-abstraction semantics $\outputsemanticsnoparam$ and the property of \refthm{dependency-output-galois-connection}.
\end{proof}

We show the unused property $\unused$ derived from the dependency and output-abstraction semantics.
It is interesting to note that removing intermediate states and abstracting output states allows to rewrite the unused property as was originally proposed by \sidetextcite{Urban2018}. That is, the output abstraction and intermediate states are handled at a semantics level rather than in the property definition.


\marginnote{
  The set $\state$ contains the program states and $\stateandbottom\defeq\state\setjoin\{\statebottom\}$ are the states extended with $\statebottom$ to represent non-termination.
  The symbol $\valuesofvariables$ is the vector of values for $\cardinalitynospaces{\definputvariables}$ variables.
}
\marginnote{
  From two states $\defstate, \defstate'\in\state$, the notation $\defstate \stateeq{\inputvariableswithoutw} \defstate'$ denotes that the values of the variables in $\inputvariableswithoutw$ are equal in both states, \ie, $\forall \defvariable\in\inputvariableswithoutw.\spacer \defstate(\defvariable) = \defstate'(\defvariable)$.
}
\begin{remark} The abstraction $\outputabstraction\circ\dependencyabstraction$ of the unused property $\unused$ is defined as:
    \begin{gather*}
      \bigsetdef{\defsetofdependencies\in\setof\pairofstates}{
    \forall
      \inputoutputtuple\defstate\in\defsetofdependencies, \defvalue\in\valuesofvariables
    .\spacer
      \retrieveinput{\defstate}(\definputvariables) \neq \defvalue \ImplieS \\
      \exists
      \inputoutputtuple{\defstate'}\in\defsetofdependencies
      .\spacer
        \retrieveinput{\defstate'} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate}
        \LanD
        \retrieveinput{\defstate'}(\definputvariables) = \defvalue \\
        \LanD
       \retrieveoutput{\defstate} =\retrieveoutput{\defstate'}
      }
  \end{gather*}
\end{remark}

Note that, the property defined in the remark above is not, per se, a property of programs as by extension it would be a set of program semantics.
Instead, it is a property of output-and-dependency semantics, which is a set of sets of input-output observations.
%
Nevertheless, such characterization is useful as, whenever $\outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\unused))$ holds, the program $\defprogram$ does not use the input variables in $\definputvariables$ \refthm{output-validation}.

\section{Syntactic Dependency Analysis}
\labsec{syntactic-dependency-analysis}

\denis{todo}

\section{Summary}
\labsec{input-data-usage-summary}

In this chapter, we introduced the notion of input data usage and define a generalized version based on the definition of abstract non-interference.
We presented the hierarchy of semantics that allows reasoning about the usage of input variables.
In the next chapter, we will define a quantitative counterpart of the input data usage, able to measure the impact of variations in the input data on the outcome of a program. We will exploit the output abstraction to obtain numerical values from the output states.
