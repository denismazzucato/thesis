\chapter{Input Data Usage}
\labch{input-data-usage}


In this chapter, we introduce the notion of input data usage and the corresponding semantics, as proposed by \sidetextcite{Urban2018}.
In particular, we focus on the definition of an unused input variable, we present a more generalized definition with the introduction of output abstractions.
This chapter shows a \emph{sound and complete} hierarchy of semantics that contain only and exactly the information needed to reason about the usage of input variables.
Later, in the next chapters, we define a quantitative measure of usage of input variables, extending the qualitative notion presented in this chapter.

\section{Input Data Usage}
\labsec{input-data-usage}

Originally introduced by \sidetextcite{Urban2018}, the notion of input data usage is a predicate to determine whether a given input variable is used in the computation of the output. It consists in a predicate
\[
  \unusedwrapper \in \tracetype \to \B
\]
that holds whenever the input variable $\definputvariable\in\inputvariables$ is not used in the program under evaluation.

\begin{definition}[Unused]\labdef{unused-predicate}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, the variable $\definputvariable$ is \emph{unused} if the following predicate holds:
  \begin{align}
    \unusedwrapper(\tracesemantics) \DefifF
    \forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer&
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      \exists
        \defseq'\in\tracesemantics
      .\spacer&
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD \\
        &\retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD \\
        &\retrieveoutput{\defseq} = \retrieveoutput{\defseq'}
  \end{align}
\end{definition}

Intuitively, an input variable $\definputvariable$ is unused if all feasible trace outcomes $\retrieveoutput{\defseq}$ are feasible from all possible initial values of $\definputvariable$.
That is, for all possible initial values $\defvalue$ that differ from the initial value of $\definputvariable$ in the trace $\defseq$, there exists another trace $\defseq'$ with initial value $\defvalue$ for $\definputvariable$ that leads to the same output $\retrieveoutput\defseq$.

\begin{example}\labexample{school-year}
\begin{marginlisting}
  \caption{Program to check if a student passed the school year.}
  \labprog{school-year}
  \vspace{10pt}
\begin{lstlisting}
is_passed(
  eng, math, science, bonus):
  passing = True;
  if not eng:
    eng = False;
  if not math:
    passing = bonus;
  if not math:
    passing = bonus;
\end{lstlisting}
\end{marginlisting}
Let us consider the program of example presented in \sidetextcite{Urban2018}, on the side.
Based on the boolean-valued input variables \texttt{eng}, \texttt{math}, \texttt{science}, and \texttt{bonus}, the program should determine whether a student has passed the year or not, and store the result in the variable \texttt{passing}. Additionally, the student is allowed a bonus to help with math and science.
However, there are two mistakes in the program: it should be \texttt{passing = False} in the first conditional statement, and the third condition should be \texttt{not science} instead of \texttt{not math}.
These two mistakes cause the variables \texttt{eng} and \texttt{science} to be unused in \refprog{school-year}.
Let us consider the input variable \texttt{science}.
The simplified trace semantics, considering only the variables \texttt{science} and \texttt{passing}, is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  =
  \{
    &\tuple\true\anyvalue\dots\tuple\true\true, \\
    &\tuple\true\anyvalue\dots\tuple\true\false, \\
    &\tuple\false\anyvalue\dots\tuple\false\true, \\
    &\tuple\false\anyvalue\dots\tuple\false\false
  \}
\end{align*}
where each state $\tuple{\defvalue_1}{\defvalue_2}$ shows the boolean value $\defvalue_1$ of \texttt{science} and $\defvalue_2$ of \texttt{passing}. The symbol $\anyvalue$ denotes any boolean value. We omit the intermediate states for brevity, only showing input-output dependencies.
The input variable \texttt{science} is unused, since each result value for \texttt{passing} is feasible from all possible initial values of \texttt{science}.

Instead, if we consider the variable \texttt{math}, the simplified trace semantics considering only the variables \texttt{math} and \texttt{passing} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
  =
  \{
    &\tuple\true\anyvalue\dots\tuple\true\true, \\
    &\tuple\false\anyvalue\dots\tuple\false\true, \\
    &\tuple\false\anyvalue\dots\tuple\false\false
  \}
\end{align*}
The input variable \texttt{math} is used, since the result value for \texttt{passing} is not feasible from all possible initial values of \texttt{math}.
Indeed, only the initial state $\tuple\false\anyvalue$ yields the result value $\false$ for \texttt{passing} (in the final state $\tuple\false\false$).
\end{example}

\refdef{unused-predicate} is significant as it determines whether a given input variable is used or not, even in the presence of non-deterministic programs\sidenote{In \refexample{school-year} the trace semantics where we consider subsets of input variables, \cf{} $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ and $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}$, are two non-deterministic set of traces.}.
Furthermore, also non-termination is considered in the definition, as the predicate consider non-termination as a feasible trace outcome.

\begin{example}\labexample{non-termination}
  \begin{marginlisting}
    \caption{Program that does not terminate for positive values of \texttt{x}.}
    \labprog{non-termination}
    \vspace{10pt}
  \begin{lstlisting}
non_termination(x):
  while x > 0:
    x = x + 1;
\end{lstlisting}
  \end{marginlisting}
  Consider the \refprog{non-termination} defined on the side. The program does not terminate for positive values of \texttt{x}. Instead, it terminates without modifying \texttt{x} on the value of $0$ or negative. The trace semantics is the following:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{non\_termination}}
    =
    \{
      \langle{<}\rangle\dots\langle{<}\rangle,
      \langle{0}\rangle\dots\langle{0}\rangle,
      \langle{>}\rangle\dots
    \}
  \end{align*}
  where the symbol $\langle{<}\rangle$ denotes a negative value and $\langle{<}\rangle$ a positive one. When the program is provided a positive value for \texttt{x}, it does not terminate and the respective traces are all of infinite length.

  In this case, the variable \texttt{x} is used since the non-termination is feasible only from positive values of \texttt{x}.
  In fact, by excluding non-termination as a possible outcome, the variable \texttt{x} would be unused.
\end{example}

\section{Abstract Input Data Usage}
\labsec{abstract-input-data-usage}

Inspired by the definition of abstract non-interference (ANI) \sidecite{Giacobazzi2018,Mastroeni2023}, we introduce the notion of abstract unused predicate.
That is, a weaker version of the unused predicate that abstracts the output states, allowing for a more general definition of the unused property.
Later, we define the quantitative measure of input data usage, and use the abstraction of output states to determine numerical values from output states.

\marginnote{
\begin{definition}[Abstract Non-Interference]\labdef{ani-predicate}
  The abstract non-interference predicate $\aniwrapper$ holds if, for any two traces $\defseq$ and $\defseq'$, it holds that:
  \begin{gather*}
      \aniselect(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \aniselect(\retrieveinput{\defseq'})
      \ImplieS
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{gather*}
\end{definition}}

In the following, we define the abstraction of output states, called output observer, as a map from states to an abstract domain.

\begin{definition}[Output observer]\labdef{output-observer}
  Given a program $\defprogram$, an \emph{output observer} $\aniobserver\in \state \to \state$ is an upper closure operator that abstracts the value of output states.
\end{definition}

\denis{Examples of the output observer, e.g. gathering together output values, even-odd values, neural networks.}

Similar to the abstraction of non-interference property into the abstract non-interference, we employ the output observer to define an abstract version of the unused predicate, called $\unusediowrapper$.


\begin{definition}[Abstract Unused]\labdef{abstract-unused}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, an output observer $\aniobserver\in \state \to \state$ the variable $\definputvariable$ is \emph{unused} if the following predicate holds:
  \begin{align}
    \unusediowrapper(\tracesemantics) \DefifF
    \forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer&
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      \exists
        \defseq'\in\tracesemantics
      .\spacer&
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD \\
        &\retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD \\
        &\aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{align}
\end{definition}

This latter abstract unused predicate allows for further abstractions of the output states, which can be used to determine the impact of variations of the input data on the output states.
This can also be seen as a potential abstract non-interference definition working with non-deterministic programs.
As a drawback, we lose the input abstraction, the tread-off to allow for non-determinism does not permit input state abstractions in the sense of abstract non-interference.

The next result shows that the abstract unused predicate is equivalent to the original unused when the output observer is the identity function.
\begin{remark}[Unused Equivalence]\labremark{unused-predicate-equivalence}
  Whenever $\aniobserver = \identity$, it holds that:
  \begin{gather*}
    \unusedwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{gather*}
\end{remark}

Moreover, abstract non-interference matches the abstract unused predicate when the program is deterministic, assuming the input abstraction is the identity function.

\begin{remark}[Abstract Non-Interference Equivalence]\labremark{ani-predicate-equivalence}
  If $\defprogram$ deterministic and $\aniselect = \identity$, then, it holds that:
  \begin{align*}
    \aniwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{align*}
\end{remark}

\denis{Example comparing ANI and unused on a non-deterministic program.}

The input data usage property $\unused$ can be now formally defined as follows:

\begin{definition}[Unused Property]\labdef{unused}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, the \emph{input data usage} property $\unused\in\setofsetof\finiteinfinitesequences$ is defined as:
  \begin{align*}
    \unused\DefeQ&
    \setdef{\tracesemantics\in\tracetype}{\unusediowrapper(\tracesemantics)}
  \end{align*}
\end{definition}

The input data usage property $\unused$ defined above is not subset-closed, we cannot use the standard abstract interpretation framework to soundly prove that a program does not use (some of) its input variables by checking whether an over-approximation of the semantics of the program is included in the unused property.
We solve this problem by lifting the trace semantics of the program to its collecting semantics.

\begin{theorem}[Validation of Unused]\labthm{validation-unused}
  A program $\defprogram$ satisfies a property $\defproperty\in\setofsetof\finiteinfinitesequences$ if and only if its collecting semantics $\collectingsemantics$ belongs to the property $\defproperty$.
  \begin{align*}
    \defprogram \satisfies \unused \IfF \collectingsemantics \subseteq \unused
  \end{align*}
\end{theorem}

\section{Dependency Semantics}
\labsec{dependency-semantics}

\denis{Maybe explain here that the soundness requirement for abstractions of the collecting is a reasoning on set of programs rather than a single program.}

We abstract the collecting semantics $\collectingsemantics$ into a set of dependencies between output states of finite traces and between initial and $\statebottom$ for infinite traces.
Formally, the pair of right-left adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ is defined as follows:
%
\begin{align*}
  \dependencyabstraction \IN& \collectingtype \to \dependencytype \\
  \dependencyabstraction(\defsetofsetoftraces) \DefeQ& \setdef{
    \setdef{\inputoutputtuple{\defseq}}{\defseq\in\defsetoftraces}
  }{
    \defsetoftraces\in\defsetofsetoftraces
  }\\
  \dependencyconcretization \IN& \dependencytype \to \collectingtype \\
  \dependencyconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \defsetoftraces\in\setof\finiteinfinitesequences
  }{
    \setdef{\inputoutputtuple\defseq}{\defseq\in\defsetoftraces} \in \defsetofsetofdependencies
  }
\end{align*}
where $\dependencyabstraction$ abstracts away all intermediate states of any trace, preserving the set-structure of $\defsetofsetoftraces$.
The concretization $\dependencyconcretization$ yields all the semantics that share the same output observations of, at least, one of the set of semantics in $\defsetofsetofdependencies$.


\begin{theorem}\labthm{collecting-dependency-galois-connection}
The two adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{collecting}{dependency}
\end{align*}
\end{theorem}
\begin{proof}
  Given a set of semantics $\defsetofsetoftraces\in\setofsetof\finiteinfinitesequences$ and a set of sets of input-output observations $\defsetofsetofdependencies\in\setofsetof\pairofstates$ implied by the abstraction of $\defsetofsetoftraces$, $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies$, we obtain that $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$ since the concretization $\dependencyconcretization$ builds all the possible semantics with the same set of input-output observations of at least one of the starting semantics.
  Moreover, it is easy to note that $\dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
\end{proof}

We now derive the \emph{dependency semantics} $\dependencysemantics$ as an abstraction of the collecting semantics.

\begin{definition}[Dependency Semantics]\labdef{dependency-semantics}
  The \emph{dependency semantics} $\dependencysemanticsnoparam\in\dependencytype$ is defined as:
  \begin{align*}
    \dependencysemanticsnoparam\DefeQ& \dependencyabstraction(\collectingsemanticsnoparam) \\
    % \spacearound{=}& \dependencyabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    % \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=}& \{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

The next result shows that the dependency semantics $\dependencysemantics$ allows a sound and complete verification for proving that an input variable $\definputvariable$ is unused in the program $\defprogram$.

\begin{theorem}\labthm{dependency-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \dependencysemantics \subseteq \dependencyabstraction(\unused)
  \end{math}
\end{theorem}
\begin{proof}
  The implication $(\implies)$ follows from the monotonicity of $\dependencyabstraction$, \refthm{collecting-dependency-galois-connection}, and the definition of $\dependencysemanticsnoparam$, \refeq{dependency}, \ie,
  $
    \collectingsemanticsnoparam \subseteq \bounded \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\bounded)\implies \dependencysemanticsnoparam \subseteq \dependencyabstraction(\bounded)
  $.
  Regarding the other implication $(\Leftarrow)$, from the definition of $\dependencysemanticsnoparam$ and the property of \refthm{collecting-dependency-galois-connection}, we obtain $\dependencysemanticsnoparam \subseteq \dependencyabstraction(\bounded) \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\bounded)\implies \collectingsemanticsnoparam \subseteq \dependencyconcretization(\dependencyabstraction(\bounded))$, which can be written as $\tracesemanticsnoparam \in \dependencyconcretization(\dependencyabstraction(\bounded))$ by the definition of $\collectingsemanticsnoparam$.
  By definition of $\dependencyconcretization$, \refeq{dependency-concretization}, it follows that $\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\tracesemanticsnoparam}\in\dependencyabstraction(\bounded)$.
  Finally, by application of the definition of $\dependencyabstraction$, \refeq{dependency-abstraction}, we obtain $\tracesemanticsnoparam\in\bounded$.
  The conclusion $\collectingsemanticsnoparam \subseteq \bounded$ trivially follows from the definition of $(\subseteq)$.
\end{proof}

\denis{Example to show how the dependency semantics works.}

\section{Output Abstraction Semantics}
\labsec{output-abstraction-semantics}

We further abstract the dependency semantics $\dependencysemantics$ into the output-abstraction semantics $\outputsemantics$.
We exploit the output observer $\aniobserver$ to abstract the output states.
Formally, the pair of right-left adjoints $\tuple{\outputabstraction}{\outputconcretization}$ is defined as follows:
%
\begin{align*}
  \outputabstraction \IN& \dependencytype \to \outputtype \\
  \outputabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setdef{
      \tuple{\retrieveinput{\defstate}}{\outputobs(\retrieveoutput{\defstate})}
    }{
      \inputoutputtuple{\defstate}\in\defsetofdependencies
    }
  }{
    \defsetofdependencies \in \defsetofsetofdependencies
  }\\
  \outputconcretization \IN& \outputtype \to \dependencytype \\
  \outputconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setjoin \setdef{
      \defsetofdependencies' \subseteq
      \setdef{
        \tuple{\retrieveinput\defstate}{\retrieveoutput\defstate'}
      }{
        \retrieveoutput{\defstate} = \outputobs(\retrieveoutput{\defstate'})
      }
    }{
      \inputoutputtuple{\defstate} \in \defsetofdependencies
    }
  }{
    \defsetofdependencies\in\defsetofsetofdependencies
  }
\end{align*}
where $\outputabstraction$ abstracts the output states of the dependencies and $\outputconcretization$ concretizes the set of dependencies that share the same set of output observations.

\begin{theorem}\labthm{dependency-output-galois-connection}
  The two adjoints $\tuple{\outputabstraction}{\outputconcretization}$ form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{dependency}{output}
\end{align*}
\end{theorem}

We now derive the \emph{output-abstraction semantics} $\outputsemantics$ as an abstraction of the dependency semantics.

\begin{definition}[Output Abstraction Semantics]\labdef{inputoutput-abstraction-semantics}
  The \emph{output-abstraction semantics} $\outputsemanticsnoparam\in\outputtype$ is defined as:
  \begin{align*}
    \outputsemanticsnoparam\DefeQ&\outputabstraction(\dependencysemanticsnoparam) \\
    % \spacearound{=}&\outputabstraction(\{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}) \\
    \spacearound{=}&
    \{\spacearound{
      \setdef{
        \tuple{\retrieveinput{\deftrace}}{\outputobs(\retrieveoutput{\deftrace})}
      }{
        \deftrace \in \tracesemanticsnoparam
      }
    }\}
  \end{align*}
\end{definition}

The next result shows that the output-abstraction semantics $\outputsemantics$ allows a sound and complete verification for proving that an input variable $\definputvariable$ is unused in the program $\defprogram$.

\begin{theorem}\labthm{output-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\unused))
  \end{math}
\end{theorem}

\denis{Example to show how the dependency semantics works.}

We show the unused property $\unused$ derived from the dependency and output-abstraction semantics.
It is interesting to note that removing intermediate states and abstracting output states allows to rewrite the unused property as was originally proposed by \sidetextcite{Urban2018}. That is, the output abstraction and intermediate states are handled at a semantics level rather than in the property definition.

\begin{remark} The abstraction $\outputabstraction\circ\dependencyabstraction$ of the unused property $\unused$ is defined as:
    \begin{align*}
    \setdef{\defsetofdependencies\in\setof\pairofstates}{
    \forall
      \inputoutputtuple\defstate\in\defsetofdependencies, \defvalue\in\values
    .\spacer &
      \retrieveinput{\defstate}(\definputvariable) \neq \defvalue \ImplieS \\
      \exists
      \inputoutputtuple{\defstate'}\in\defsetofdependencies
      .\spacer &
        \retrieveinput{\defstate'} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate}
        \LanD \\
        &
        \retrieveinput{\defstate'}(\definputvariable) = \defvalue
        \LanD \\
        &
       \retrieveoutput{\defstate} =\retrieveoutput{\defstate'}
    }
  \end{align*}
\end{remark}
