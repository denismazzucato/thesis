\chapter{Input Data Usage}
\labch{input-data-usage}


In this chapter, we introduce the notion of input data usage as proposed by \textcite{Urban2018}.
In particular, we include output abstractions in the definition of an unused input variable obtaining a more general definition.
Then, we present a \emph{sound and complete} hierarchy of semantics that contain only, and exactly, the information needed to reason about the usage of input variables.
Later in the next chapters, we will define a quantitative measure of usage of input variables, extending the qualitative notion presented in this chapter.

\emph{Dans ce chapitre, nous introduisons la notion d'utilisation des données d'entrée comme proposé par \sidetextcite{Urban2018}. En particulier, nous incluons des abstractions de sortie dans la définition d'une variable d'entrée inutilisée, obtenant ainsi une définition plus générale. Ensuite, nous présentons une hiérarchie \emph{correcte et complète} de sémantiques qui contiennent uniquement et exactement les informations nécessaires pour raisonner sur l'utilisation des variables d'entrée. Plus tard, dans les chapitres suivants, nous définirons une mesure quantitative de l'utilisation des variables d'entrée, en étendant la notion qualitative présentée dans ce chapitre.}

\section{Input Data Usage}
\labsec{input-data-usage}

Originally introduced by \textcite{Urban2018}, the notion of input data usage is a predicate to determine whether the input variable $\definputvariable\in\inputvariables$ is used in the computation of the output. It consists in a predicate
\[
  \unusedwrapper \in \tracetype \to \B
\]
that holds whenever the input variable $\definputvariable\in\inputvariables$ is not used in the program under evaluation.

\begin{definition}[Unused]\labdef{unused-predicate}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, the variable $\definputvariable$ is \emph{unused} if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusedwrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD
        \retrieveoutput{\defseq} = \retrieveoutput{\defseq'}
  \end{eqnarray*}
\end{definition}

Intuitively, an input variable $\definputvariable$ is unused if all feasible trace outcomes $\retrieveoutput{\defseq}$ are feasible from all possible initial values of $\definputvariable$.
That is, for all possible initial values $\defvalue$ that differ from the initial value of $\definputvariable$ in the trace $\defseq$, there exists another trace $\defseq'$ with initial value $\defvalue$ for $\definputvariable$ that leads to the same output $\retrieveoutput\defseq$.

\begin{example}\labexample{school-year}
\begin{marginlisting}[*-9]
  \caption{Program to check if a student passed the school year.}
  \labprog{school-year}
  \vspace{2\lineheight}
\begin{lstlisting}[language=Python]
is_passed(eng, math, science,
    bonus):
  passing = True;
  if not eng:
    eng = False;
  if not math:
    passing = bonus;
  if not math:
    passing = bonus;
\end{lstlisting}
\end{marginlisting}
Let us consider the program of example presented in \textcite{Urban2018}, \cf{} \refprog{school-year} on the side.
Based on the boolean-valued input variables \texttt{eng}, \texttt{math}, \texttt{science}, and \texttt{bonus}.
The program should determine whether a student has passed the year or not, and store the result in the variable \texttt{passing}. Additionally, the student is allowed a bonus to help with math and science.
However, there are two mistakes in the program: it should be \texttt{passing = False} in the first conditional statement, and the third condition should be \texttt{not science} instead of \texttt{not math}.
These two mistakes cause the variables \texttt{eng} and \texttt{science} to be unused in \refprog{school-year}.
Let us consider the input variable \texttt{science}.
The simplified trace semantics, considering only the variables \texttt{science} and \texttt{passing}, is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  =
  \left\{
    \begin{array}{l}
      \tuple\true\anyvalue\dots\tuple\true\true, \\
      \tuple\true\anyvalue\dots\tuple\true\false, \\
      \tuple\false\anyvalue\dots\tuple\false\true, \\
      \tuple\false\anyvalue\dots\tuple\false\false
    \end{array}
  \right\}
\end{align*}
where each state $\tuple{\defvalue_1}{\defvalue_2}$ shows the boolean value $\defvalue_1$ of \texttt{science} and $\defvalue_2$ of \texttt{passing}. The symbol $\anyvalue$ denotes any boolean value. We omit the intermediate states for brevity, only showing input-output dependencies.
The input variable \texttt{science} is unused, since each result value for \texttt{passing} is feasible from all possible initial values of \texttt{science}.

Instead, if we consider the variable \texttt{math}, the simplified trace semantics considering only the variables \texttt{math} and \texttt{passing} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
  =
  \left\{
    \begin{array}{l}
    \tuple\true\anyvalue\dots\tuple\true\true, \\
    \tuple\false\anyvalue\dots\tuple\false\true, \\
    \tuple\false\anyvalue\dots\tuple\false\false
  \end{array}
  \right\}
\end{align*}
The input variable \texttt{math} is used, since the result value for \texttt{passing} is not feasible from all possible initial values of \texttt{math}.
Indeed, only the initial state $\tuple\false\anyvalue$ yields the result value $\false$ for \texttt{passing} (in the final state $\tuple\false\false$).
\end{example}

\begin{example}
  \begin{marginlisting}
    \caption{Syntactic versus semantic usage of the input variable \texttt{x}.}
    \labprog{syntactic-vs-semantic-usage}
    \vspace{2\lineheight}
  \begin{lstlisting}[language=Python]
x_plus_rand(x):
  return x + rand();
\end{lstlisting}
  \end{marginlisting}
With this second example we highlight the difference between the syntactic and semantic meaning of using a variable. Indeed, a variable could be syntactically used in the program, \ie it is present in the code, but it could be semantically unused, \ie it does not affect the output of the program; and vice versa.
Consider \refprog{syntactic-vs-semantic-usage} on the side, where the input variable \texttt{x} is used in the return statement.
However, the variable \texttt{x} is semantically unused if we consider machine integers wrapped up to $\texttt{max\_int}\in\N$. Otherwise, if we consider unbounded integers, then the input variable \texttt{x} is, as expected, used.
This difference can be clearly seen by the trace semantics of the program, in case of bounded integers the trace semantics is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}_\texttt{x}}
  =
  \setdef{
    \langle{x}\rangle\dots\langle{x+r \mod \texttt{max\_int}}\rangle
  }{x, r \in \N}
\end{align*}
where $x\in\N$ denotes the value of the input variable \texttt{x} and $r\in\N$ a random integer from the \texttt{rand()} function.
In this case, any outcome value $x+r \mod \texttt{max\_int}$ is feasible from any initial value of \texttt{x}.
On the other hand, if we consider unbounded integers, the trace semantics is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}_\texttt{x}}
  =
  \setdef{
    \langle{x}\rangle\dots\langle{x+r}\rangle
  }{x, r \in \N}
\end{align*}
In such instance, for any outcome value $x+r$, only initial values of \texttt{x} that are equal or smaller than $x+r$ may generate such outcome.
% \pgfplotstableread[]{
% x y
% 0 81
% 1 15
% 2 5
% 3 97
% 4 39
% 5 36
% 6 34
% 7 24
% 8 102
% 9 22
% 10 96
% 11 105
% 12 81
% 13 24
% 14 89
% 15 69
% 16 20
% 17 20
% 18 29
% 19 46
% 20 49
% 21 85
% 22 99
% 23 26
% 24 95
% 25 50
% 26 117
% 27 110
% 28 117
% 29 98
% 30 83
% 31 59
% 32 89
% 33 108
% 34 69
% 35 35
% 36 133
% 37 57
% 38 127
% 39 93
% 40 83
% 41 76
% 42 61
% 43 70
% 44 141
% 45 88
% 46 59
% 47 58
% 48 96
% 49 61
% 50 95
% 51 95
% 52 129
% 53 86
% 54 59
% 55 148
% 56 114
% 57 125
% 58 73
% 59 107
% 60 70
% 61 131
% 62 99
% 63 143
% 64 143
% 65 111
% 66 139
% 67 91
% 68 158
% 69 77
% 70 75
% 71 155
% 72 101
% 73 171
% 74 111
% 75 85
% 76 105
% 77 89
% 78 126
% 79 114
% 80 138
% 81 162
% 82 128
% 83 103
% 84 131
% 85 130
% 86 112
% 87 172
% 88 122
% 89 178
% 90 177
% 91 173
% 92 101
% 93 170
% 94 175
% 95 116
% 96 164
% 97 190
% 98 129
% 99 119
% }\advdata
% \begin{figure}[H]
% \centering
% \caption{Scatterplot of Advertising versus Sales Data}
% \begin{tikzpicture}
% \begin{axis}[
% axis lines = left,
% xlabel = {Input Variable \texttt{x}},
% ylabel = {Program Outcome}
% ]
% \addplot[
% mark=*,only marks,
% point meta =explicit symbolic,
% nodes near coords,
% ]
% table[x=x,y=y]{\advdata};
% \end{axis}
% \end{tikzpicture}
% \end{figure}
\end{example}

\nrefdef{unused-predicate} is significant as it determines whether a given input variable is used or not, even in the presence of non-deterministic programs\sidenote[][*-2]{In \refexample{school-year} the trace semantics where we consider subsets of input variables, \cf{} $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ and $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}$, are two non-deterministic sets of traces.}.
Furthermore, also non-termination is considered in the definition.
In fact, non-termination is a feasible trace outcome.

\begin{example}\labexample{non-termination}
  \begin{marginlisting}
    \caption{Program that does not terminate for positive values of \texttt{x}.}
    \labprog{non-termination}
    \vspace{2\lineheight}
  \begin{lstlisting}
non_termination(x):
  while x > 0:
    x = x + 1;
\end{lstlisting}
  \end{marginlisting}
  Consider the \refprog{non-termination} defined on the side. The program does not terminate for positive values of \texttt{x}. Instead, it terminates without modifying \texttt{x} on the value of $0$ or negative. The trace semantics is the following:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{non\_termination}}
    =
    \{
      \langle{<}\rangle\dots\langle{<}\rangle,
      \langle{0}\rangle\dots\langle{0}\rangle,
      \langle{>}\rangle\dots
    \}
  \end{align*}
  where the symbol $\langle{<}\rangle$ denotes a negative value and $\langle{>}\rangle$ a positive one. When the program is provided a positive value for \texttt{x}, it does not terminate and the respective traces are all of infinite length.

  In this case, the variable \texttt{x} is used since the non-termination is feasible only from positive values of \texttt{x}.
  In fact, by excluding non-termination as a possible outcome, the variable \texttt{x} would be --instead-- unused.
\end{example}

\section{Abstract Input Data Usage}
\labsec{abstract-input-data-usage}

Inspired by the definition of abstract non-interference (ANI) \sidecite{Giacobazzi2018,Mastroeni2023}, we introduce the notion of abstract unused predicate.
That is, a weaker version of the unused predicate that abstracts the output states, allowing for a more general definition of the unused property.
Later, we will define the quantitative measure of input data usage, and use the abstraction of output states to determine numerical values from output states.

\marginnote{
\begin{definition}[Abstract Non-Interference]\labdef{ani-predicate}
  The abstract non-interference predicate $\aniwrapper$ holds if, for any two traces $\defseq$ and $\defseq'$:
  \begin{gather*}
      \aniselect(\retrieveinput{\defseq}) = \aniselect(\retrieveinput{\defseq'})
      \ImplieS
       \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{gather*}
\end{definition}
We assume that the objective of the input abstraction $\aniselect$ is to monitor the interference of the input variable $\definputvariable$.}

In the following, we define the abstraction of output states, called output observer, as a map from states to an abstract domain.

\begin{definition}[Output observer]\labdef{output-observer}
  Given a program $\defprogram$, an \emph{output observer} $\aniobserver\in \state \to \state$ is an upper closure operator that abstracts the value of output states.
\end{definition}


Similar to the abstraction of non-interference property into the abstract non-interference, we employ the output observer to define an abstract version of the unused predicate, called $\unusediowrapper$.


\begin{definition}[Abstract Unused]\labdef{abstract-unused}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, an output observer $\aniobserver\in \state \to \state$ the variable $\definputvariable$ is \emph{unused} if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusediowrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{eqnarray*}
\end{definition}

This latter abstract unused predicate allows for further abstractions of the output states, which can be used to determine the impact of variations of the input data on the output states.
This can also be seen as a potential abstract non-interference definition working with non-deterministic programs.
As a drawback, we lose the input abstraction, the tread-off to allow for non-determinism does not permit input state abstractions in the sense of abstract non-interference.
Moreover, such definition generalizes non-exploitability \sidecite{Parolini2024} to non-deterministic programs.

The next result shows that the abstract unused predicate is equivalent to the original unused when the output observer is the identity function.
\begin{remark}[Unused Equivalence]\labremark{unused-predicate-equivalence}
  Whenever $\aniobserver = \identity$, it holds that:
  \begin{gather*}
    \unusedwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{gather*}
\end{remark}

Next we show that abstract non-interference matches the abstract unused predicate when the program is deterministic, assuming the input abstraction is the identity function.

\begin{remark}[Abstract Non-Interference Equivalence]\labremark{ani-predicate-equivalence}
  If $\defprogram$ deterministic and $\aniselect = \identity$, then, it holds that:
  \begin{align*}
    \aniwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{align*}
\end{remark}

\begin{example}
\marginnote{
  \begin{eqnarray*}
    \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = } \\
    &\{
      \tuple\true\anyvalue\dots\tuple\true\true, \\
      &\tuple\true\anyvalue\dots\tuple\true\false, \\
      &\tuple\false\anyvalue\dots\tuple\false\true, \\
      &\tuple\false\anyvalue\dots\tuple\false\false
    \}
  \end{eqnarray*}
}
Let us consider the simplified trace semantics of the program \refprog{school-year}, considering only the variables \texttt{science} and \texttt{passing}.
As this set of traces is non-deterministic, the predicate $\aniwrapper$ would discover interference between the variables \texttt{science} and \texttt{passing}.
In fact, assuming the input and output abstractions are the identity function, the abstract non-interference discovers interference between the input variables.
This can be shown by the two traces
\begin{align*}
  \tuple\true\true&\dots\tuple\true\true
  \\
  \tuple\false\true&\dots\tuple\true\false
\end{align*}
for the variable \texttt{passing}, and these two traces
\begin{align*}
  \tuple\false\true&\dots\tuple\false\true
  \\
  \tuple\false\false&\dots\tuple\false\false
\end{align*}
for the variable \texttt{science}. Specifically, the two traces shows variations of the input value that lead to different output values. However, $\aniwrapper$ does not take into account that such variations in the outcome may be due to the non-determinism.
\end{example}

The input data usage property $\unused$ can be now formally defined as follows:

\begin{definition}[Unused Property]\labdef{unused}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, the \emph{input data usage} property $\unused\in\setofsetof\finiteinfinitesequences$ is defined as:
  \begin{align*}
    \unused\DefeQ&
    \bigsetdef{\tracesemantics\in\tracetype}{\unusediowrapper(\tracesemantics)}
  \end{align*}
\end{definition}

The input data usage property $\unused$ defined above is not subset-closed, we cannot use the standard abstract interpretation framework to soundly prove that a program does not use (some of) its input variables by checking whether an over-approximation of the semantics of the program is included in the unused property.
We solve this problem by lifting the trace semantics of the program to its collecting semantics.

\begin{theorem}[Validation of Unused]\labthm{validation-unused}
  A program $\defprogram$ satisfies a property $\defproperty\in\setofsetof\finiteinfinitesequences$ if and only if its collecting semantics $\collectingsemantics$ belongs to the property $\defproperty$.
  \begin{align*}
    \defprogram \satisfies \unused \IfF \collectingsemantics \subseteq \unused
  \end{align*}
\end{theorem}

\section{Dependency Semantics}
\labsec{dependency-semantics}

We abstract the collecting semantics $\collectingsemantics$ into a set of dependencies between output states of finite traces and between initial and $\statebottom$ for infinite traces.
Formally, the pair of right-left adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ is defined as follows:
%
\begin{align*}
  \dependencyabstraction \IN& \collectingtype \to \dependencytype \\
  \dependencyabstraction(\defsetofsetoftraces) \DefeQ& \setdef{
    \setdef{\inputoutputtuple{\defseq}}{\defseq\in\defsetoftraces}
  }{
    \defsetoftraces\in\defsetofsetoftraces
  }\\
  \dependencyconcretization \IN& \dependencytype \to \collectingtype \\
  \dependencyconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \defsetoftraces\in\setof\finiteinfinitesequences
  }{
    \setdef{\inputoutputtuple\defseq}{\defseq\in\defsetoftraces} \in \defsetofsetofdependencies
  }
\end{align*}
where $\dependencyabstraction$ abstracts away all intermediate states of any trace, preserving the set-structure of $\defsetofsetoftraces$.
The concretization $\dependencyconcretization$ yields all the semantics that share the same output observations of, at least, one of the set of semantics in $\defsetofsetofdependencies$.


\begin{theorem}\labthm{collecting-dependency-galois-connection}
The two adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{collecting}{dependency}
\end{align*}
\end{theorem}
\begin{proof}
  Given a set of semantics $\defsetofsetoftraces\in\setofsetof\finiteinfinitesequences$ and a set of sets of input-output observations $\defsetofsetofdependencies\in\setofsetof\pairofstates$ implied by the abstraction of $\defsetofsetoftraces$, $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies$, we obtain that $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$ since the concretization $\dependencyconcretization$ builds all the possible semantics with the same set of input-output observations of at least one of the starting semantics.
  Moreover, it is easy to note that $\dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
\end{proof}

We now derive the \emph{dependency semantics} $\dependencysemantics$ as an abstraction of the collecting semantics.

\begin{definition}[Dependency Semantics]\labdef{dependency-semantics}
  The \emph{dependency semantics} $\dependencysemanticsnoparam\in\dependencytype$ is defined as:
  \begin{align*}
    \dependencysemanticsnoparam\DefeQ& \dependencyabstraction(\collectingsemanticsnoparam) \\
    % \spacearound{=}& \dependencyabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    % \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=}& \{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

The next result shows that the dependency semantics $\dependencysemantics$ allows a sound and complete verification for proving that an input variable $\definputvariable$ is unused in the program $\defprogram$.

\begin{theorem}\labthm{dependency-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \dependencysemantics \subseteq \dependencyabstraction(\unused)
  \end{math}
\end{theorem}
\begin{proof}
  The implication $(\implies)$ follows from the monotonicity of $\dependencyabstraction$, \refthm{collecting-dependency-galois-connection}, and the definition of $\dependencysemanticsnoparam$, \refeq{dependency}, \ie,
  $
    \collectingsemanticsnoparam \subseteq \bounded \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\bounded)\implies \dependencysemanticsnoparam \subseteq \dependencyabstraction(\bounded)
  $.
  Regarding the other implication $(\Leftarrow)$, from the definition of $\dependencysemanticsnoparam$ and the property of \refthm{collecting-dependency-galois-connection}, we obtain $\dependencysemanticsnoparam \subseteq \dependencyabstraction(\bounded) \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\bounded)\implies \collectingsemanticsnoparam \subseteq \dependencyconcretization(\dependencyabstraction(\bounded))$, which can be written as $\tracesemanticsnoparam \in \dependencyconcretization(\dependencyabstraction(\bounded))$ by the definition of $\collectingsemanticsnoparam$.
  By definition of $\dependencyconcretization$, \refeq{dependency-concretization}, it follows that $\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\tracesemanticsnoparam}\in\dependencyabstraction(\bounded)$.
  Finally, by application of the definition of $\dependencyabstraction$, \refeq{dependency-abstraction}, we obtain $\tracesemanticsnoparam\in\bounded$.
  The conclusion $\collectingsemanticsnoparam \subseteq \bounded$ trivially follows from the definition of $(\subseteq)$.
\end{proof}

\begin{example}
  \marginnote{
    \begin{eqnarray*}
      \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
      = } \\
      &\{
        \tuple\true\anyvalue\dots\tuple\true\true, \\
        &\tuple\true\anyvalue\dots\tuple\true\false, \\
        &\tuple\false\anyvalue\dots\tuple\false\true, \\
        &\tuple\false\anyvalue\dots\tuple\false\false
      \}
    \end{eqnarray*}
  }
  \marginnote{
    \begin{eqnarray*}
      \lefteqn{\dependencysemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
      = } \\
      &\{
        \tuple\true\anyvalue\dots\tuple\true\true, \\
        &\tuple\true\anyvalue\dots\tuple\true\false, \\
        &\tuple\false\anyvalue\dots\tuple\false\true, \\
        &\tuple\false\anyvalue\dots\tuple\false\false
      \}
    \end{eqnarray*}
  }
  We show how the dependency semantics abstracts the trace semantics $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ and $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}$ of the program \refprog{school-year}.
  First, as explained by \refthm{validation-unused}, the trace semantics should be abstracted by the collecting semantics, obtaining $\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}$ and
  $\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}\}$.
  The dependency semantics is then:
  \begin{align*}
     \dependencysemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = &\dependencyabstraction(\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}) \\
     = &\{ \tuple\true\anyvalue, \tuple\true\true, \\
      & \tuple\true\anyvalue, \tuple\true\false, \\
      & \tuple\false\anyvalue, \tuple\false\true, \\
      & \tuple\false\anyvalue, \tuple\false\false
    \}
    \\
    \dependencysemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
    = &\dependencyabstraction(\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}) \\
    = &\{ \tuple\true\anyvalue, \tuple\true\true, \\
      &\tuple\true\anyvalue, \tuple\true\false, \\
      &\tuple\false\anyvalue, \tuple\false\true, \\
      &\tuple\false\anyvalue, \tuple\false\false
    \}
  \end{align*}
  The dependency semantics abstracts the trace semantics, preserving the input-output dependencies.
\end{example}

\section{Output Abstraction Semantics}
\labsec{output-abstraction-semantics}

We further abstract the dependency semantics $\dependencysemantics$ into the output-abstraction semantics $\outputsemantics$.
We exploit the output observer $\aniobserver$ to abstract the output states.
Formally, the pair of right-left adjoints $\tuple{\outputabstraction}{\outputconcretization}$ is defined as follows:
%
\begin{align*}
  \outputabstraction \IN& \dependencytype \to \outputtype \\
  \outputabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setdef{
      \tuple{\retrieveinput{\defstate}}{\outputobs(\retrieveoutput{\defstate})}
    }{
      \inputoutputtuple{\defstate}\in\defsetofdependencies
    }
  }{
    \defsetofdependencies \in \defsetofsetofdependencies
  }\\
  \outputconcretization \IN& \outputtype \to \dependencytype \\
  \outputconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setjoin \setdef{
      \defsetofdependencies' \subseteq
      \setdef{
        \tuple{\retrieveinput\defstate}{\retrieveoutput\defstate'}
      }{
        \retrieveoutput{\defstate} = \outputobs(\retrieveoutput{\defstate'})
      }
    }{
      \inputoutputtuple{\defstate} \in \defsetofdependencies
    }
  }{
    \defsetofdependencies\in\defsetofsetofdependencies
  }
\end{align*}
where $\outputabstraction$ abstracts the output states of the dependencies and $\outputconcretization$ concretizes the set of dependencies that share the same set of output observations.

\begin{theorem}\labthm{dependency-output-galois-connection}
  The two adjoints $\tuple{\outputabstraction}{\outputconcretization}$ form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{dependency}{output}
\end{align*}
\end{theorem}

We now derive the \emph{output-abstraction semantics} $\outputsemantics$ as an abstraction of the dependency semantics.

\begin{definition}[Output Abstraction Semantics]\labdef{inputoutput-abstraction-semantics}
  The \emph{output-abstraction semantics} $\outputsemanticsnoparam\in\outputtype$ is defined as:
  \begin{align*}
    \outputsemanticsnoparam\DefeQ&\outputabstraction(\dependencysemanticsnoparam) \\
    % \spacearound{=}&\outputabstraction(\{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}) \\
    \spacearound{=}&
    \{\spacearound{
      \setdef{
        \tuple{\retrieveinput{\deftrace}}{\outputobs(\retrieveoutput{\deftrace})}
      }{
        \deftrace \in \tracesemanticsnoparam
      }
    }\}
  \end{align*}
\end{definition}

The next result shows that the output-abstraction semantics $\outputsemantics$ allows a sound and complete verification for proving that an input variable $\definputvariable$ is unused in the program $\defprogram$.

\begin{theorem}\labthm{output-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\unused))
  \end{math}
\end{theorem}

We show the unused property $\unused$ derived from the dependency and output-abstraction semantics.
It is interesting to note that removing intermediate states and abstracting output states allows to rewrite the unused property as was originally proposed by \sidetextcite{Urban2018}. That is, the output abstraction and intermediate states are handled at a semantics level rather than in the property definition.

\begin{remark} The abstraction $\outputabstraction\circ\dependencyabstraction$ of the unused property $\unused$ is defined as:
    \begin{gather*}
      \bigsetdef{\defsetofdependencies\in\setof\pairofstates}{
    \forall
      \inputoutputtuple\defstate\in\defsetofdependencies, \defvalue\in\values
    .\spacer
      \retrieveinput{\defstate}(\definputvariable) \neq \defvalue \ImplieS \\
      \exists
      \inputoutputtuple{\defstate'}\in\defsetofdependencies
      .\spacer
        \retrieveinput{\defstate'} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate}
        \LanD
        \retrieveinput{\defstate'}(\definputvariable) = \defvalue \\
        \LanD
       \retrieveoutput{\defstate} =\retrieveoutput{\defstate'}
      }
  \end{gather*}
\end{remark}

\section{Summary}
\labsec{input-data-usage-summary}

In this chapter, we introduced the notion of input data usage and define a generalized version based on the definition of abstract non-interference.
We presented the hierarchy of semantics that allows reasoning about the usage of input variables.
In the next chapter, we define a quantitative counterpart of the input data usage, able to measure the impact of variations in the input data on the outcome of a program.
