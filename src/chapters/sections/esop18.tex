\chapter{Input Data Usage}
\labch{input-data-usage}


In this chapter, we introduce the notion of input data usage as proposed by \textcite{Urban2018}.
In particular, we include output abstractions in the definition of an unused input variable, obtaining a more general definition.
Then, we present a \emph{sound and complete} hierarchy of semantics that contains only, and exactly, the information needed to reason about the usage of input variables.
Later in the next chapters, we will define a quantitative measure of usage of input variables, extending the qualitative notion presented in this chapter.

\emph{Dans ce chapitre, nous introduisons la notion d'utilisation des données d'entrée comme proposé par \sidetextcite{Urban2018}. En particulier, nous incluons des abstractions de sortie dans la définition d'une variable d'entrée inutilisée, obtenant ainsi une définition plus générale. Ensuite, nous présentons une hiérarchie \emph{correcte et complète} de sémantiques qui contiennent uniquement et exactement les informations nécessaires pour raisonner sur l'utilisation des variables d'entrée. Plus tard, dans les chapitres suivants, nous définirons une mesure quantitative de l'utilisation des variables d'entrée, en étendant la notion qualitative présentée dans ce chapitre.}

\section{Input Data Usage}
\labsec{input-data-usage}

\marginnote[*2]{Given a program $\defprogram$, its semantics is defined by the trace semantics $\tracesemantics\in\tracetype$, that is, the set of finite and infinite traces of the program $\defprogram$.}
Originally introduced by \textcite{Urban2018}, the notion of input data usage is a predicate to determine whether the input variable $\definputvariable\in\inputvariables$ is used in the computation of the program's output. It consists in a predicate
\[
  \unusedwrapper \in \tracetype \to \B
\]
that holds whenever the input variable $\definputvariable\in\inputvariables$ is not used by the program under evaluation.


\marginnote{
  Let $\deftrace\in\finiteinfinitesequences$ be a trace, $\retrieveinput{\deftrace}\in\state$ refers to the initial state and $\retrieveoutput{\deftrace}\in\stateandbottom$ to the final one if $\deftrace$ is of finite length, otherwise $\statebottom$ for non-terminating traces.
}
\begin{definition}[Unused]\labdef{unused-predicate}
  Given a program $\defprogram$ and an input variable of interest $\definputvariable\in\inputvariables$, the variable $\definputvariable$ is \emph{unused} if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusedwrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD
        \retrieveoutput{\defseq} = \retrieveoutput{\defseq'}
  \end{eqnarray*}
\end{definition}

Intuitively, an input variable $\definputvariable$ is unused if all feasible outcomes $\retrieveoutput{\defseq}$ are feasible from all possible initial values of $\definputvariable$.
That is, for all possible initial values $\defvalue$ that differ from the initial value of $\definputvariable$ in the trace $\defseq$, there exists another trace $\defseq'$ with initial value $\defvalue$ for $\definputvariable$ that leads to the same output $\retrieveoutput\defseq$.

\begin{example}\labexample{school-year}
\begin{marginlisting}[*-9]
  \caption{Program to check if a student passed the school year.}
  \labprog{school-year}
  \vspace{2\lineheight}
\begin{lstlisting}[language=Python,escapechar=|]
is_passed(eng, math, science,
    bonus):
  passing = True;
  if not eng:
    eng = False;|\labline{err1}|
  if not math:
    passing = bonus;
  if not math:|\labline{err2}|
    passing = bonus;
\end{lstlisting}
\end{marginlisting}
Let us consider the example program presented in \textcite{Urban2018}, \cf{} \refprog{school-year}.
Based on the boolean-valued input variables \texttt{eng}, \texttt{math}, \texttt{science}, and \texttt{bonus}.
The program should determine whether a student has passed the year or not, and store the result in the variable \texttt{passing}. Additionally, the student is allowed a bonus to help with math and science.
However, there are two mistakes in the program: the first conditional statement should be \texttt{passing = False} (\cf{} \refline{err1}), and the third condition should be \texttt{not science} instead of \texttt{not math} (\cf{} \refline{err2}).
These two mistakes cause the variables \texttt{eng} and \texttt{science} to be unused by \refprog{school-year}.
Let us consider the input variable \texttt{science}.
The trace semantics of the program simplified to consider only the variables \texttt{science} and \texttt{passing} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  =
  \left\{
    \begin{array}{l}
      \tuple\true\anyvalue\rightarrow\tuple\true\true, \\
      \tuple\true\anyvalue\rightarrow\tuple\true\false, \\
      \tuple\false\anyvalue\rightarrow\tuple\false\true, \\
      \tuple\false\anyvalue\rightarrow\tuple\false\false
    \end{array}
  \right\}
\end{align*}
where each state $\tuple{\defvalue_1}{\defvalue_2}$ shows the boolean value $\defvalue_1$ of \texttt{science} and $\defvalue_2$ of \texttt{passing}. The symbol $\anyvalue$ denotes any boolean value. We omit the intermediate states for brevity, only showing input-output dependencies.
The input variable \texttt{science} is unused, since each result value for \texttt{passing} is feasible from all possible initial values of \texttt{science}.

Instead, if we consider the variable \texttt{math}, the simplified trace semantics considering only the variables \texttt{math} and \texttt{passing} is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}
  =
  \left\{
    \begin{array}{l}
    \tuple\true\anyvalue\rightarrow\tuple\true\true, \\
    \tuple\false\anyvalue\rightarrow\tuple\false\true, \\
    \tuple\false\anyvalue\rightarrow\tuple\false\false
  \end{array}
  \right\}
\end{align*}
The input variable \texttt{math} is used, since the result value for \texttt{passing} is not feasible from all possible initial values of \texttt{math}.
Indeed, only the initial state $\tuple\false\anyvalue$ yields the result value $\false$ for \texttt{passing} (in the final state $\tuple\false\false$).
\end{example}

\begin{example}
  \begin{marginlisting}
    \caption{Syntactic versus semantic usage of the input variable \texttt{x}.}
    \labprog{syntactic-vs-semantic-usage}
    \vspace{2\lineheight}
  \begin{lstlisting}[language=Python]
x_plus_rand(x):
  return x + rand();
\end{lstlisting}
  \end{marginlisting}
With this second example we highlight the difference between the syntactic and semantic meaning of using a variable. Indeed, a variable could be syntactically used in the program, \ie present in the code, but it could be semantically unused, \ie it does not affect the computation of the program; and vice versa.
Consider \refprog{syntactic-vs-semantic-usage}, where the input variable \texttt{x} is a non-negative integer.
The variable \texttt{x} is syntactically used by the program, as it is present in the return statement.
However, the variable \texttt{x} is semantically unused if we consider machine integers wrapped up to $\texttt{max\_int}\in\N$.
This difference can be clearly seen by studying the trace semantics of the program. In case of machine integers the trace semantics is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}}
  =
  \setdef{
    \langle{x}\rangle\rightarrow\langle{x+r \mod \texttt{max\_int}}\rangle
  }{x, r \in \N}
\end{align*}
where $x\in\N$ denotes the value of the input variable \texttt{x} and $r\in\N$ a random integer from the \texttt{rand()} function.
In this case, any outcome value $x+r \mod \texttt{max\_int}$ is feasible from any initial value of \texttt{x}.
Even if $x$ is bigger than a given outcome $z$, the result is still feasible as we can take a positive $r = \texttt{max\_int} - x + z$ to make the wrapped sum $x + r \mod \texttt{max\_int} = z$.

On the other hand, if we consider unbounded positive integers, the trace semantics is:
\begin{align*}
  \tracesemanticsnoparam\semanticsof{\texttt{x\_plus\_rand}}
  =
  \setdef{
    \langle{x}\rangle\rightarrow\langle{x+r}\rangle
  }{x, r \in \N}
\end{align*}
In such instance, for any outcome value $x+r$, only initial values of \texttt{x} that are equal or smaller than $x+r$ may generate such outcome.
For instance, if the outcome is 42, an initial value of 41 is feasible as it exists a random value $r = 1$ that makes the sum $41 + 1 = 42$. Instead, an initial value of 43 is not feasible as there is no positive random value $r$ that makes the sum $43 + r = 42$.
% \pgfplotstableread[]{
% x y
% 0 81
% 1 15
% 2 5
% 3 97
% 4 39
% 5 36
% 6 34
% 7 24
% 8 102
% 9 22
% 10 96
% 11 105
% 12 81
% 13 24
% 14 89
% 15 69
% 16 20
% 17 20
% 18 29
% 19 46
% 20 49
% 21 85
% 22 99
% 23 26
% 24 95
% 25 50
% 26 117
% 27 110
% 28 117
% 29 98
% 30 83
% 31 59
% 32 89
% 33 108
% 34 69
% 35 35
% 36 133
% 37 57
% 38 127
% 39 93
% 40 83
% 41 76
% 42 61
% 43 70
% 44 141
% 45 88
% 46 59
% 47 58
% 48 96
% 49 61
% 50 95
% 51 95
% 52 129
% 53 86
% 54 59
% 55 148
% 56 114
% 57 125
% 58 73
% 59 107
% 60 70
% 61 131
% 62 99
% 63 143
% 64 143
% 65 111
% 66 139
% 67 91
% 68 158
% 69 77
% 70 75
% 71 155
% 72 101
% 73 171
% 74 111
% 75 85
% 76 105
% 77 89
% 78 126
% 79 114
% 80 138
% 81 162
% 82 128
% 83 103
% 84 131
% 85 130
% 86 112
% 87 172
% 88 122
% 89 178
% 90 177
% 91 173
% 92 101
% 93 170
% 94 175
% 95 116
% 96 164
% 97 190
% 98 129
% 99 119
% }\advdata
% \begin{figure}[H]
% \centering
% \caption{Scatterplot of Advertising versus Sales Data}
% \begin{tikzpicture}
% \begin{axis}[
% axis lines = left,
% xlabel = {Input Variable \texttt{x}},
% ylabel = {Program Outcome}
% ]
% \addplot[
% mark=*,only marks,
% point meta =explicit symbolic,
% nodes near coords,
% ]
% table[x=x,y=y]{\advdata};
% \end{axis}
% \end{tikzpicture}
% \end{figure}
\end{example}

\nrefdef{unused-predicate} is significant as it determines whether a given input variable is used or not, even in the presence of non-deterministic programs%
\sidenote[][*-8]{%
  In \refexample{school-year} the trace semantics where we consider subsets of input variables, \cf{} $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ and $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{math}}$, are two non-deterministic sets of traces.
  %
  This can be easily seen by considering the two traces:
  \begin{eqnarray*}
    \lefteqn{\tuple\true\true\rightarrow\tuple\true\true} \\
       &\in \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}} \\
    \lefteqn{\tuple\true\true\rightarrow\tuple\true\false} \\
       &\in \tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
  \end{eqnarray*}
  where both start from the same initial state $\tuple\true\true$ and have different outcomes.}.
Furthermore, the next example shows that the unused predicate is termination aware.
Indeed, termination is a possible outcome of a program, and thus a variable should be unused if it does not affect the termination as well as the result of the program.

\begin{example}\labexample{non-termination}
  \begin{marginlisting}
    \caption{Program that does not terminate for positive values of \texttt{x}.}
    \labprog{non-termination}
    \vspace{2\lineheight}
  \begin{lstlisting}
non_termination(x):
  while x > 0:
    x = x + 1;
\end{lstlisting}
  \end{marginlisting}
  Consider the \refprog{non-termination} defined on the side. The program does not terminate for positive values of \texttt{x}. Instead, it terminates without modifying \texttt{x} on the value of $0$ or negative. The trace semantics is the following:
  \begin{align*}
    \tracesemanticsnoparam\semanticsof{\texttt{non\_termination}}
    =
    \{
      \langle{<}\rangle\rightarrow\langle{<}\rangle,
      \langle{0}\rangle\rightarrow\langle{0}\rangle,
      \langle{>}\rangle\rightarrow\dots
    \}
  \end{align*}
  where the symbol $<$ denotes a negative value and $>$ a positive one. When the program is provided a positive value for \texttt{x}, it does not terminate and the respective traces are all of infinite length.

  In this example we conclude that the variable \texttt{x} is used since the non-termination is feasible only from positive values of \texttt{x}.
\end{example}

\section{Abstract Input Data Usage}
\labsec{abstract-input-data-usage}

Inspired by the definition of abstract non-interference (ANI) \sidecite{Giacobazzi2018,Mastroeni2023}, we introduce a generalized version of the unused predicate.
That is, a weaker version of the unused predicate that abstracts the output states, allowing for a more general definition of the unused property.
Later, we will define the quantitative measure of input data usage, and use the abstraction of output states to determine numerical values from output states.

\marginnote{
\begin{definition}[Abstract Non-Interference]\labdef{ani-predicate}
  The abstract non-interference predicate $\aniwrapper$ holds if, for any two traces $\defseq$ and $\defseq'$:
  \begin{gather*}
      \aniselect(\retrieveinput{\defseq}) = \aniselect(\retrieveinput{\defseq'})
      \ImplieS
       \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{gather*}
where $\aniselect$ and $\aniobserver$ are upper closure operators on program states to abstract input and output states respectively.
\end{definition}
% We assume that the objective of the input abstraction $\aniselect$ is to monitor the interference of the input variable $\definputvariable$.
}

In the following, we define the abstraction of output states, called output observer, as a map from states to an abstract domain.


\begin{definition}[Output Observer]\labdef{output-observer}
  Given a program $\defprogram$, an \emph{output observer} $\aniobserver\in \stateandbottom \to \stateandbottom$ is an upper closure operator (\refdef*{upper-closure-operator}) that abstracts the output states.
\end{definition}


We employ the output observer to define an abstract version of the unused predicate, called $\unusediowrapper$, as follows:


\begin{definition}[Abstract Unused]\labdef{abstract-unused}
  Given a program $\defprogram$, an output observer $\aniobserver\in \state \to \state$, and an input variable of interest $\definputvariable\in\inputvariables$, the variable $\definputvariable$ is (abstractly) \emph{unused} if the following predicate holds:
  \begin{eqnarray*}
    \lefteqn{\unusediowrapper(\tracesemantics) \DefifF} \\
    & &\forall
      \defseq\in\tracesemantics, \defvalue\in\values
    .\spacer
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      & &\exists
        \defseq'\in\tracesemantics
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD
        \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{eqnarray*}
\end{definition}

This abstract unused predicate allows for further abstractions of the output states, which permits a more general definition of the unused property.
For instance, the output observer could identify which variable is to consider as the outcome of the program and abstract away the other variables. Another use case could be to abstract the output states into the parity of their variables, or even into the sign. In such case, a variable could be used with respect to \nrefdef{unused-predicate} but unused with respect to \nrefdef{abstract-unused}.

\begin{example}
  \begin{marginlisting}
    \caption{The variable \texttt{x} is used but not abstractly.}
    \labprog{parity}
    \vspace{2\lineheight}
  \begin{lstlisting}
parity(x):
  return 2 * x;
\end{lstlisting}
  \end{marginlisting}
  The \refprog{parity} doubles the values of the input variable \texttt{x}. If we consider \nrefdef{unused-predicate}, the variable \texttt{x} is used as for any output value we consider, \eg{} the output 4 from an input value of $\texttt{x}=2$, it does not exist a trace that starts with $x\neq 2$ and terminates with output 4. Instead, by considering the parity of the output value, the \refprog{parity} does not use the variable \texttt{x} as the only possible outcome is ``even''.
\end{example}

\nrefdef{abstract-unused} can also be seen as a potential abstract non-interference definition working with non-deterministic programs.
As a drawback, we lose the input abstraction: the tread-off allows non-determinism but does not permit input state abstractions in the sense of abstract non-interference.
The reason is that to take into account non-determinism, for any value of the input variable $\definputvariable$, we need to consider all possible traces that start from a different initial value.
Such low-level detail cannot be captured anymore by the input abstraction employed in the definition of abstract non-interference.

The next result shows that the abstract unused predicate is equivalent to the original unused when the output observer is the identity function.
\begin{proposition}[Unused Equivalence]\labprop{unused-predicate-equivalence}
  Whenever $\aniobserver = \identity$, it holds that:
  \begin{gather*}
    \unusedwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{gather*}
\end{proposition}
\begin{proof}
  The proof is straightforward by the definition of the abstract unused predicate, \nrefdef{abstract-unused}, and the unused predicate, \nrefdef{unused-predicate}.
  Indeed, the output observer $\aniobserver = \identity$ does not abstract the output states, and thus the two predicates are equivalent.
\end{proof}

Next we show that abstract non-interference matches the abstract unused predicate when the program is deterministic, assuming the input abstraction allows only the value of the variable $\definputvariable$, returning $\top$ in the other cases.

\begin{proposition}[Abstract Non-Interference Equivalence]\labprop{ani-predicate-equivalence}
  If $\defprogram$ deterministic and the input abstraction is defined as:
  \begin{align*}
    \aniselect(\defstate) \spacearound= \lambda \texttt{j}. \spacer
    \begin{cases}
      \defstate(\texttt{j}) & \text{if } \texttt{j} \neq \definputvariable \\
      \top & \text{otherwise}
    \end{cases}
  \end{align*}
  then, it holds that:
  \begin{align*}
    \aniwrapper(\tracesemantics) \IfF \unusediowrapper(\tracesemantics)
  \end{align*}
\end{proposition}
\begin{proof}
  By hypothesis, the program $\defprogram$ is deterministic. Thus, whenever two traces $\deftrace,\deftrace' \in \tracesemantics$ share the same input state, they also share the same output state, \ie $\retrieveinput\deftrace = \retrieveinput\deftrace' \implies \retrieveoutput\deftrace = \retrieveoutput\deftrace'$.
  To show ($\implies$), we assume $\aniwrapper$.
  For any two traces $\deftrace$ \dots \denis{SOno arrivato qui} the input variable $\definputvariable$ does not interfere with the output states (up to the abstraction $\aniobserver$).
  It is easy to note that, even without the assumption on the determinism of the program, if the variable $\definputvariable$ does not interfere, then it is unused in the sense of \nrefdef{abstract-unused}.

  On the other hand, to prove ($\Leftarrow$), we need to show that $\forall \deftrace,\deftrace' \in \tracesemantics.\spacer \retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput\deftrace' \implies \aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput\deftrace')$.
  From the assumption that the program $\defprogram$ is deterministic, we have that $\retrieveinput\deftrace = \retrieveinput\deftrace'$ implies $\retrieveoutput\deftrace = \retrieveoutput\deftrace'$. Note that, $\retrieveoutput\deftrace = \retrieveoutput\deftrace'$ implies $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput\deftrace')$ as $\aniobserver$ is an upper-closure operator.
  Thus, we only need to prove that the output states are equivalent whenever $\retrieveinput\deftrace(\definputvariable) \neq \retrieveinput\deftrace'(\definputvariable)$.
  From the definition of the abstract unused predicate, it holds that if $\retrieveinput\deftrace(\definputvariable) \neq \retrieveinput\deftrace'(\definputvariable)$ and $\retrieveinput\deftrace \stateeq{\inputvariableswithouti} \retrieveinput\deftrace'$, then $\aniobserver(\retrieveoutput\deftrace) = \aniobserver(\retrieveoutput\deftrace')$.
  Thus, the output states are equivalent and $\aniwrapper$ holds.
\end{proof}

\begin{example}
\marginnote{
  \begin{eqnarray*}
    \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = } \\
    & \left\{
      \begin{array}{l}
        \tuple\true\anyvalue\dots\tuple\true\true, \\
        \tuple\true\anyvalue\dots\tuple\true\false, \\
        \tuple\false\anyvalue\dots\tuple\false\true, \\
        \tuple\false\anyvalue\dots\tuple\false\false
      \end{array}
    \right\}
  \end{eqnarray*}
}
Let us consider the simplified trace semantics of the program \refprog{school-year}, considering only the variables \texttt{science} and \texttt{passing}.
As this set of traces is non-deterministic, the predicate $\aniwrapper$ would discover that the variable \texttt{science} interferes with the output states.
In fact, assuming:
\begin{align*}
  \eta_{\texttt{science}}(\defstate) \spacearound{&=} \lambda \texttt{j}. \spacer
  \begin{cases}
    \defstate(\texttt{j}) & \text{if } \texttt{j} \neq \texttt{science} \\
    \top & \text{otherwise}
  \end{cases}\\
  \aniobserver(\defstate) \spacearound{&=} \defstate
\end{align*}
the predicate of  abstract non-interference does not hold for the variable \texttt{science}.
This can be shown by the two traces
\begin{align*}
  \tuple\true\true&\dots\tuple\false\true
  \\
  \tuple\true\true&\dots\tuple\false\false
\end{align*}
where the output states are different, but the input states are the same.
Indeed, $\aniwrapper$ does not take into account that such variation in the outcome may be due to the non-determinism and classifies the variable \texttt{science} as an interfering variable.
\end{example}

We show that whenever a variable is not used, it is also abstractly unused.
In other words, the abstract unused predicate weakens the unused predicate.
\begin{lemma}[Unused Implies Abstract Unused]\lablemma{unused-implies-abstract-unused}
  If $\unusedwrapper(\tracesemantics)$ holds, then $\unusediowrapper(\tracesemantics)$ holds.
\end{lemma}
\begin{proof}
  \denis{todo}
\end{proof}

The next result instead shows that whenever a variable is unused, it means that for any abstract output and input value, it exists a trace with that input value that leads to the same output value.

\begin{proposition}\labprop{abstract-unused-property}
  If $\unusediowrapper(\tracesemantics)$ holds, then for any output state $\retrieveoutput{\defseq}\in\stateandbottom$ it holds that:
  \begin{gather*}
      \not\exists
        \defseq'\in\tracesemantics.\spacer
        \aniobserver(\retrieveoutput\defseq) = \aniobserver(\retrieveoutput{\defseq'}) \\
      \lor \\
      \foralldef{\defvalue\in\values}{\existsdef{\defseq'\in\tracesemantics}{
        \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})}}
  \end{gather*}
\end{proposition}
\begin{proof}
  \denis{todo}
\end{proof}


\section{Unused Property of Programs}
\labsec{unused-property-of-programs}

In this section, we state the \emph{unused property} as a property of programs.
Whenever a program does not use the input variable $\definputvariable$, the trace semantics of the program belongs to the unused property. The unused property is defined as follows:

\begin{definition}[Unused Property]\labdef{unused}
  Given a program $\defprogram$, and an input variable of interest $\definputvariable\in\inputvariables$, the \emph{unused property} $\unused\in\setofsetof\finiteinfinitesequences$ is:
  \begin{align*}
    \unused\DefeQ&
    \setdef{\tracesemantics\in\tracetype}{\unusediowrapper(\tracesemantics)}
  \end{align*}
\end{definition}

The input data usage property $\unused$ defined above is not subset-closed, we cannot use the standard abstract interpretation framework to soundly prove that a program does not use (some of) its input variables by checking whether an over-approximation of the semantics of the program is included in the unused property.
We solve this problem by lifting the trace semantics of the program to its collecting semantics.
Therefore, a program $\defprogram$ satisfies the unused property $\unused\in\setofsetof\finiteinfinitesequences$ if and only if its collecting semantics $\collectingsemantics$ belongs to $\unused$, formally:
\begin{align}\labeq{validation-unused}
  \defprogram \satisfies \unused \IfF \collectingsemantics \subseteq \unused
\end{align}
We develop our hierarchy of semantics to reason about the unused property starting from the collecting semantics.

\section{Dependency Semantics}
\labsec{dependency-semantics}

We abstract the collecting semantics $\collectingsemanticsnoparam\in\collectingtype$ into a set of dependencies between output states of finite traces and between initial and $\statebottom$ for infinite traces.
Formally, the pair of right-left adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ is defined as follows:
%
\begin{definition}[Right-Left Adjoints for the Dependency Semantics]\labdef{right-left-adjoints-for-the-dependency-semantics}
\begin{align*}
  \dependencyabstraction \IN& \collectingtype \to \dependencytype \\
  \dependencyabstraction(\defsetofsetoftraces) \DefeQ& \setdef{
    \setdef{\inputoutputtuple{\defseq}}{\defseq\in\defsetoftraces}
  }{
    \defsetoftraces\in\defsetofsetoftraces
  }\\
  \dependencyconcretization \IN& \dependencytype \to \collectingtype \\
  \dependencyconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \defsetoftraces\in\setof\finiteinfinitesequences
  }{
    \setdef{\inputoutputtuple\defseq}{\defseq\in\defsetoftraces} \in \defsetofsetofdependencies
  }
\end{align*}
\end{definition}
The function $\dependencyabstraction$ abstracts away all intermediate states of any trace, preserving the set-structure of $\defsetofsetoftraces$.
The concretization $\dependencyconcretization$ yields all the semantics that share the same output observations of, at least, one of the set of semantics in $\defsetofsetofdependencies$.


\begin{theorem}\labthm{collecting-dependency-galois-connection}
The two adjoints $\tuple{\dependencyabstraction}{\dependencyconcretization}$ form a \emph{Galois connection}:
\begin{align*}
  \galoisbetweensemantics{collecting}{dependency}
\end{align*}
\end{theorem}
\begin{proof}
  Given a set of semantics $\defsetofsetoftraces\in\setofsetof\finiteinfinitesequences$ and a set of sets of input-output observations $\defsetofsetofdependencies\in\setofsetof\pairofstates$ implied by the abstraction of $\defsetofsetoftraces$, $\dependencyabstraction(\defsetofsetoftraces)\subseteq \defsetofsetofdependencies$, we obtain that $\defsetofsetoftraces\subseteq\dependencyconcretization(\defsetofsetofdependencies)$ since the concretization $\dependencyconcretization$ builds all the possible semantics with the same set of input-output observations of at least one of the starting semantics.
  Moreover, it is easy to note that $\dependencyabstraction(\dependencyconcretization(\defsetofsetofdependencies)) = \defsetofsetofdependencies$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
\end{proof}

We now derive the \emph{dependency semantics} $\dependencysemantics$ as an abstraction of the collecting semantics.

\begin{definition}[Dependency Semantics]\labdef{dependency-semantics}
  The \emph{dependency semantics} $\dependencysemanticsnoparam\in\dependencytype$ is defined as:
  \begin{align*}
    \dependencysemanticsnoparam\DefeQ& \dependencyabstraction(\collectingsemanticsnoparam) \\
    % \spacearound{=}& \dependencyabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    % \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=}& \{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

The next result shows that the dependency semantics $\dependencysemantics$ allows a sound and complete verification that an input variable $\definputvariable$ is unused by the program $\defprogram$.

\begin{theorem}\labthm{dependency-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \dependencysemantics \subseteq \dependencyabstraction(\unused)
  \end{math}
\end{theorem}
\begin{proof}
  The implication $(\implies)$ follows from the monotonicity of $\dependencyabstraction$, as an implication from the fact that the two adjoints $\tuple\dependencyabstraction\dependencyconcretization$ form a Galois connection (\cf{} \refthm{collecting-dependency-galois-connection}), and \refdef{dependency-semantics} of $\dependencysemanticsnoparam$.
  Obtaining
  $
    \collectingsemanticsnoparam \subseteq \unused \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\unused)\implies \dependencysemanticsnoparam \subseteq \dependencyabstraction(\unused)
  $.
%
  Regarding the other implication $(\Leftarrow)$, from \refdef{dependency-semantics} of $\dependencysemanticsnoparam$ and the property of \refthm{collecting-dependency-galois-connection}, we obtain $\dependencysemanticsnoparam \subseteq \dependencyabstraction(\unused) \implies \dependencyabstraction(\collectingsemanticsnoparam) \subseteq \dependencyabstraction(\unused)\implies \collectingsemanticsnoparam \subseteq \dependencyconcretization(\dependencyabstraction(\unused))$, which can be written as $\tracesemanticsnoparam \in \dependencyconcretization(\dependencyabstraction(\unused))$ by the definition of $\collectingsemanticsnoparam$.
  By \refdef{right-left-adjoints-for-the-dependency-semantics} of $\dependencyconcretization$ it follows that $\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\tracesemanticsnoparam}\in\dependencyabstraction(\unused)$.
  Finally, by application of \refdef{right-left-adjoints-for-the-dependency-semantics} of $\dependencyabstraction$ we obtain $\tracesemanticsnoparam\in\unused$.
  The conclusion $\collectingsemanticsnoparam \subseteq \unused$ trivially follows from the definition of the subset inclusion $(\subseteq)$.
\end{proof}

\begin{example}
  \marginnote{
  \begin{eqnarray*}
    \lefteqn{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    = } \\
    & \left\{
      \begin{array}{l}
        \tuple\true\anyvalue\dots\tuple\true\true, \\
        \tuple\true\anyvalue\dots\tuple\true\false, \\
        \tuple\false\anyvalue\dots\tuple\false\true, \\
        \tuple\false\anyvalue\dots\tuple\false\false
      \end{array}
    \right\}
  \end{eqnarray*}
}
  We show how the dependency semantics abstracts the trace semantics $\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}$ of \refprog{school-year}.
  First, as required by \refeq{validation-unused}, the trace semantics should be abstracted first by the collecting semantics, obtaining $\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}$.
  The dependency semantics is then:
  \begin{align*}
     \dependencysemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}
    \spacearound{&=} \dependencyabstraction(\{\tracesemanticsnoparam\semanticsof{\texttt{is\_passed}_\texttt{science}}\}) \\
    \spacearound{&=} \left\{\left\{
      \begin{array}{l}
        \tuple{\tuple\true\anyvalue}{\tuple\true\true}, \\
        \tuple{\tuple\true\anyvalue}{\tuple\true\false}, \\
        \tuple{\tuple\false\anyvalue}{\tuple\false\true}, \\
        \tuple{\tuple\false\anyvalue}{\tuple\false\false}
      \end{array}
    \right\}\right\}
  \end{align*}
  The dependency semantics abstracts the trace semantics, preserving the input-output dependencies.
\end{example}

\section{Output Abstraction Semantics}
\labsec{output-abstraction-semantics}

We further abstract the dependency semantics $\dependencysemanticsnoparam$ into the output-abstraction semantics $\outputsemanticsnoparam$.
We exploit the output observer $\aniobserver$ to abstract the output states.
Formally, the pair of right-left adjoints $\tuple{\outputabstraction}{\outputconcretization}$ is defined as:
%
\begin{definition}[Right-Left Adjoints for the Output Abstraction Semantics]\labdef{right-left-adjoints-for-the-output-abstraction-semantics}
\begin{align*}
  \outputabstraction \IN& \dependencytype \to \outputtype \\
  \outputabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setdef{
      \tuple{\retrieveinput{\defstate}}{\outputobs(\retrieveoutput{\defstate})}
    }{
      \inputoutputtuple{\defstate}\in\defsetofdependencies
    }
  }{
    \defsetofdependencies \in \defsetofsetofdependencies
  }\\
  \outputconcretization \IN& \outputtype \to \dependencytype \\
  \outputconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setjoin \setdef{
      \defsetofdependencies' \subseteq
      \setdef{
        \tuple{\retrieveinput\defstate}{\retrieveoutput\defstate'}
      }{
        \retrieveoutput{\defstate} = \outputobs(\retrieveoutput{\defstate'})
      }
    }{
      \inputoutputtuple{\defstate} \in \defsetofdependencies
    }
  }{
    \defsetofdependencies\in\defsetofsetofdependencies
  }
\end{align*}
\end{definition}
The function $\outputabstraction$ abstracts the output states of the dependencies and $\outputconcretization$ concretizes the set of dependencies that share the same set of output observations.

\begin{theorem}\labthm{dependency-output-galois-connection}
  The two adjoints $\tuple{\outputabstraction}{\outputconcretization}$ form a \emph{Galois connection}:
\begin{align*}
  \galoisbetweensemantics{dependency}{output}
\end{align*}
\end{theorem}
\begin{proof}
  Given two sets of sets of input-output observations $\defsetofsetofdependencies, \defsetofsetofdependencies\in\dependencytype$ such that $\outputabstraction(\defsetofsetofdependencies)\subseteq\defsetofsetofdependencies'$, we obtain that $\defsetofsetofdependencies\subseteq\outputconcretization(\defsetofsetofdependencies')$ since the concretization $\outputconcretization$ builds all the possible sets of sets of dependencies enhanced with the any amount of output states that result in an output abstraction of $\defsetofsetofdependencies'$.
  On the other hand, we assume that $\defsetofsetofdependencies\subseteq\outputconcretization(\defsetofsetofdependencies')$.
  By the monotonicity of $\outputabstraction$, \cf{} consequence of \refthm{dependency-output-galois-connection}, we obtain that $\outputabstraction(\defsetofsetofdependencies)\subseteq\outputabstraction(\outputconcretization(\defsetofsetofdependencies'))$.
  We note that the concretization $\outputconcretization(\defsetofsetofdependencies')$ builds all the possible sets of dependencies that may have generated the same output observations of each set of dependencies in $\defsetofsetofdependencies'$. By applying the abstraction $\outputabstraction$, for each of the sets of dependencies concretized by $\outputconcretization$, the abstraction returns the original set in $\defsetofsetofdependencies'$. Thus, we have that $\outputabstraction(\outputconcretization(\defsetofsetofdependencies')) = \defsetofsetofdependencies'$, so we conclude with $\outputabstraction(\defsetofsetofdependencies)\subseteq\defsetofsetofdependencies'$.
\end{proof}

We now derive the \emph{output-abstraction semantics} $\outputsemantics$ as an abstraction of the dependency semantics.

\begin{definition}[Output Abstraction Semantics]\labdef{output-abstraction-semantics}
  The \emph{output-abstraction semantics} $\outputsemanticsnoparam\in\outputtype$ is defined as:
  \begin{align*}
    \outputsemanticsnoparam\DefeQ&\outputabstraction(\dependencysemanticsnoparam) \\
    % \spacearound{=}&\outputabstraction(\{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}) \\
    \spacearound{=}&
    \{\spacearound{
      \setdef{
        \tuple{\retrieveinput{\deftrace}}{\outputobs(\retrieveoutput{\deftrace})}
      }{
        \deftrace \in \tracesemanticsnoparam
      }
    }\}
  \end{align*}
\end{definition}

The next result shows that the output-abstraction semantics $\outputsemantics$ allows a sound and complete verification for proving that an input variable $\definputvariable$ is unused in the program $\defprogram$.

\begin{theorem}\labthm{output-validation}
  \begin{math}
    \collectingsemantics \subseteq \unused \IfF \outputsemantics \subseteq \outputabstraction(\dependencyabstraction(\unused))
  \end{math}
\end{theorem}
\begin{proof}
  Similarly to the proof of \refthm{dependency-validation}, the implication $(\implies)$ follows from the monotonicity of $\outputabstraction$ and \refdef{output-abstraction-semantics} of $\outputsemanticsnoparam$.
  The implication $(\Leftarrow)$ follows from the definition of the output-abstraction semantics $\outputsemanticsnoparam$ and the property of \refthm{dependency-output-galois-connection}.
\end{proof}

We show the unused property $\unused$ derived from the dependency and output-abstraction semantics.
It is interesting to note that removing intermediate states and abstracting output states allows to rewrite the unused property as was originally proposed by \sidetextcite{Urban2018}. That is, the output abstraction and intermediate states are handled at a semantics level rather than in the property definition.

\begin{remark} The abstraction $\outputabstraction\circ\dependencyabstraction$ of the unused property $\unused$ is defined as:
    \begin{gather*}
      \bigsetdef{\defsetofdependencies\in\setof\pairofstates}{
    \forall
      \inputoutputtuple\defstate\in\defsetofdependencies, \defvalue\in\values
    .\spacer
      \retrieveinput{\defstate}(\definputvariable) \neq \defvalue \ImplieS \\
      \exists
      \inputoutputtuple{\defstate'}\in\defsetofdependencies
      .\spacer
        \retrieveinput{\defstate'} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate}
        \LanD
        \retrieveinput{\defstate'}(\definputvariable) = \defvalue \\
        \LanD
       \retrieveoutput{\defstate} =\retrieveoutput{\defstate'}
      }
  \end{gather*}
\end{remark}

Note that, the property defined in the remark above is not, per se, a property of programs as by extension it would be a set of program semantics.
Instead, it is a property of output-and-dependency semantics, which is a set of sets of input-output observations.

\section{Summary}
\labsec{input-data-usage-summary}

In this chapter, we introduced the notion of input data usage and define a generalized version based on the definition of abstract non-interference.
We presented the hierarchy of semantics that allows reasoning about the usage of input variables.
In the next chapter, we will define a quantitative counterpart of the input data usage, able to measure the impact of variations in the input data on the outcome of a program. We will exploit the output abstraction to obtain numerical values from the output states.
