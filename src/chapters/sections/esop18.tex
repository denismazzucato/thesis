\chapter{Input Data Usage}
\labch{input-data-usage}


\section{Input Data Usage}
\labsec{input-data-usage}

\begin{definition}[Unused]\labdef{unused-predicate}
  \begin{align*}
    \unusedwrapper(\tracesemanticsnoparam) \DefifF&
    \forall
      \defseq\in\tracesemanticsnoparam, \defvalue\in\values
    .\spacer
      \retrieveinput{\defseq}(\definputvariable) \neq \defvalue \ImplieS \\
      &\exists
        \defseq'\in\tracesemanticsnoparam
      .\spacer
        \retrieveinput{\defseq'} \stateeq{\inputvariableswithouti} \retrieveinput{\defseq}
        \LanD \retrieveinput{\defseq'}(\definputvariable) = \defvalue
        \LanD \retrieveoutput{\defseq} = \retrieveoutput{\defseq'}
  \end{align*}
\end{definition}

\begin{description}
  \item[Output Observer] $\aniobserver \in \state \to \state$ abstraction of output states.
  \item[Input Selection] $\aniselect \in \state \to \state$ abstraction of input states.
\end{description}

\begin{definition}[Abstract Non-Interference]\labdef{ani-predicate}
  This definition is specialized on the $\definputvariable\in\inputvariables$ input variable.
  \begin{align*}
    \aniwrapper(\tracesemanticsnoparam) \DefifF
    \forall
      \defseq, \defseq'\in\tracesemanticsnoparam
    .\spacer
      \aniselect(\retrieveinput{\defseq}) \stateeq{\inputvariableswithouti} \aniselect(\retrieveinput{\defseq'})
      \ImplieS
        \aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{align*}
\end{definition}

Note that such definition does not work with non-deterministic programs.

\begin{definition}[Abstract Unused]\labdef{abstract-unused}
  \begin{align*}
    \unusediowrapper(\tracesemanticsnoparam) \DefifF
    \forall
      \defseq\in\tracesemanticsnoparam, \defstate\in\state
    .\spacer&
      \aniselect(\retrieveinput{\defseq})(\definputvariable) \neq \aniselect(\defstate)(\definputvariable) \ImplieS \\
      \exists
        \defseq'\in\tracesemanticsnoparam
      .\spacer&
        \aniselect(\retrieveinput{\defseq'}) \stateeq{\inputvariableswithouti} \aniselect(\retrieveinput{\defseq})
        \LanD \\
        &\aniselect(\retrieveinput{\defseq'})(\definputvariable) = \aniselect(\defstate)(\definputvariable)
        \LanD \\
        &\aniobserver(\retrieveoutput{\defseq}) = \aniobserver(\retrieveoutput{\defseq'})
  \end{align*}
\end{definition}

This can be seen as a generalization of the abstract non-interference that works with non-deterministic programs.

\begin{remark}[Unused Equivalence]\labremark{unused-predicate-equivalence}
  \begin{gather*}
    \aniobserver \spacearound{=} \aniselect \spacearound{=} \identity \\
    \unusedwrapper(\tracesemanticsnoparam) \IfF \unusediowrapper(\tracesemanticsnoparam)
  \end{gather*}
\end{remark}

\begin{remark}[Abstract Non-Interference Equivalence]\labremark{ani-predicate-equivalence}
  If $\defprogram$ deterministic, then it holds that:
  \begin{align*}
    \aniwrapper(\tracesemanticsnoparam) \IfF \unusediowrapper(\tracesemanticsnoparam)
  \end{align*}
\end{remark}

\begin{definition}[Unused Property]\labdef{unused}
  \begin{align*}
    \unused\DefeQ&
    \setdef{\tracesemanticsnoparam\in\tracetype}{\unusediowrapper(\tracesemanticsnoparam)}
  \end{align*}
\end{definition}


\begin{theorem}[Validation of Unused]\labthm{validation-unused}
  \begin{align*}
    \defprogram \satisfies \unused \IfF \collectingsemantics \subseteq \unused
  \end{align*}
\end{theorem}

\section{Dependency Semantics}
\labsec{dependency-semantics}

\begin{definition}[Adjoints for the Dependency Semantics]
  \labdef{adjoints-dependency-semantics}
  \begin{align*}
    \dependencyabstraction \IN& \collectingtype \to \dependencytype \\
    \dependencyabstraction(\defsetofsetoftraces) \DefeQ& \setdef{
      \setdef{\inputoutputtuple{\defseq}}{\defseq\in\defsetoftraces}
    }{
      \defsetoftraces\in\defsetofsetoftraces
    }\\
    \dependencyconcretization \IN& \dependencytype \to \collectingtype \\
    \dependencyconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
      \defsetoftraces\in\setof\finiteinfinitesequences
    }{
      \setdef{\inputoutputtuple\defseq}{\defseq\in\defsetoftraces} \in \defsetofsetofdependencies
    }
  \end{align*}
\end{definition}

\begin{theorem}\labthm{collecting-dependency-galois-connection}
  The collecting $\collectingsemanticsnoparam$ and dependency $\dependencysemanticsnoparam$ semantics form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{collecting}{dependency}
\end{align*}
\end{theorem}

\begin{definition}[Dependency Semantics]\labdef{dependency-semantics}
  \begin{align*}
    \dependencysemanticsnoparam\DefeQ& \dependencyabstraction(\collectingsemanticsnoparam) \\
    \spacearound{=}& \dependencyabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=}& \{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

\begin{theorem}\labthm{dependency-validation}
  \begin{align*}
    \collectingsemantics \subseteq \unused \IfF \dependencysemantics \subseteq \dependencyabstraction(\unused)
  \end{align*}
\end{theorem}


\section{Input-Output Abstraction Semantics}
\labsec{input-output-abstraction-semantics}


\begin{definition}[Adjoints for the Input-Output Abstraction Semantics]\labdef{adjoints-dependency-semantics}
  \begin{align*}
    \inputoutputabstraction \IN& \dependencytype \to \inputoutputtype \\
    \inputoutputabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
      \setdef{
        \tuple{\inputobs(\retrieveinput{\defstate})}{\outputobs(\retrieveoutput{\defstate})}
      }{
        \inputoutputtuple{\defstate}\in\defsetofdependencies
      }
    }{
      \defsetofdependencies \in \defsetofsetofdependencies
    }\\
    \inputoutputconcretization \IN& \inputoutputtype \to \dependencytype \\
    \inputoutputconcretization(\defsetofsetofdependencies) \DefeQ& \setdef{
      \setjoin \setdef{
        \defsetofdependencies' \subseteq
        \setdef{
          \inputoutputtuple{\defstate}
        }{
          \retrieveinput{\defvalue} = \inputobs(\retrieveinput{\defstate})
          \land
          \retrieveoutput{\defvalue} = \outputobs(\retrieveoutput{\defstate})
        }
        \\ &\qquad
      }{
        \inputoutputtuple{\defstate} \in \defsetofdependencies
      }
    }{
      \defsetofdependencies\in\defsetofsetofdependencies
    }
  \end{align*}
\end{definition}

\begin{theorem}\labthm{dependency-inputoutput-galois-connection}
  The dependency $\dependencysemanticsnoparam$ and input-output abstraction $\inputoutputsemanticsnoparam$ semantics form a \emph{Galois Connection}:
\begin{align*}
  \galoisbetweensemantics{dependency}{inputoutput}
\end{align*}
\end{theorem}

\begin{definition}[Input-Output Abstraction Semantics]\labdef{inputoutput-abstraction-semantics}
  \begin{align*}
    \inputoutputsemanticsnoparam\DefeQ&\inputoutputabstraction(\dependencysemanticsnoparam) \\
    % \spacearound{=}&\inputoutputabstraction(\{\spacearound{\setdef{\inputoutputtuple{\deftrace}}{\deftrace \in \tracesemanticsnoparam}}\}) \\
    \spacearound{=}&
    \{\spacearound{
      \setdef{
        \tuple{\inputobs(\retrieveinput{\deftrace})}{\outputobs(\retrieveoutput{\deftrace})}
      }{
        \deftrace \in \tracesemanticsnoparam
      }
    }\}
  \end{align*}
\end{definition}

\begin{theorem}\labthm{inputoutput-validation}
  \begin{align*}
    \collectingsemantics \subseteq \unused \IfF \inputoutputsemantics \subseteq \inputoutputabstraction(\dependencyabstraction(\unused))
  \end{align*}
\end{theorem}

\begin{remark}
  \begin{align*}
    \inputoutputabstraction(\dependencyabstraction(\unused))\spacearound{=}
    \setdef{\inputoutputsemanticsnoparam\in\setof\pairofstates}{&
    \forall
      \inputoutputtuple\defstate\in\inputoutputsemanticsnoparam, \defstate\in\state
    .\spacer
      \\ &\qquad
      \retrieveinput{\defstate}(\definputvariable) \neq \inputobs(\defstate(\definputvariable)) \ImplieS \\
      &\exists
        \defstate'\in\inputoutputsemanticsnoparam
      .\spacer
        \retrieveinput{\defstate'} \stateeq{\inputvariableswithouti} \retrieveinput{\defstate}
        \LanD \\
        & \qquad
        \retrieveinput{\defstate'}(\definputvariable) = \inputobs(\defstate(\definputvariable))
        \LanD \\
        & \qquad
        \aniobserver(\retrieveoutput{\defstate}) = \aniobserver(\retrieveoutput{\defstate'})
    }
  \end{align*}
\end{remark}
