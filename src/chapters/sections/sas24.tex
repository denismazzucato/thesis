\pagelayout{wide} % No margins
\addpart{Quantitative Verification of Intensional Properties}
\labpart{intensional}
\pagelayout{margin} % Restore margins

\setchapterpreamble[u]{\margintoc}

\chapter{Quantitative Static Timing Analysis}
\labch{quantitative-static-timing-analysis}


\marginemptybox{6.8cm}

This chapter presents a static analysis for quantifying the impact of input variables on the number of iterations of a program.
The analysis employs a semantic global loop bound analysis to derive an over-approximation of the impact quantity.
First, we introduce the maximal trace semantics augmented with a global loop counter to model the number of iterations of all the loops of a program.
Then, we show an abstract global loop bound analysis, followed by the impact quantification, which is employed to verify the corresponding $\defbound$-impact property.
This chapter is based on the work presented at the 31st Static Analysis Symposium (SAS 2024)~\sidecite{Mazzucato2024c}.
\refch{sas24-eval} will discuss some implementation details and optimizations, as well as the evaluation of the analysis presented on this chapter.


\frenchdiv

\emph{Ce chapitre présente une analyse statique pour quantifier l'impact des variables d'entrée sur le nombre d'itérations d'un programme. L'analyse utilise une analyse sémantique des bornes globales des boucles pour dériver une sur-approximation de la quantité d'impact. Tout d'abord, nous introduisons la sémantique de trace maximale augmentée d'un compteur global de boucles pour modéliser le nombre d'itérations de toutes les boucles d'un programme. Ensuite, nous montrons une analyse abstraite des bornes globales des boucles, suivie de la quantification de l'impact, qui est utilisée pour vérifier la propriété d'impact correspondante $\defbound$. Ce chapitre est basé sur le travail présenté au 31ème Symposium sur l'Analyse Statique (SAS 2024)~\cite{Mazzucato2024c}. \refch{sas24-eval} discutera de certains détails de mise en œuvre et optimisations, ainsi que de l'évaluation de l'analyse présentée dans ce chapitre.}



\section{Global Loop Bound Semantics}


\marginnote{We recall that the variables of the program are represented by the set $\variables$, where the finite set $\inputvariables\subseteq\variables$ contains the input variables.}
We present a concrete semantics extended with the global loop counter for the simple imperative language of \refsec{a-small-imperative-language}, reported on the side for convenience.

\marginnote{
  \begin{align*}
    \defaexp \grammardef \defvalue  \sep \defvariable \sep \defaexp + \defaexp \sep \defaexp - \defaexp  \\
    \defbexp \grammardef \defaexp \leq \defvalue \sep \defaexp = \defvalue \sep \defbexp \land \defbexp \sep \lnot \defbexp \\
    \defstmt \grammardef \skipstmt
    \sep \assignstmt
    \sep \assertstmt\\
    \linesep \ifstmt \\
    \linesep \whilestmt \\
    \linesep \compstmt \\
    \defprogram \grammardef \progstmt
  \end{align*}
}



In order to accumulate the number of iterations of (all) loops in the program, we introduce a variable $\counter\not\in\variables$, called the \emph{global loop counter}.
Consequently, we extend the program states to include the value of the global loop counter, \ie, $\state$ maps from variables in $\variablesandcounter\defeq\variables\setjoin\{\counter\}$ to values in $\values$.
As a consequence, $\counter$ is not an input variable either, \ie, $\counter\notin\inputvariables$.
We extend the maximal trace semantics $\tracesemanticsnoparam$ to include the global loop counter as follows:

\marginnote{For simplicity, we omit program locations in the maximal trace semantics of \refdef{counter-semantics}}
\begin{definition}[Maximal Trace Semantics with the Global Loop Counter]\labdef{counter-semantics}
  The semantics $\countertracesemanticsnoparam\in\tracetype$ is defined as:
\begin{align*}
  % &\reabwdsemanticsnoparam \semanticsof{\defstmt} \IN \reabwdtype \\
  &\countertracesemanticsnoparam \semanticsof{\skipstmt}\defsetoftraces \DefeQ
  \setdef{\concat{\defstate \defstate}{\deftrace}}{\defstate \in \state \land \deftrace\in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
  \\
  &\countertracesemanticsnoparam \semanticsof{\assignstmt}\defsetoftraces \DefeQ \\
  % \setdef{\defstate\in\state}{\defvalue \in \aexpsemantics \land \updatemem{\defstate}{\defvariable}{\defvalue} \in \defsetoftraces }
  &\quad \setdef{\concat{\defstate \updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace}}{\defstate \in \state \land \defvalue \in \aexpsemantics \defstate \land \deftrace\in \finiteoremptyinfinitesequences \land \concat{\updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace} \in \defsetoftraces}
  \\
  &\countertracesemanticsnoparam \semanticsof{\assertstmt}\defsetoftraces \DefeQ
  % \bexpsemantics\defsetoftraces
  \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
  \\
  &\countertracesemanticsnoparam \semanticsof{\ifstmt[\defstmt][\defstmt']}\defsetoftraces \DefeQ
  \\
  &\quad
  % \bexpsemantics(\countertracesemanticsnoparam \semanticsof{\defstmt}\defsetoftraces)
  % \bexpsemanticsnoparam\semanticsof{\neg\defbexp}(\countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces)
  \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt}\defsetoftraces} \SetjoiN {} \\
  &\quad \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces}
  \\
  &\countertracesemanticsnoparam \semanticsof{\whilestmt}\defsetoftraces \DefeQ
  \lfp{}\fixpointfunction\\
  % &\quad \fixpointfunction(X) \DefeQ \bexpsemanticsnoparam\semanticsof{\neg \defbexp} \defsetoftraces \SetjoiN  \bexpsemantics (\countertracesemanticsnoparam \semanticsof{\defstmt} \bwddecr(X))
  &\quad \fixpointfunction(X) \DefeQ
  \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \concat{\defstate}{\deftrace} \in \defsetoftraces} \SetjoiN {} \\
  &\qquad   \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics \defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt} \bwddecr(X)}
  \\
  &\countertracesemanticsnoparam \semanticsof{\compstmt[\defstmt][\defstmt']}\defsetoftraces \DefeQ
  \countertracesemanticsnoparam \semanticsof{\defstmt}( \countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces)
  \\
  &\countertracesemanticsnoparam \semanticsof{\progstmt}\defsetoftraces \DefeQ \\
  % \countertracesemanticsnoparam \semanticsof{\defstmt}(\updatemem{\defsetoftraces}{\counter}{0})
  &\quad \countertracesemanticsnoparam \semanticsof{\defstmt}\setdef{\concat{\updatemem{\defstate}{\counter}{0}}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
\end{align*}
\end{definition}

The semantics $\countertracesemanticsnoparam$ increments the value of the global loop counter $\counter$ at each iteration.
Therefore, the global loop counter $\counter$ contains the number of iterations of all the loops in the program.
% To some extent, the maximal trace semantics augmented with the global loop counter foresees the global number of iterations before computing the program traces. Whenever $\counter$ reaches $0$, the program will terminate without further loop iterations.

% The hierarchy of semantics applies accordingly from the maximal trace semantics.
% Thus, from the semantics abstractions we obtain the collecting semantics $\countercollectingsemanticsnoparam \defeq \{ \countertracesemanticsnoparam \}$, the dependency semantics $\counterdependencysemanticsnoparam \defeq \dependencyabstraction(\countercollectingsemanticsnoparam)$, and the output semantics $\counteroutputsemanticsnoparam \defeq \outputabstraction(\counterdependencysemanticsnoparam)$.

\begin{marginlisting}[*-23]
  \caption{Program \add, computing the sum of two numbers \texttt{x} and \texttt{y} into \texttt{z}.}
  \labprog{add}
  \vspace{15pt}
  \begin{lstlisting}[
    language=customPython,
    style=mystyle,
    escapechar=\%]
def Add(p, z, m, x, n, y):
    r = min(p, m)%\labline{min1}%
    s = min(p, n)%\labline{min2}%
    if (r < s):%\labline{if1}%
      t = p - s%\labline{sub1}%
      q = s - r%\labline{sub2}%
      # i = 0
      # a = 0
      for (; r > 0; r--):%\labline{for1}%
        # s = x[i] %\labline{array}%
        # w = y[i]
        # z[i] = s + w + a
        # i = i + 1
        # a = (w < a) ||%\labline{bitwise}%
        #   (s + w < s) ||
        #   (s + w + a < s)
      do:%\labline{do1}%
        # r = y[i]
        # b = (r < a) ||
        #   (r + a < r)
        # z[i] = r + a
        # i = i + 1
        q--
        # a = b
      while (q > 0)
  else:%\labline{else}%
    t = p - r%\labline{sub3}%
    q = r - s%\labline{sub4}%
    # i = 0
    # b = 0
    for (; s > 0; s--):%\labline{for2}%
      # r = x[i]
      # w = y[i]
      # z[i] = r + w + b
      # i = i + 1
      # b = (w < b) ||
      #   (r + w < r) ||
      #   (r + w + b < r)
    for (; q > 0; q--):%\labline{for3}%
      # r = x[i]
      # z[i] = r + b
      # i = i + 1
      # b = (r < b) ||
      #   (r + b < r)
  if (t > 0):%\labline{if2}%
    # z[i] = b
    while (t > 0):%\labline{while1}%
      # i = i + 1
      t--
      # if (t > 0):%\labline{padding}%
        # z[i] = 0
\end{lstlisting}
\end{marginlisting}

\begin{table}[b]
  \caption{A few executions to show how many times the program \add{} iterates over the loops. The symbol \anyvalue{} denotes any possible value.}
  \labtab{add-execution}
  \centering
  \begin{tabular}{cc cc cc C{1cm} c}
    $\add( \texttt{p}$, & \texttt{z}, & \texttt{m}, & \texttt{x}, & \texttt{n}, & $\texttt{y})$ & $\rightsquigarrow$ & \makecell{global \\ \underline{\blue{n}}umber of \underline{\blue{it}}erations} \\
  \hline\hline
    $\add( 0$, & \anyvalue, & 0, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{0} \\
    $\add( 1$, & \anyvalue, & 0, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{1} \\
    $\add( 2$, & \anyvalue, & 0, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{2} \\
    $\add( 0$, & \anyvalue, & 1, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{0} \\
    $\add( 1$, & \anyvalue, & 1, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{1} \\
    $\add( 2$, & \anyvalue, & 1, & \anyvalue, & 0, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{2} \\
    $\add( 0$, & \anyvalue, & 0, & \anyvalue, & 1, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{0} \\
    $\add( 1$, & \anyvalue, & 0, & \anyvalue, & 1, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{1} \\
    $\add( 2$, & \anyvalue, & 0, & \anyvalue, & 1, & $\anyvalue)$ & $\rightsquigarrow$ & \blue{2}
  \end{tabular}
\end{table}

\begin{example}\labexample{add}
  Consider the \refprog{add}, called \add{}, presented on the side.
The goal of program \add{} is to compute the sum of two given numbers \texttt{x} and \texttt{y}, storing the result into \texttt{z}.
The input variables \texttt{x}, \texttt{y}, and the output \texttt{z} are represented in the form of arrays, respectively of length \texttt{m}, \texttt{n}, and \texttt{p}.
The program \add{} computes the column addition of the two input arrays. For instance, assuming $\texttt{x} = [3\spacer 8]$, $\texttt{y} = [4]$ and the size of $\texttt{z}$ is 3, then $\add(3, \texttt{z}, 2, [3\spacer 8], 1, [4])$ computes:
\begin{center}
  \begin{tabular}{c@{\,}r@{\,}r@{\,}c}
       & [3 &  8] & + \\
       &    & [4] & = \\
    \hline
    [0 &  4 &  2] &  \\
  \end{tabular}
\end{center}
where the result is stored back into \texttt{z}, available in the calling context of the function.
The statements that are not relevant to the number of iterations of loops are commented out (\cf{} \textcolor{codecomment}{\texttt{\#}}).
As we will discover in the next chapter, these irrelevant statements are pruned by the syntactic dependency analysis.
\reftab{add-execution} shows a few executions of the program \add{}.

The semantics of the program \add, \cf{} \refdef{counter-semantics}, is defined backwards from any state with the global loop counter $\counter$ initialized to $0$.
Thus, starting from final states where $\counter = 0$, the semantics of the program \add{} decrements (in a backward fashion) the global loop counter $\counter$ at each iteration of the loops. The backward decrement is defined as $\bwddecr(\defsetofstates) \defeq \setdef{\defstate \in \state}{\updatemem{\defstate}{\counter}{\defstate(\counter) - 1} \in \defsetofstates}$. After the computation of the semantics of a given program, we obtain the number of iterations of all the loops in the program.
\reftab{add-trace} shows the maximal traces of the executions of the program \add{}, intermediate states are omitted for brevity.
\end{example}

\begin{table}[t]
  \caption{Maximal traces of the program \add{}.}
  \labtab{add-trace}
  \hspace{2cm}
  \centering
  \begin{tabular}{c C{1.5cm} c}
    $\langle\tikzmark{a1}$ \texttt{p}, \texttt{m}, \texttt{n}, $\dots$, $\counter$ $\tikzmark{a2}\rangle$ & $\tracearrow$ & $\langle\tikzmark{b1}\texttt{p}$, \texttt{m}, \texttt{n}, $\dots$ $\counter\tikzmark{b2}\rangle$ \\
  \hline\hline
    $\langle$ 0, 0, 0, $\dots$, \blue{0} $\rangle$ & $\tracearrow$ & $\langle$ 0, 0, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 1, 0, 0, $\dots$, \blue{1} $\rangle$ & $\tracearrow$ & $\langle$ 1, 0, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 2, 0, 0, $\dots$, \blue{2} $\rangle$ & $\tracearrow$ & $\langle$ 2, 0, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 0, 1, 0, $\dots$, \blue{0} $\rangle$ & $\tracearrow$ & $\langle$ 0, 1, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 1, 1, 0, $\dots$, \blue{1} $\rangle$ & $\tracearrow$ & $\langle$ 1, 1, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 2, 1, 0, $\dots$, \blue{2} $\rangle$ & $\tracearrow$ & $\langle$ 2, 1, 0, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 0, 0, 1, $\dots$, \blue{0} $\rangle$ & $\tracearrow$ & $\langle$ 0, 0, 1, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 1, 0, 1, $\dots$, \blue{1} $\rangle$ & $\tracearrow$ & $\langle$ 1, 0, 1, $\dots$, \blue{0} $\rangle$ \\
    $\langle$ 2, 0, 1, $\dots$, \blue{2} $\rangle$ & $\tracearrow$ & $\langle$ 2, 0, 1, $\dots$, \blue{0} $\rangle$ \\
    $\vdots$ & & $\vdots$ \\
    \tikzmark{c} $\langle$ a, b, c, $\dots$, \blue{a} $\rangle$ & $\tracearrow$& $\langle$ a, b, c, $\dots$, \blue{0} $\rangle$
  \end{tabular}
  \begin{tikzpicture}[overlay, remember picture]
    % \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt}] (a1.north) --node[above=14pt]{$\state$} (a2.north);
    % \draw [decorate,decoration={brace,amplitude=10pt,raise=4pt}] (b1.north) --node[above=14pt]{$\state$} (b2.north);
    \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=13pt}] (a1.north) --node[left=24pt]{$\countertracesemanticsnoparam\semanticsof{\add}$} (c.south);
    % \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt}] ($(b1.west) - (0,1)$) --node[below=14pt]{$\Delta n_{t, \Delta t} = n_t - N_{t-1}, \Delta_t$} ($(b2.east) - (0,1)$);
\end{tikzpicture}
\end{table}




We define the $\defbound$-impact property, which quantifies the impact of input variables on the global number of iterations of a program.

\begin{definition}[$\defbound$-Bounded Impact Property with Loop Iterations]\labdef{counter-bounded}
  Let $\defprogram$ be a program, $\definputvariables$ the set of input variables of interest, $\impactwrapper \in \tracetype\to\valuesposplus$ an impact quantifier,
  and $\defbound\in\valuesposplus$ the threshold.
  The $\defbound$-bounded impact property with loop iterations is defined as:
  \begin{equation*}
    \GENBOUNDED \DefeQ \setdef{\countertracesemanticsnoparam\in\tracetype}{\impactwrapper(\countertracesemanticsnoparam) \comparison \defbound}
  \end{equation*}
  where $\comparison\in\{\le, \ge\}$.
\end{definition}

To compute the impact of input variables on the global number of iterations of a program, we need to instantiate the $\defbound$-bounded impact property with an impact quantifier.
As a design choice, we choose the \rangename{} quantifier among the quantifiers defined in \nrefsec{k-bounded-impact-property}.
The range quantifier instrumented with the global loop counter $\counter$ as output variables and the identity function as output observer $\outputobs$ is defined as follows:
\begin{definition}[\rangename{} with $\counter$]\labdef{range-nit}
  Given the set of input variables of interest $\definputvariables\in\setof\inputvariables$, the impact quantifier $\range\in\tracetype\to\Rposplus$ instrumented with the global loop counter $\counter$ is defined as
\begin{align*}
  \range(\defsetoftraces) &\DefeQ \sup_{\definput\in\reducedstate}
    \distance(\setdef{
      \retrieveinput{\defseq}(\counter)
    }{
      \defseq \in \defsetoftraces \land \retrieveinput{\defseq} \stateeq{\inputvariableswithoutw} \definput
    })
\end{align*}
\end{definition}

Let $\boundedrange$ be the $\defbound$-bounded impact property with loop iterations when instantiated with the $\rangename$ impact quantifier. Formally:
\begin{align*}
  \BOUNDEDRANGE \DefeQ \setdef{\countertracesemanticsnoparam \in \tracetype}{\range(\countertracesemanticsnoparam) \comparison \defbound}
\end{align*}

\begin{example}
  Consider the trace semantics $\countertracesemanticsnoparam\semanticsof\add$ defined in~\reftab{add-trace}.
  For brevity, we consider states as $\state = \setdef{\langle p, m, n, nit \rangle}{p, m, n, nit\in[0, u]}$,
  % For brevity, we consider states as $\state = \setdef{\langle p, m, n\rangle}{p, m, n\in[0, u]}$,
  where $p$ is the value of \texttt{p}, $m$ of \texttt{m}, $n$ of \texttt{n}, and $nit$ of $\counter$, all ranging in the interval $[0, u]$.
  % We abuse the notation and use states as set of tuples instead of a map between variables and values, the two views are equivalent.
  Assuming we are interested in the impact of the input variable \texttt{p}, $\rangename_{\{\texttt{p}\}}(\countertracesemanticsnoparam\semanticsof\add)$ considers all possible input values $\definput\in\reducedstate$, on the left of~\reftab{add-trace}.
  We collect all the input states that agree with the input value $\definput$ on the other input variables, \cf{} $\texttt{m}$ and $\texttt{n}$.
  Specifically, we collect all the input states $\defstate$ such that $\defstate\stateeq{\{\texttt{m},\texttt{n}\}}\definput$.
  For instance, for the input value $\definput = \langle 0, 0, 0, 0\rangle$, we collect the set of states $\setdef{\langle p, 0, 0, nit\rangle}{p, nit\in[0, u]}$ where everything but \texttt{p} and \counter{} is fixed.
  From this set of states, we consider only the values of the counter $\counter$.
  For instance, regarding the input $\definput = \langle 0, 0, 0, 0\rangle$, we collect the values $[0, u]$.
  Then, we apply the operator $\distance([0, u]) = \sup\; [0, u] - \inf\; [0, u] = u$.
  For all the input values, the maximum value is taken; we obtain $\rangename_{\{\texttt{p}\}}(\countertracesemanticsnoparam\semanticsof\add)= u$.


  Let us analyze the impact of other input variables, \eg{}, the input variable \texttt{m}.
  By considering the input value $\definput = \langle 0, 0, 0, 0\rangle$, we collect the dependencies that start from states in $\setdef{\langle 0, m, 0, nit\rangle}{m, nit\in[0, u]}$. As we notice from left columns of \reftab{add-trace}, the number of iterations starting from any of these states is always $0$.
  Hence, $\distance(\{0\}) = \sup\; \{0\} - \inf\; \{0\} = 0$.
  For all the input values, we obtain: $\rangename_{\{\texttt{m}\}}(\countertracesemanticsnoparam\semanticsof\add)=\rangename_{\{\texttt{n}\}}(\countertracesemanticsnoparam\semanticsof\add)=0$.
%
  We conclude that:
  \[ \add \satisfies \mathscr{B}^{\le u}_{\rangename_{\{\texttt{p}\}}}, \qquad \add \satisfies \mathscr{B}^{\le 0}_{\rangename_{\{\texttt{n}\}}},\text{ and} \qquad \add \satisfies \mathscr{B}^{\le 0}_{\rangename_{\{\texttt{m}\}}}\]
  As a consequence, we can infer that there exist two executions starting from a different value for the input variable \texttt{p} that differ in the global number of iterations by at most $u$. On the contrary, any variation in the input variables \texttt{m} and \texttt{n} does not affect the global number of iterations.
\end{example}


Importantly, our goal is to quantify the impact of input variables on the global number of iterations.
As a consequence, only the initial and final states are relevant, \ie, where the program loop counter contains the global number of iterations.
In fact, we reduced the verification of an \emph{intensional} property about the global number of iterations of a program to the verification of an \emph{extensional} property by collecting the global number of iterations into input-output dependencies.
Thus, the hierarchy of semantics (\cref{sec:dependency-semantics,sec:output-abstraction-semantics}) applies accordingly from the maximal trace semantics $\countertracesemanticsnoparam$.
We retrieve the collecting semantics $\countercollectingsemanticsnoparam \defeq \{ \countertracesemanticsnoparam \}$, \cf{} \refdef{collecting-semantics}, and the dependency semantics $\counterdependencysemanticsnoparam \defeq \dependencyabstraction(\countercollectingsemanticsnoparam)$, \cf{} \refdef{dependency-semantics}.
Regarding \refexample{add}, the left and right columns of \reftab{add-trace} contain, in fact, the input-output dependencies with the additional variable for the global loop counter $\counter$.


Next, we show that the dependency semantics $\counterdependencysemanticsnoparam$ is sound and complete for validating $\boundedrange$.
\siderefbox{def}{dependency-semantics}
\begin{lemma}\lablemma{counter-range-validation}
  \begin{align*}
    \countercollectingsemantics \subseteq \BOUNDEDRANGE \IfF \counterdependencysemantics \subseteq \dependencyabstraction(\BOUNDEDRANGE)
  \end{align*}
\end{lemma}
\begin{proof}
  The proof is similar to the proof of \reflemma*{range-validation} where $\outputobs = \identity$.
\end{proof}

Note that we do not consider the output observer $\outputobs$, hence the output-abstraction semantics $\outputabstraction$ is not needed.
Furthermore, we notice from the example above that as the loop counter $\counter$ holds the global number of iterations in the initial states of the dependency semantics, we can further abstract the dependency semantics to the backward co-reachability semantics by removing output states as not necessary for $\boundedrange$.


\section{Backward Reachability Semantics}
\labsec{backwardreachability-semantics}

We define the pair of right-left adjoints $\tuple{\backwardreachabilityabstraction}{\backwardreachabilityconcretization}$ to abstract the dependency semantics into the backward co-reachability semantics.
\begin{definition}[Right-Left Adjoints for the Backward Reachability Semantics]\labdef{right-left-adjoints-for-the-backwardreachability-semantics}
\begin{align*}
  \backwardreachabilityabstraction \IN& \dependencytype \to \backwardreachabilitytype \\
  \backwardreachabilityabstraction(\defsetofsetofdependencies) \DefeQ& \setdef{
    \setdef{\retrieveinput{\defseq}}{\inputoutputtuple{\defseq}\in\defsetofdependencies}
  }{
    \defsetofdependencies\in\defsetofsetofdependencies
  }\\
  \backwardreachabilityconcretization \IN& \backwardreachabilitytype \to \dependencytype \\
  \backwardreachabilityconcretization(\defsetofsetofstates) \DefeQ& \setdef{
    \pair\defsetofstates{Q}
  }{
    \defsetofstates \in \defsetofsetofstates
    \land Q \subseteq \stateandbottom
  }
\end{align*}
\end{definition}
The function $\backwardreachabilityabstraction$ abstracts away output states of any dependency, preserving the set-structure of $\defsetofsetofdependencies$.
The concretization $\backwardreachabilityconcretization$ yields all the semantics that share the same input states of, at least, one of the set of semantics in $\defsetofsetofstates$.


\begin{theorem}\labthm{collecting-backwardreachability-galois-connection}
The two adjoints $\tuple{\backwardreachabilityabstraction}{\backwardreachabilityconcretization}$ form a \emph{Galois insertion}:
\begin{align*}
  \galoisinjbetweensemantics{collecting}{backwardreachability}
\end{align*}
\end{theorem}
\begin{proof}
  % Given a set of semantics $\defsetofsetofdependencies\in\setofsetof\finiteinfinitesequences$ and a set of sets of input-output observations $\defsetofsetofstates\in\setofsetof\pairofstates$ implied by the abstraction of $\defsetofsetofdependencies$, $\backwardreachabilityabstraction(\defsetofsetofdependencies)\subseteq \defsetofsetofstates$, we obtain that $\defsetofsetofdependencies\subseteq\backwardreachabilityconcretization(\defsetofsetofstates)$ since the concretization $\backwardreachabilityconcretization$ builds all the possible semantics with the same set of input-output observations of at least one of the starting semantics.
  % Moreover, it is easy to note that $\backwardreachabilityabstraction(\backwardreachabilityconcretization(\defsetofsetofstates)) = \defsetofsetofstates$ since the concretization maintains the same input-output observations and the abstraction removes only intermediate states.
  We need to show that $\backwardreachabilityabstraction(\defsetofsetofdependencies)\subseteq \defsetofsetofstates \iff \defsetofsetofdependencies\subseteq\backwardreachabilityconcretization(\defsetofsetofstates)$.
  First, we show the direction $(\implies)$.
  Assuming $\backwardreachabilityabstraction(\defsetofsetofdependencies)\subseteq \defsetofsetofstates$, we have that $\backwardreachabilityconcretization(\defsetofsetofstates)$ contains all the possible semantics that share the same set of input states of at least one of the semantics in $\defsetofsetofstates$. Thus, $\backwardreachabilityconcretization(\defsetofsetofstates)$ also contains all the semantics in $\defsetofsetofdependencies$, \ie, $\defsetofsetofdependencies\subseteq\backwardreachabilityconcretization(\defsetofsetofstates)$.
  To show $(\Leftarrow)$, we assume $\defsetofsetofdependencies\subseteq\backwardreachabilityconcretization(\defsetofsetofstates)$.
  It is easy to note that $\backwardreachabilityabstraction(\backwardreachabilityconcretization(\defsetofsetofstates)) = \defsetofsetofstates$ since the concretization maintains the same set of input states and the abstraction removes only output states.
  Hence, by monotonicity of $\backwardreachabilityabstraction$, we obtain $\backwardreachabilityabstraction(\defsetofsetofdependencies)\subseteq \backwardreachabilityabstraction(\backwardreachabilityconcretization(\defsetofsetofstates)) = \defsetofsetofstates$.
\end{proof}

We now derive the \emph{backward co-reachability semantics} $\counterbackwardreachabilitysemanticsnoparam$ as an abstraction of the dependency semantics.

\begin{definition}[Backward Co-Reachability Semantics]\labdef{backwardreachability-semantics}
  The \emph{backward co-reachability semantics} $\counterbackwardreachabilitysemanticsnoparam\in\backwardreachabilitytype$ is defined as:
  \begin{align*}
    \counterbackwardreachabilitysemanticsnoparam\DefeQ \backwardreachabilityabstraction(\counterdependencysemanticsnoparam)
    % \spacearound{=}& \backwardreachabilityabstraction(\{\spacearound{\tracesemanticsnoparam}\}) \\
    % \spacearound{=}& \setdef{\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\defsetoftraces}}{\defsetoftraces\in\{\spacearound{\tracesemanticsnoparam}\}} \\
    \spacearound{=} \{\spacearound{\setdef{\retrieveinput{\deftrace}}{\deftrace \in \countertracesemanticsnoparam}}\}
  \end{align*}
\end{definition}

The next result shows that the backward co-reachability semantics $\counterbackwardreachabilitysemanticsnoparam$ allows a sound and complete verification of $\boundedrange$.

\begin{lemma}\lablemma{backwardreachability-validation}
\begin{align*}
  \countercollectingsemantics \subseteq \BOUNDEDRANGE \IfF \counterbackwardreachabilitysemantics \subseteq \backwardreachabilityabstraction(\dependencyabstraction(\BOUNDEDRANGE))
\end{align*}
\end{lemma}
\begin{proof}
  The implication $(\implies)$ follows from the monotonicity of $\backwardreachabilityabstraction$, as an implication from the fact that the two adjoints $\tuple\backwardreachabilityabstraction\backwardreachabilityconcretization$ form a Galois connection (\cf{} \refthm{collecting-backwardreachability-galois-connection}), and \refdef{backwardreachability-semantics} of $\counterbackwardreachabilitysemanticsnoparam$.
  Obtaining
  $
    \collectingsemanticsnoparam \subseteq \unused \implies \backwardreachabilityabstraction(\collectingsemanticsnoparam) \subseteq \backwardreachabilityabstraction(\unused)\implies \counterbackwardreachabilitysemanticsnoparam \subseteq \backwardreachabilityabstraction(\unused)
  $.
%
  Regarding the other implication $(\Leftarrow)$, from \refdef{backwardreachability-semantics} of $\counterbackwardreachabilitysemanticsnoparam$ and the property of \refthm{collecting-backwardreachability-galois-connection}, we obtain $\counterbackwardreachabilitysemanticsnoparam \subseteq \backwardreachabilityabstraction(\unused) \implies \backwardreachabilityabstraction(\collectingsemanticsnoparam) \subseteq \backwardreachabilityabstraction(\unused)\implies \collectingsemanticsnoparam \subseteq \backwardreachabilityconcretization(\backwardreachabilityabstraction(\unused))$, which can be written as $\tracesemanticsnoparam \in \backwardreachabilityconcretization(\backwardreachabilityabstraction(\unused))$ by the definition of $\collectingsemanticsnoparam$.
  By \refdef{right-left-adjoints-for-the-backwardreachability-semantics} of $\backwardreachabilityconcretization$ it follows that $\setdef{\inputoutputtuple{\deftrace}}{\deftrace\in\tracesemanticsnoparam}\in\backwardreachabilityabstraction(\unused)$.
  Finally, by application of \refdef{right-left-adjoints-for-the-backwardreachability-semantics} of $\backwardreachabilityabstraction$ we obtain $\tracesemanticsnoparam\in\unused$.
  The conclusion $\collectingsemanticsnoparam \subseteq \unused$ trivially follows from the definition of the subset inclusion $(\subseteq)$.
\end{proof}





\section{Static Analysis for Global Loop Bound}

This section presents a sound computable static analysis to automatically compute the global number of iterations.
An over-approximation of the global loop counter is computed by analyzing the program backwards.
The soundness of the approach leverages: $(1)$ an abstract domain of conjunctions of linear constraints, $(2)$ a sound global loop bound analysis to collect the dependencies of the loop counter $\counter$ from the input variables, and $(3)$ a linear programming encoding as a sound implementation of the impact $\rangename$, called $\counterrangename$.

\subsection{Conjunctions of Linear Constraints}
\labsec{conjunctions-of-linear-constraints}

We define the numerical abstract state domain used in the global loop bound analysis.
In principle, our abstract domain could be any convex abstract domain subsumed by the polyhedra domain~\sidecite{Cousot1978}, such as the interval domain~\cite{Cousot1978}, octagon domain~\sidecite{Min_e2006a}, or the polyhedra domain itself.
The elements of the abstract domain are conjunctions of linear constraints of the form:
%
\begin{equation*}
  c_1\cdot\defvariable_1 \spacearound+ \ldots \spacearound+ c_n\cdot\defvariable_n \spacearound+ c_{n+1} \spacearound\ge 0
\end{equation*}
%
where $\defvariable_j\in\variablesandcounter$ are variables and $c_j \in \values$ are constant values.
For better readability, we avoid writing the constant-variable multiplication term $c_i\cdot\defvariable_i$ when $c_i=0$; and we abuse the notation, \eg, for the constraint $\defvariable_1 = \defvariable_2$, to denote the conjunction of the two linear constraints $\defvariable_1 - \defvariable_2 \ge 0$ and $\defvariable_2 - \defvariable_1 \ge 0$.
The abstract domain is a lattice $\langle\abstractdomain, \abstractdomainsubseteq, \abstractdomainjoin, \abstractdomainmeet, \abstractdomaintop, \abstractdomainbottom\rangle$ equipped with a concretization function $\abstractdomainconcretization\in\abstractdomain\to\setof\state$, defined as follows:

\begin{definition}[Concretization of Linear Constraints]\labdef{concretization-of-conjunctions-of-linear-constraints}
  The concretization $\abstractdomainconcretization$ of conjunctions of linear constraints $\defabstractvalue\in\abstractdomain$ is defined as:
\begin{align*}
  \abstractdomainconcretization(\defabstractvalue) \DefeQ \setdef*{\defstate\in\state}{\forall  \left(c_1\cdot\defvariable_1 + \ldots + c_n\cdot\defvariable_n + c_{n+1} \ge 0\right) \in \defabstractvalue. \\
      c_1\cdot\defstate(\defvariable_1) + \ldots + c_n\cdot\defstate(\defvariable_n) + c_{n+1} \ge 0
  }
\end{align*}
\end{definition}
Additionally, in order to be effectively used in the context of the global loop bound analysis, we assume:
\begin{enumerate}[label=(\roman*)]
  \item an operator $\abstractdomainsubstitute{\defvariable}{\defaexp}\in\abstractdomain\to\abstractdomain$ to substitute the variable $\defvariable\in\variablesandcounter$ with the expression $\defaexp$,
  \item an operator $\abstractdomainfilter\semanticsof{\defbexp}\in\abstractdomain\to\abstractdomain$ to handle boolean expressions $\defbexp$,
  \item a widening operator $\abstractdomainwidening\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ to ensure termination of the analysis, and
  \item a project operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$ to remove the input variables $\definputvariables$ from the given abstract state.
\end{enumerate}

These requirements are satisfied by any of the commonly used numerical abstract domains \sidecite{Cousot1978,Min_e2006a}.

\subsection{Global Loop Bounds}

\newcommand{\s}{\red{\texttt{s}_x}}
The global loop bound semantics $\counterbackwardsemanticsnoparam\in\counterbackwardtype$ is a backward abstract semantics that generates an
invariant over input variables and the global loop counter $\counter$.
% over-approximation of the global number of iterations, \cf~the global loop counter $\counter$.
% We set the global loop bound semantics $\counterbackwardsemanticsnoparam$ to start from the post-condition $\counter = 0$.
%
During the backward analysis, the value of $\counter$ increases from $0$ to an over-approximation of the possible global range of iterations.
As a consequence, the pre-condition invariant generated by the backward semantics $\counterbackwardsemantics$ over-approximates relations between $\counter$ and the initial values of variables in $\variables$.
The concretization function $\backwardconcretization\in\counterbackwardtype\to\backwardreachabilitytype$ maps an abstract state to a set of sets of input states.
Its goal is to preserve the relations between input values and the global loop counter $\counter$.
% Potentially, $\backwardconcretization$ introduces dependencies that are not present in the concrete dependency semantics $\counterdependencysemanticsnoparam$.
% Nevertheless, these additional dependencies are irrelevant for the quantification of the impact.
Formally:
\begin{align}
  \labeq{counter-backward-concretization}
  \backwardconcretization(\counterbackwardsemantics) \DefeQ \setof{\abstractdomainconcretization(\counterbackwardsemantics)}
\end{align}
The concretization $\backwardconcretization$ restores all possible input states that satisfy the relations between the input variables and the global loop counter $\counter$.
%
%
% Note that, the use of this global loop bound analysis removes the need for the set of $\numberofbuckets$ starting output buckets.
% Effectively, we reduce the number of backward passes prior to the impact quantification from $\numberofbuckets$ to only one.
% The reason is that there is only one output state to consider, the one where the global loop counter $\counter$ is $0$.
% The impact quantification can be performed by analyzing the abstract element resulting from the global loop bound analysis, which alone contains all the necessary information as it comprises relations between the input variables and the global loop counter $\counter$.
% To some extent, $\counter=0$ could be seen as a single output bucket, which intuitively is compatible and covers all the possible output states.
%
% The soundness of the abstract semantics is adjusted accordingly, to handle the absence of the output buckets.
For the backward semantics $\counterbackwardsemanticsnoparam$ to be sound, we require the concretization $\backwardconcretization$ to over-approximate the backward co-reachability semantics $\counterbackwardreachabilitysemanticsnoparam$.
Formally, for all programs $\defprogram$, it should hold that:
\begin{equation}
  \labeq{sound-abstract-dependency-semantics}
  \counterbackwardreachabilitysemantics\SubseteQ\backwardconcretization(\counterbackwardsemantics)
\end{equation}
%
The soundness condition, \cf{} \refeq{sound-abstract-dependency-semantics}, allows any sound global loop bound analysis $\counterbackwardsemanticsnoparam$ to verify the $\defbound$-bounded impact property $\boundedrange$.
% Note that, originally in \refdef*{sound-over-approximation} we required the concretization to be a sound over-approximation of the output-abstraction semantics.
% However, in the context of the global loop bound analysis, the output-abstraction semantics is not needed, as the output observer is the identity function.
% Thus, we state the sound over-approximation condition on the dependency semantics directly.


\begin{figure}[t]
  \caption{Global loop bound semantics.}
  \labfig{backward-semantics}
  \begin{align*}
    &\counterbackwardsemanticsnoparam \semanticsof{\skipstmt}\defabstractvalue \DefeQ
      \defabstractvalue
    \\
    &\counterbackwardsemanticsnoparam \semanticsof{\assignstmt}\defabstractvalue \DefeQ
      \abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue
    \\
    &\counterbackwardsemanticsnoparam \semanticsof{\assertstmt}\defabstractvalue \DefeQ
      \abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue
    \\
    &\counterbackwardsemanticsnoparam \semanticsof{\ifstmt[\defstmt][\defstmt']}\defabstractvalue \DefeQ
      \\
    &\qquad
    \abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue) \spacearound\abstractdomainjoin
    \abstractdomainfilter\semanticsof{\neg\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)
    \\
    &\counterbackwardsemanticsnoparam \semanticsof{\whilestmt}\defabstractvalue \DefeQ
      \lim_{n} \spacer \abstractdomainfixpoint_n
      \\
      &\qquad \abstractdomainfixpoint_0 \DefeQ d
      \\
      &\qquad \abstractdomainfixpoint_{n+1} \DefeQ \abstractdomainfixpoint_n \spacearound\abstractdomainwidening \abstractdomainfixpoint(\abstractdomainfixpoint_n)
      \\
      &\qquad \abstractdomainfixpoint(a) \DefeQ \abstractdomainfilter\semanticsof{\neg\defbexp}d \\
      &\qquad \hphantom{\abstractdomainfixpoint(a)} \spacearound\abstractdomainjoin \abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} (\abstractdomainsubstitute{\counter}{\counter-1}a)) \numberthis \labeq{backward-incr}
      \\
    &\counterbackwardsemanticsnoparam \semanticsof{\compstmt[\defstmt][\defstmt']} \defabstractvalue \DefeQ
      \counterbackwardsemanticsnoparam \semanticsof{\defstmt} (\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)
      \\\\
    &\counterbackwardsemanticsnoparam \semanticsof{\progstmt} \DefeQ
    \counterbackwardsemanticsnoparam \semanticsof{\defstmt} (\counter = 0)
    \numberthis \labeq{backward-init}
\end{align*}
\end{figure}
A possible candidate semantics for the global loop bound analysis $\counterbackwardsemanticsnoparam\in\counterbackwardtype$ is defined in \reffig{backward-semantics}.
The semantics $\counterbackwardsemanticsnoparam$ is a \textit{backward co-reachability semantics} instrumented to increment the loop counter $\counter$ at each loop iteration, \cf{} \refeq{backward-incr}.
The loop counter $\counter$ is handled semantically in the abstract domain without loss of precision, initialized to $0$ at the program exit, \cf{} \refeq{backward-init}.
% The semantics of the loop statement is defined by a fixpoint computation that iteratively applies the loop body semantics and decrements the loop counter $\counter$, \cf~\refeq{bac-incr}.
The rest of the semantics is classical.
The following result states the soundness of the backward semantics defined in \reffig{backward-semantics}.
%

\begin{lemma}[Soundness of $\counterbackwardsemanticsnoparam$]\lablemma{candidate-backward}
  For all programs $\defprogram$, the semantics $\counterbackwardsemantics\in\counterbackwardtype$ defined in~\reffig{backward-semantics} is a \textup{sound over-approximation} of the backward co-reachability semantics $\counterbackwardreachabilitysemantics$:
  \begin{equation*}
    \counterbackwardreachabilitysemantics \SubseteQ \backwardconcretization(\counterbackwardsemantics)
  \end{equation*}
\end{lemma}
\begin{proof}[Proof]
  We prove by induction on the syntax of the program that the global loop bound semantics $\counterbackwardsemantics$, \cf{} \reffig{backward-semantics}, is a sound over-approximation of the backward co-reachability semantics $\counterbackwardreachabilitysemantics$, \cf{} \refdef*{backwardreachability-semantics}. Regarding the base cases, we have:
  % \begin{figure*}
  \siderefbox{def}{counter-semantics}
  \begin{align*}
    &(\skipstmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\skipstmt} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\skipstmt} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput{(\defstate \defstate)}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by $\deftrace = \emptysequence$} \\
    &\quad
      =\{\setdef{\retrieveinput{(\defstate \defstate)}}{\defstate \in \state \land \defstate \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by set property} \\
    &\quad
      =\{\setdef{\retrieveinput{(\defstate \defstate)}}{\defstate \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by $\retrieveinput{(\defstate \defstate)} = \defstate$} \\
    &\quad
      =\{\setdef{\defstate}{\defstate \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by set definition} \\
    &\quad
      =\{\abstractdomainconcretization(\defabstractvalue)\} && \tag{by \refeqshort{counter-backward-concretization}} \\
    &\quad
      \subseteq \setof{\abstractdomainconcretization(\defabstractvalue)} && \tag{by \refeqshort{sound-abstract-dependency-semantics}} \\
    &\quad
      =\backwardconcretization(\defabstractvalue) && \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      =\backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\skipstmt} \defabstractvalue)
  \end{align*}
%   \end{align*}
% \end{figure*}
% \begin{figure*}
  \begin{align*}
    &(\assignstmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\assignstmt} \abstractdomainconcretization(\defabstractvalue) \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\assignstmt} \abstractdomainconcretization(\defabstractvalue)}\} \tag{by \refdefshort{counter-semantics}} \\
    &\quad
      =\left\{\setdef*{\retrieveinput{(\concat{\defstate \updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace})}}{\defstate \in \state \land \defvalue \in \aexpsemantics \defstate \land \deftrace\in \finiteoremptyinfinitesequences \land \\ \concat{\updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace} \in \abstractdomainconcretization(\defabstractvalue)}\right\} \tag{by $\deftrace = \emptysequence$} \\
    &\quad
      =\{\setdef{\retrieveinput{(\concat{\defstate \updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace})}}{\defstate \in \state \land \defvalue \in \aexpsemantics \defstate \land \updatemem{\defstate}{\defvariable}{\defvalue} \in \abstractdomainconcretization(\defabstractvalue)}\} \tag{by $\retrieveinput{(\concat{\defstate \updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace})} = \defstate$} \\
    &\quad
      =\{\setdef{\defstate\in \state}{\defvalue \in \aexpsemantics \defstate \land \updatemem{\defstate}{\defvariable}{\defvalue} \in \abstractdomainconcretization(\defabstractvalue)}\} \tag{by $\abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue$} \\
    &\quad
      \subseteq \setof{\abstractdomainconcretization(\abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue)} \tag{by \refeqshort{sound-abstract-dependency-semantics}} \\
    &\quad
      = \backwardconcretization(\abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue) \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\assignstmt} \defabstractvalue)
  \end{align*}
% \end{figure*}
% \begin{figure*}
\siderefbox{eq}{counter-backward-concretization}
\siderefbox{eq}{sound-abstract-dependency-semantics}
\siderefbox{def}{backwardreachability-semantics}
\siderefbox{def}{counter-semantics}
  \begin{align*}
    &(\assertstmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\assertstmt} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\assertstmt} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput{(\concat{\defstate}{\deftrace})}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by $\deftrace = \emptysequence$} \\
    &\quad
      =\{\setdef{\retrieveinput{(\defstate)}}{\defstate \in \state \land \bexpsemantics\defstate \land \defstate \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by set property} \\
    &\quad
      =\{\setdef{\retrieveinput{(\defstate)}}{\defstate \in \abstractdomainconcretization(\defabstractvalue) \land \bexpsemantics\defstate}\} && \tag{by $\retrieveinput{(\defstate)} = \defstate$} \\
    &\quad
      =\{\setdef{\defstate\in\abstractdomainconcretization(\defabstractvalue)}{\bexpsemantics\defstate}\} && \tag{by \refdefshort{concretization-of-conjunctions-of-linear-constraints}} \\
    &\quad
      \subseteq \setof{\abstractdomainconcretization(\abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue)} && \tag{by $\abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue$} \\
    &\quad
      = \backwardconcretization(\abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue) && \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\assertstmt} \defabstractvalue)
  \end{align*}
  \begin{align*}
  &(\progstmt) \\
  &\quad
    \counterbackwardreachabilitysemanticsnoparam \semanticsof{\progstmt} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
  &\quad
    =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\progstmt} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
  &\quad
    =\{\setdef{\retrieveinput{(\concat{\updatemem{\defstate}{\counter}{0}}{\deftrace})}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by $\deftrace = \emptysequence$} \\
  &\quad
    =\{\setdef{\updatemem{\defstate}{\counter}{0}}{\defstate \in \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by $\abstractdomainsubstitute{\counter}{0}\defabstractvalue$} \\
  &\quad
    \subseteq \setof{\abstractdomainconcretization(\abstractdomainsubstitute{\counter}{0}\defabstractvalue)} && \tag{by \refeqshort{sound-abstract-dependency-semantics}} \\
  &\quad
    = \backwardconcretization(\abstractdomainsubstitute{\counter}{0}\defabstractvalue) && \tag{by \reffigshort{backward-semantics}} \\
  &\quad
    = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\progstmt} \defabstractvalue)
  \end{align*}

\begin{samepage}
  Regarding the inductive cases, we assume the following inductive hypothesis: $\counterbackwardreachabilitysemanticsnoparam \semanticsof{\defstmt} \abstractdomainconcretization(\defabstractvalue) \subseteq \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)$.
  Note that, the inductive hypothesis implies that $\countertracesemanticsnoparam \semanticsof{\defstmt} \abstractdomainconcretization(\defabstractvalue) \in \setof{\abstractdomainconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)}$ by \refdef{backwardreachability-semantics} and \refeq{counter-backward-concretization}. Therefore, we have:
  \begin{align*}
    &(\compstmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\compstmt} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\compstmt} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\defstmt} (\countertracesemanticsnoparam \semanticsof{\defstmt'} \abstractdomainconcretization(\defabstractvalue))}\} && \tag{by inductive hypothesis} \\
    &\quad
      \subseteq\setof{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\defstmt} \abstractdomainconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by inductive hypothesis} \\
      &\quad
        \subseteq\setof{\setdef{\retrieveinput\deftrace}{\deftrace\in \abstractdomainconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by $\deftrace = \defstate$} \\
    &\quad
      \subseteq\setof{\setdef{\defstate}{\defstate\in \abstractdomainconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by set definition} \\
    &\quad
      = \setof{\abstractdomainconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue))} && \tag{by \refeqshort{counter-backward-concretization}} \\
    &\quad
      = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)) && \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\compstmt} \defabstractvalue)
  \end{align*}
\end{samepage}
\siderefbox{eq}{counter-backward-concretization}
\siderefbox{eq}{sound-abstract-dependency-semantics}
\siderefbox{def}{backwardreachability-semantics}
\siderefbox{def}{counter-semantics}
% \end{figure*}
% \begin{figure*}
  \begin{align*}
    &(\ifstmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\ifstmt[\defstmt][\defstmt']} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\ifstmt[\defstmt][\defstmt']} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput{(\concat\defstate\deftrace)}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt} \abstractdomainconcretization(\defabstractvalue)} \spacearound\cup \\
    &\qquad \setdef{\retrieveinput{(\concat\defstate\deftrace)}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt'} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by inductive hypothesis} \\
    &\quad
      \subseteq\setof*{\setdef*{\retrieveinput{(\concat\defstate\deftrace)}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \\ \concat{\defstate}{\deftrace} \in \abstractdomainconcretization(\countertracesemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)}  \\
      \spacearound\cup \setdef*{\retrieveinput{(\concat\defstate\deftrace)}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \\ \concat{\defstate}{\deftrace} \in \abstractdomainconcretization(\countertracesemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by $\deftrace = \emptysequence$} \\
    &\quad
      =\setof*{\setdef{\defstate\in\state}{\bexpsemantics\defstate \land \defstate \in \abstractdomainconcretization(\countertracesemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)} \spacearound\cup \\
      \setdef{\defstate\in\state}{\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \defstate \in \abstractdomainconcretization(\countertracesemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by $\abstractdomainfilter \semanticsof{\defbexp}\defabstractvalue$} \\
    &\quad
      \subseteq\setof*{ \abstractdomainconcretization(\abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)) \spacearound\cup \\
      \setdef{\defstate\in\state}{\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \defstate \in \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)}} && \tag{by $\abstractdomainfilter \semanticsof{\neg\defbexp}\defabstractvalue$} \\
    &\quad
      \subseteq\setof*{ \abstractdomainconcretization(\abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)) \spacearound\cup \\
      \abstractdomainconcretization(\abstractdomainfilter\semanticsof{\neg\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)) } && \tag{by $\abstractdomainjoin$} \\
    &\quad
      \subseteq\setof*{ \abstractdomainconcretization \left(\abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue) \spacearound\abstractdomainjoin
      \abstractdomainfilter\semanticsof{\neg\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue) \right)} && \tag{by \refeqshort{counter-backward-concretization}} \\
    &\quad
      = \backwardconcretization(\abstractdomainfilter\semanticsof{\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue) \spacearound\abstractdomainjoin
      \abstractdomainfilter\semanticsof{\neg\defbexp}(\counterbackwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue)) && \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      = \backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\ifstmt} \defabstractvalue)
  \end{align*}
  \begin{align*}
    &(\whilestmt) \\
    &\quad
      \counterbackwardreachabilitysemanticsnoparam \semanticsof{\whilestmt} \abstractdomainconcretization(\defabstractvalue) && \tag{by \refdefshort{backwardreachability-semantics}} \\
    &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\countertracesemanticsnoparam \semanticsof{\whilestmt} \abstractdomainconcretization(\defabstractvalue)}\} && \tag{by \refdefshort{counter-semantics}} \\
      &\quad
      =\{\setdef{\retrieveinput\deftrace}{\deftrace\in\lfp{}\fixpointfunction}\} && \tag{by $\lim_{n} \spacer \abstractdomainfixpoint_n$} \\
    &\quad
      \subseteq\setof{\setdef{\retrieveinput\deftrace}{\deftrace\in\abstractdomainconcretization(\lim_{n} \abstractdomainfixpoint_n)}} && \tag{by $\deftrace = \defstate$} \\
    &\quad
      =\setof{\setdef{\defstate}{\defstate\in\abstractdomainconcretization(\lim_{n} \abstractdomainfixpoint_n)}} && \tag{by set definition} \\
    &\quad
      =\setof{\abstractdomainconcretization(\lim_{n} \abstractdomainfixpoint_n)} && \tag{by \refeqshort{counter-backward-concretization}} \\
    &\quad
      =\backwardconcretization(\lim_{n} \abstractdomainfixpoint_n) && \tag{by \reffigshort{backward-semantics}} \\
    &\quad
      =\backwardconcretization(\counterbackwardsemanticsnoparam \semanticsof{\whilestmt} \defabstractvalue)
  \end{align*}
  As a consequence, the backward semantics $\counterbackwardsemantics$ is a sound over-approximation of the backward co-reachability semantics $\counterbackwardreachabilitysemantics$, \ie, $\counterbackwardreachabilitysemantics \SubseteQ \backwardconcretization(\counterbackwardsemantics)$.
\end{proof}

% &\countertracesemanticsnoparam \semanticsof{\skipstmt}\defsetoftraces \DefeQ
% \setdef{\concat{\defstate \defstate}{\deftrace}}{\defstate \in \state \land \deftrace\in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
% \\
% &\countertracesemanticsnoparam \semanticsof{\assignstmt}\defsetoftraces \DefeQ \\
% % \setdef{\defstate\in\state}{\defvalue \in \aexpsemantics \land \updatemem{\defstate}{\defvariable}{\defvalue} \in \defsetoftraces }
% &\quad \setdef{\concat{\defstate \updatemem{\defstate}{\defvariable}{\defvalue}}{\deftrace}}{\defstate \in \state \land \defvalue \in \aexpsemantics \defstate \land \deftrace\in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
% \\
% &\countertracesemanticsnoparam \semanticsof{\assertstmt}\defsetoftraces \DefeQ
% % \bexpsemantics\defsetoftraces
% \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
% \\
% &\countertracesemanticsnoparam \semanticsof{\ifstmt[\defstmt][\defstmt']}\defsetoftraces \DefeQ
% \\
% &\quad
% % \bexpsemantics(\countertracesemanticsnoparam \semanticsof{\defstmt}\defsetoftraces)
% % \bexpsemanticsnoparam\semanticsof{\neg\defbexp}(\countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces)
% \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt}\defsetoftraces} \SetjoiN {} \\
% &\quad \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces}
% \\
% &\countertracesemanticsnoparam \semanticsof{\whilestmt}\defsetoftraces \DefeQ
% \lfp{}\fixpointfunction\\
% % &\quad \fixpointfunction(X) \DefeQ \bexpsemanticsnoparam\semanticsof{\neg \defbexp} \defsetoftraces \SetjoiN  \bexpsemantics (\countertracesemanticsnoparam \semanticsof{\defstmt} \bwddecr(X))
% &\quad \fixpointfunction(X) \DefeQ
% \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defstate \land \concat{\defstate}{\deftrace} \in \defsetoftraces} \SetjoiN {} \\
% &\qquad   \setdef{\concat{\defstate}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \bexpsemantics \defstate \land \concat{\defstate}{\deftrace} \in \countertracesemanticsnoparam \semanticsof{\defstmt} \bwddecr(X)}
% \\
% &\countertracesemanticsnoparam \semanticsof{\compstmt[\defstmt][\defstmt']}\defsetoftraces \DefeQ
% \countertracesemanticsnoparam \semanticsof{\defstmt}( \countertracesemanticsnoparam \semanticsof{\defstmt'}\defsetoftraces)
% \\
% &\countertracesemanticsnoparam \semanticsof{\progstmt}\defsetoftraces \DefeQ \\
% % \countertracesemanticsnoparam \semanticsof{\defstmt}(\updatemem{\defsetoftraces}{\counter}{0})
% &\quad \countertracesemanticsnoparam \semanticsof{\defstmt}\setdef{\concat{\updatemem{\defstate}{\counter}{0}}{\deftrace}}{\defstate \in \state \land \deftrace \in \finiteoremptyinfinitesequences \land \concat{\defstate}{\deftrace} \in \defsetoftraces}
% \end{align*}

Next, we show how to quantify the impact of the input variables on the global loop counter $\counter$.
We employ the $\rangename$ impact quantifier, instrumented with $\counter$ as output variable, and we design a linear programming encoding to compute the abstract implementation of the impact $\range$.

\begin{example}
  We consider the \refprog*{add}, where states $\state$ are tuples $\langle p, m, n, nit\rangle$, respectively for the variables \texttt{p}, \texttt{m}, \texttt{n}, and the global loop counter $\counter$.
  Let us assume that the computation of the backward semantics on the program \add{} results in:
  \[
    \counterbackwardsemanticsnoparam\semanticsof{\add} \spacearound=
    (\texttt{p} = \counter)
  \]
  % For brevity, we consider states as $\state = \setdef{\langle p, m, n\rangle}{p, m, n\in[0, u]}$,
  Then, from \refdef*{concretization-of-conjunctions-of-linear-constraints}[*-15], the concretization of the abstract element $\texttt{p} = \counter$ is:
  \begin{align*}
    \abstractdomainconcretization(\texttt{p} = \counter) \spacearound= \setdef{\langle p, m, n, p\rangle}{p, m, n\in\values}
\end{align*}
where $\langle p, m, n, p\rangle$ is the concrete state in which the input variable \texttt{p} (first $p$ in the tuple) is equal to the loop counter $\counter$ (last $p$ in the tuple).
The goal of the concretization $\backwardconcretization$ is to over-approximate the backward co-reachability semantics $\counterbackwardreachabilitysemanticsnoparam\semanticsof\add$.
By concretizing any subset of $\abstractdomainconcretization(\texttt{p} = \counter)$ we obtain all the possible input states such that the input variable \texttt{p} is equal to the value of the global loop counter $\counter$, including the backward co-reachability semantics $\counterbackwardreachabilitysemanticsnoparam\semanticsof\add$.
\end{example}


\section{An Abstract Range Implementation via a Linear Programming Encoding}

We present a linear programming encoding $\counterrange\in\abstractdomain\to\valuesposplus$ to compute the abstract implementation of the impact $\range$ from the result of the global loop bound analysis $\counterbackwardsemanticsnoparam$.

\begin{definition}[$\counterrange$]\labdef{counterrange}
  Let $\counterbackwardsemanticsnoparam\in\counterbackwardtype$ be the global loop bound analysis and $\definputvariables\subseteq\inputvariables$ be the input variables of interest.
  For all programs $\defprogram$, $\counterrange(\counterbackwardsemantics)$ is defined as:
\begin{align}
  \label{eq:obj}
  \text{maximize} \spacer\spacer& \defbound \\
  \label{eq:a}
  \text{subject to} \spacer\spacer
    & \abstractdomainproject(\abstractdomainsubstitute{\counter}{\counterup}(\counterbackwardsemantics)) \\
    \label{eq:b}
    \land\spacer\spacer& \abstractdomainproject(\abstractdomainsubstitute{\counter}{\counterdown}(\counterbackwardsemantics)) \\
    \label{eq:slack}
    \land\spacer\spacer& 0 \le \defbound \le \counterup - \counterdown
\end{align}
where $\counterup,\counterdown$ are fresh variables.
\end{definition}
Since $\defbound$ should be an integer variable, we specifically solve a mixed-integer linear programming problem.
\refeq{a} substitutes the variable $\counter$ with $\counterup$ to account for the maximal value of the global loop counter $\counter$.
Then, it
projects away the input variables $\definputvariables$ to encompass any possible variation of that variables.
\refeq{b} substitutes the variable $\counter$ with $\counterdown$ for the minimal value of $\counter$, and again projects away the input variables $\definputvariables$.
Hence, the set of constraints from~\refeq{a} and~\refeq{b} only differ in the variable of the loop counter, respectively $\counterup$ and $\counterdown$.
Finally, the objective function, \cf{} \refeq{obj}, maximizes the value of the bound $\defbound$, which ranges between $0$ and $\counterup - \counterdown$, \cf~\refeq{slack}.
The maximum value of the bound $\defbound$ is the length of the range of the feasible values for the loop counter $\counter$.



\begin{example}
  We consider again the example of the \refprog{add}.
  Let us assume that $\texttt{p}\in[0,u]$ and the computation of the backward semantics on the program \add{} results in:
  \[
    \counterbackwardsemanticsnoparam\semanticsof{\add} \spacearound=
    (\texttt{p} = \counter \LanD 0 \le \texttt{p} \le u)
  \]
%
  To compute the abstract range $\counterrange[\{\texttt{p}\}]$ for the input variable \texttt{p}, we solve the linear programming problem~\refeq{obj}--\refeq{slack}.
  Where
  \refeq{a} and \refeq{b} are respectively:
  \begin{align*}
    &\abstractdomainproject[\{\texttt{p}\}](\abstractdomainsubstitute{\counter}{\counterup}(\texttt{p} = \counter \LanD 0 \le \texttt{p} \le u)) \\
      &\qquad\spacearound= \abstractdomainproject[\{\texttt{p}\}](\texttt{p} = \counterup \LanD 0 \le \texttt{p} \le u) \spacearound= 0 \le \counterup \le u \\
    &\abstractdomainproject[\{\texttt{p}\}](\abstractdomainsubstitute{\counter}{\counterdown}(\texttt{p} = \counter \LanD 0 \le \texttt{p} \le u)) \\
      &\qquad\spacearound= \abstractdomainproject[\{\texttt{p}\}](\texttt{p} = \counterdown \LanD 0 \le \texttt{p} \le u) \spacearound= 0 \le \counterdown \le u
  \end{align*}
  Therefore, the linear programming encoding for $\counterrange[\{\texttt{p}\}](\texttt{p} = \counter \LanD 0 \le \texttt{p} \le u)$ is defined as:
  \begin{align*}
    \text{maximize} \spacer\spacer& \defbound \\
    \text{subject to} \spacer\spacer
      & 0 \le \counterup \le u \\
      \land\spacer\spacer& 0 \le \counterdown \le u \\
      \land\spacer\spacer& 0 \le \defbound \le \counterup - \counterdown
  \end{align*}
  which maximizes at $u$. On the other hand, projecting away the other input variables leaves the invariant $\texttt{p} = \counter \LanD 0 \le \texttt{p} \le u$ unchanged. Thus, $\defbound$ maximizes at $0$ as the variable $\texttt{p}$ is equal to both $\counterup$ and $\counterdown$.
  Interestingly, we did not lose any precision regarding the $\defbound$-bounded impact property as $\range(\countertracesemanticsnoparam\semanticsof\add) = \counterrange(\counterbackwardsemanticsnoparam\semanticsof{\add})$ for all input variables $\definputvariables$ in the program \add.
\end{example}

\begin{marginfigure}
  \centering
    \begin{tikzpicture}[scale=0.73]
      % Grid
      \draw[help lines, color=gray!30, dashed] (-0.1,-0.1) grid (5.5,6.4);
      % Polyhedra
      \fill[color=seabornGreen, opacity=0.5] (0,0) -- (5,2) -- (5,6) -- (0,1) -- cycle;
      % line equations
      \draw (2.5,3.5) node[above,rotate=45] {$\texttt{y}+1$};
      \draw (3,1.2) node[below,rotate=22] {$\frac{2}{5}\cdot\texttt{y}$};
      % x-axis
      \draw[->,ultra thick] (0,0)--(5.5,0) node[above]{\texttt{y}};
      % y-axis
      \draw[->,ultra thick] (0,0)--(0,6.4) node[above]{\counter};
      % x right boundary
      \draw[dashed] (5,0) -- (5,6.4);
      % x-axis ticks
      \foreach \x in {0, 1,2,3,4, 5}
          \draw (\x,0.1) -- (\x,-0.1) node[below] {\x};
      % y-axis ticks
      \foreach \y in {1,2,3,4,5,6}
          \draw (0.1,\y) -- (-0.1,\y) node[left] {\y};
      % contours
      \fill[color=seabornGreen] (0,0) circle[radius=2pt];
      \fill[color=seabornGreen] (5,2) circle[radius=2pt];
      \fill[color=seabornGreen] (5,6) circle[radius=2pt];
      \fill[color=seabornGreen] (0,1) circle[radius=2pt];
      \draw[color=seabornGreen, ultra thick] (0.01,0) -- (5,2) -- (5,6) -- (0.01,1) -- cycle;
      % maximization line
      \draw[ultra thick, color=black] (5,2) -- (5,6);
      \draw (5,4) node[left] {$\defbound=4$};
      \draw[ultra thick, color=black] (4.9,2) -- (5.1,2);
      \draw[ultra thick, color=black] (4.9,6) -- (5.1,6);
    \end{tikzpicture}
    \caption{$\frac{2}{5}\cdot\texttt{y} \LE \counter \LE \texttt{y}+1$.}
    % \caption{Feasible region for $\texttt{x}$}
    \labfig{A}
  \end{marginfigure}
    \begin{marginfigure}
    \centering
    \begin{tikzpicture}[scale=0.73]
      % Grid
      \draw[help lines, color=gray!30, dashed] (-0.1,-0.1) grid (5.5,6.4);
      % Polyhedra
      \fill[color=seabornRed, opacity=0.5] (0,0) -- (5,1) -- (5,6) -- (0,5) -- cycle;
      % line equations
      \draw (1.5,5.25) node[above,rotate=11] {$\frac{1}{5}\cdot\texttt{x}+2$};
      \draw (4.3,0.9) node[below,rotate=11] {$\frac{1}{5}\cdot\texttt{x}$};
      % x-axis
      \draw[->,ultra thick] (0,0)--(5.5,0) node[above]{\texttt{x}};
      % y-axis
      \draw[->,ultra thick] (0,0)--(0,6.4) node[above]{\counter};
      % x right boundary
      \draw[dashed] (5,0) -- (5,6.4);
      % x-axis ticks
      \foreach \x in {0, 1,2,3,4, 5}
          \draw (\x,0.1) -- (\x,-0.1) node[below] {\x};
      % y-axis ticks
      \foreach \y in {1,2,3,4,5,6}
          \draw (0.1,\y) -- (-0.1,\y) node[left] {\y};
      % contours
      \fill[color=seabornRed] (0,0) circle[radius=2pt];
      \fill[color=seabornRed] (5,1) circle[radius=2pt];
      \fill[color=seabornRed] (5,6) circle[radius=2pt];
      \fill[color=seabornRed] (0,5) circle[radius=2pt];
      \draw[color=seabornRed, ultra thick] (0.01,0) -- (5,1) -- (5,6) -- (0.01,5) -- cycle;
      % maximization line
      \draw[ultra thick, color=black] (2.5,0.5) -- (2.5,5.5);
      \draw (2.5,3) node[left] {$\defbound=5$};
      \draw[ultra thick, color=black] (2.4,0.5) -- (2.6,0.5);
      \draw[ultra thick, color=black] (2.4,5.5) -- (2.6,5.5);
    \end{tikzpicture}
    \caption{$\frac{1}{5}\cdot\texttt{x} \LE \counter \LE \frac{1}{5}\cdot\texttt{x}+2$.}
    \labfig{B}

\end{marginfigure}
\begin{example}
  \labexample{difficult}
  In the previous example, the projection of \texttt{p} alone produced the invariant $0 \le \counter \le u$, which gives already the bound on the impact of the input variable \texttt{p} on the global loop counter $\counter$.
  We consider a more complex example to demonstrate the necessity of the linear programming encoding, in a scenario where the invariant computed by the global loop bound analysis does not already reveal the impact of input variables.
  Let us assume that the computation of the abstract dependency semantics for a program $\defprogram$ results in:
  \begin{align*}
    \counterbackwardsemantics \spacearound=\left(\frac{2}{5}\cdot\texttt{y}+\frac{1}{5}\cdot\texttt{x} \LE \counter \LE \texttt{y} + \frac{1}{5}\cdot\texttt{x} \LanD \texttt{x}, \texttt{y} \in [0, 5]\right)
  \end{align*}
  To compute the abstract range $\abstractrangename_{\texttt{x}}$ for the input variable \texttt{x}, we first project away the variable \texttt{x} from the abstract state, obtaining:
  \begin{align*}
    \frac{2}{5}\cdot\texttt{y} \LE \counter \LE \texttt{y}+1 \LanD \texttt{y} \in [0, 5]
  \end{align*}
  % The 2-dimensional representation of the feasible region is shown in \reffig{A}.
  Then, we solve the linear programming problem, where we substitute the variable $\counter$ with $\counterup$ and $\counterdown$ to respectively maximize and minimize the global loop counter $\counter$:
  \begin{align*}
    \text{maximize} \spacer\spacer& \defbound \\
    \text{subject to} \spacer\spacer & \frac{2}{5}\cdot\texttt{y} \LE \counterup \LE \texttt{y}+1 \LanD \texttt{y} \in [0, 5] \\
    \land\spacer\spacer& \frac{2}{5}\cdot\texttt{y} \LE \counterdown \LE \texttt{y}+1 \LanD \texttt{y} \in [0, 5] \\
    \land\spacer\spacer& 0 \LE \defbound \LE \counterup - \counterdown
  \end{align*}
  The linear programming encoding maximizes at $\defbound=4$ where $\texttt{y} = 5$, \reffig{A} shows graphically the feasible region and maximization point.
  %
  On the other hand, to compute the abstract range $\abstractrangename_{\texttt{y}}$ for the input variable \texttt{y}, we solve linear programming encoding where we project away the variable \texttt{y} from the abstract state, obtaining:
  \begin{align*}
    \text{maximize} \spacer\spacer& \defbound \\
    \text{subject to} \spacer\spacer & \frac{1}{5}\cdot\texttt{x} \LE \counterup \LE \frac{1}{5}\cdot\texttt{x}+2 \LanD \texttt{x} \in [0, 5] \\
    \land\spacer\spacer& \frac{1}{5}\cdot\texttt{x} \LE \counterdown \LE \frac{1}{5}\cdot\texttt{x}+2 \LanD \texttt{x} \in [0, 5] \\
    \land\spacer\spacer& 0 \LE \defbound \LE \counterup - \counterdown
    % \frac{1}{5}\texttt{x} \LE \counter \LE \frac{1}{5}\texttt{x}+2 \LanD \texttt{x} \in [0, 5]
  \end{align*}
  This second linear programming problem maximizes at $\defbound=5$ for any value of \texttt{x}, \reffig{B} shows graphically the feasible region and maximization point for this second programming problem.
  As a result, we obtain $\abstractrangename_{\texttt{x}}(\counterbackwardsemantics) = 4$ and $\abstractrangename_{\texttt{y}}(\counterbackwardsemantics) = 5$, showing that the variable \texttt{y} has a higher impact on the global loop counter $\counter$ than the variable \texttt{x}.
\end{example}


The next result shows that $\counterrange$ is a sound implementation of the impact $\range$, by means of \refdef*{sound-implementation} when applied to the $\le$ operator.
That is, the abstract quantity is always higher than the concrete counterpart.
% Note that, we relax the constraint about the output buckets, as this linear programming encoding does not need to concretize each possible concrete value for $\counter$ before performing the backward semantics.
% To some extent, the output buckets are handled symbolically.
\begin{lemma}[$\counterrange$ is a Sound Implementation of $\range$]
  \lablemma{counterrange-is-sound}
  For any program $\defprogram$,
  the following holds:
  \begin{equation*}
    \range(\countertracesemantics) \LE \counterrange(\counterbackwardsemantics)
  \end{equation*}
\end{lemma}
  \begin{proof}
    We show that $\range(\countertracesemanticsnoparam) \le \counterrange(\counterbackwardsemanticsnoparam)$ by contradiction.
    Let us assume that $\range(\countertracesemanticsnoparam) > \counterrange(\counterbackwardsemanticsnoparam)$ and $\counterrange(\counterbackwardsemanticsnoparam) = \defbound$.
    Then, by definition of $\range$, \cf{} \refdef*{range-nit}, there exists two concrete states, differing only in the value of $\definputvariables$, such that the difference in the value of the global loop counter $\counter$ is greater than $\defbound$.
    As a consequence, in the abstract implementation $\counterrange$, \cf{} \refdef*{counterrange} the distance between $\counterup$ and $\counterdown$ should maximize at a value greater than $\defbound$. This contradicts the assumption that $\defbound = \counterrange(\counterbackwardsemanticsnoparam)$.
%
    From \reflemma{candidate-backward}, and the fact that $\range$ is monotonic, \cf{} \reflemma{range-monotonic}, we conclude that:
    \begin{math}
      \range(\countertracesemanticsnoparam) \LE \counterrange(\counterbackwardsemanticsnoparam)
    \end{math}.
  \end{proof}
%
% Thus, by \refthm*{soundness} it holds that our static analysis is sound when employed to verify the property $\boundedrangele$.


Next, we show \nrefthm{soundness} instantiated with the abstract implementation $\counterrange$ and the comparison operator $\le$.



\begin{theorem}[Soundness of $\boundedrangele$]
  Let $\boundedrangele$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariables\in\setof\inputvariables$.
  Whenever, $\counterbackwardsemanticsnoparam$ is sound, \cf{} \refeq{sound-abstract-dependency-semantics},
  the following implication holds:
  \begin{align*}
    \counterrange(\counterbackwardsemantics) = \defbound' \land \defbound' \le \defbound \ImplieS \defprogram \satisfies \BOUNDEDRANGELE
  \end{align*}
\end{theorem}
\begin{proof}
  \reflemma{counterrange-is-sound} shows that $\counterrange$ is a sound implementation of $\range$, the proof follows directly by application of the \refthm*{soundness} instantiated with the abstract implementation $\counterrange$ and comparison operator $\le$.
\end{proof}

\section{Related Work}
\labsec{sas24-related-work}


Loop bound analyses are extensively studied in the literature, given their importance in various program analyses, including termination, Worst-Case Execution Time (WCET), and side-channel analysis. In this section, we discuss the most relevant works in these areas and compare them with our approach.

\paragraph{Worst-Case Execution Time.}
Worst-Case Execution Time (WCET) analysis aims to derive sound upper bounds on the execution time of programs, see \sidetextcite{Wilhelm2008} for a survey.
More specifically, determining an upper bound on the number of loop iterations is a particular instance of loop bound analysis~\sidecite{Cadek2018,Ermedahl2007}, which seeks to infer invariants on the iterations of individual loops. In contrast, global loop bound analyses consider the aggregate behavior of all loops within a program~\sidecite{Carbonneaux2015,Sinn2017}.
Our work is orthogonal to the existing literature on WCET and loop bound analysis because it does not generate invariants on the global number of iterations.
Instead, we focus on quantifying the impact of each input variable on the total number of loop iterations.
However, we leverage an underlying global loop bound analysis to understand the input-output relationship involving the global loop counter.


\paragraph{Side-Channels Analysis.}
Side-channel attacks exploit vulnerabilities in the implementation of cryptographic systems rather than targeting computational complexity directly \sidecite{Kocher1996}. These attacks, including those based on power consumption \sidecite{Kocher1999} and speculative executions \sidecite{Kocher2019,Lipp2020}, can leak sensitive information without physical tampering \sidecite{Wong2005}. Various methods have been developed to quantify the information leaked through side channels.

The quantitative analysis of side-channel attacks, first introduced by \sidetextcite{K_opf2007}, uses model counting and a greedy algorithm to manage the exponential growth of potential paths requiring examination. \sidetextcite{Phan2017,Phan2012} and \sidetextcite{Saha2023} apply symbolic execution to enumerate the equivalence classes of a program's output values and use entropy measures to quantify the information leakage. Building on these works, \sidetextcite{Malacaria2018} handles symbolic inputs interpreted probabilistically, producing provably under- and over-approximating bounds on the leakage (with respect to Shannon and min-entropy). Other static analyses, such as those by \sidetextcite{Assaf2017} and~\sidetextcite{Clark2007}, rely on abstract interpretation. Based on string analysis, \sidetextcite{Bang2016} presented an efficient technique for segmented oracles, where an attacker can explore each segment of secret data. \sidetextcite{Pasareanu2016} quantifies the information leaked to an attacker who performs multiple side-channel measurements.

Our approach diverges by quantifying the impact of each input variable separately, rather than providing a comprehensive quantification for all input variables.
This fine-grained analysis is essential for identifying specific variables that significantly influence program behavior.
This fine-grained analysis is crucial for identifying specific variables that significantly influence program behavior. While quantitative analyses could theoretically infer similar information, their entropy measures are not designed for this purpose (\cf{} \refsec{nfm24-related-work}), and they typically require $k$-times self-composition \sidecite{Barthe2011,Terauchi2005}, which is computationally intensive \sidecite{Antonopoulos2017}. Instead, our method requires only a single abstract analysis and uses variable projections to isolate the contributions of each input variable \sidecite{Urban2020,Mazzucato2021}.

Moving forward, the emergence of attacks exploiting microarchitectural features, such as out-of-order and speculative execution, diminishes the efficacy of traditional constant-time verification. Indeed, constant-time code may still vulnerable to timing attacks on processors with microarchitectural vulnerabilities \sidecite{Cauligi2020}. Recently, \textsc{OpenSSL} updated its security model to explicitly exclude physical system side-channels.\sidenote{(Last Accessed: 16th August 2024) \rurl{www.openssl.org/policies/secpolicy.html}} Related work \sidecite{Guarnieri2020,Bard2024} has proposed incorporating microarchitectural features into the analysis of timing side-channel attacks. Our approach could be extended to consider the impact of input variables in the context of out-of-order and speculative execution.

\paragraph{Termination Analysis.}


The program termination problem can be defined as whether a program will always finish running within a finite time frame, or could execute indefinitely.
It is rooted in the early 20th century mathematical logic, particularly in the Hilbert's Entscheidungsproblem.\sidenote{In English: ``decision problem.''} Turing's proof of the undecidability of the termination problem via disjunctive arguments is a cornerstone in the field \sidecite{Turing1937,Turing1949}.
Recent advancements in termination analysis have a significant impact in the literature, particularly those grounded in transition invariants as introduced in \textcite{Podelski2004}. Notably, the \textsc{Terminator} analyzer \sidecite{Cook2006} constructs iteratively these invariants to prove termination.

From the unifying work of existing approaches proposed by \sidetextcite{Cousot2012b},
Caterina Urban and Antoine Min{\'{e}} advanced the field in a series of works \sidecite{Urban2013,Urban2014a,Urban2014b,Urban2015a,Urban2017} by proving termination through the synthesis of ranking functions across all program paths within the framework of abstract interpretation.
Compared to other works \sidecite{Berdine2007,Heizmann2013}, their approach does not rely on counterexample-guided analysis or perform explicit checks on the well-foundedness of the termination argument. Their method, implemented in the tool \textsc{FuncTion} \sidecite{Urban2015b}, handles arbitrary control flow structures, unlike earlier methods \sidecite{Podelski2004,Bradley2005}. Similarly, \sidetextcite{Tsitovich2011} uses loop summarization to address termination, and \sidetextcite{Courant2017} refines \textsc{FuncTion}'s scalability and precision through fine-tuning and new heuristics for widening.

Many methods, such as those in \sidecite{Alias2010, Brockschmidt2013,Larraz2013}, indirectly leverage transition invariants. Among them, \textcite{Alias2010} explores the synthesis of ranking functions via linear programming, which is complete only for programs with rational values. \sidetextcite{Chatterjee2021} proposed a straightforward but effective approach to over-approximate non-terminating program states by synthesizing invariants through syntactic program reversal, handling programs with non-determinism and integer values. Additionally, the inference of preconditions for termination has been explored, with \sidetextcite{Cook2008} focusing on generating necessary preconditions, while \sidetextcite{Ganty2013,Mass_e2014} derive these by complementing over-approximations of non-terminating states.

State-of-the-art tools in this area include \textsc{VeryMax} \sidecite{Borralleras2017}, \textsc{AProVE} \sidecite{Giesl2017}, \textsc{Ultimate} \sidecite{Leike2018, Chen2018}, and \textsc{LoAT} \sidecite{Frohn2019}. Specifically, \textsc{VeryMax} \cite{Borralleras2017} searches for non-termination witnesses using quasi-invariants but lacks relative completeness guarantees \cite{Larraz2013}. \textsc{AProVE} \cite{Giesl2017} uses recurrence sets to prove non-termination in Java programs with non-determinism but has limitations with nested loops \sidetextcite{Brockschmidt2011}. The method by \sidetextcite{Urban2016} attempts to prove either termination or non-termination in programs with non-determinism by incrementally refining termination arguments and using a safety prover to identify non-terminating traces. Other approaches, such as those in \textsc{Ultimate} \cite{Leike2018, Chen2018}, use geometric series and constraint solving to handle deterministic programs. Computational efficiency and non-determinism remain significant challenges for termination provers; see \sidetextcite{Shi2022} for a comparison.
Recently, graph neural networks have also been employed to tackle (non-)termination under weaker (stochastic) guarantees \sidecite{Alon2022}.

The work presented in this chapter does not aim to prove termination but could significantly benefit from termination analysis to infer termination-aware quantities for the global loop counter. By understanding which input data leads to terminating executions, we could refine the impact quantification. At the current stage, an input variable that influences program termination but not the number of iterations might be incorrectly deemed unused.



\section{Summary}

This chapter presented a static analysis for quantifying the impact of input variables on the number of iterations of a program.
The following chapter presents the experimental evaluation of our approach and concludes the main body of this thesis.


\frenchdiv

\emph{Ce chapitre a présenté une analyse statique pour quantifier l'impact des variables d'entrée sur le nombre d'itérations d'un programme. Le chapitre suivant présente l'évaluation expérimentale de notre approche et conclut le corps principal de cette thèse.}
