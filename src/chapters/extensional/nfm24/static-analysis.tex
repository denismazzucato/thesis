\section{A Static Analysis for Quantitative Input Data Usage}
\labsec{static-analysis}

%
In this section, we introduce a sound computable static analysis to determine an upper bound on the impact of an input variable $\definputvariable$.
The soundness of the approach leverages two elements: $(1)$ an underlying abstract semantics $\backwardsemanticsnoparam$ to compute an over-approximation of the filter semantics $\filtersemanticsnoparam$; and $(2)$ a sound computable implementation of $\impactwrapper$, written $\impactinstance$, used in the property $\bounded$.

To quantify the usage of an input variable, we need to determine the input configurations leading to specific output values.
As our impact definitions $\outcomes$ and $\range$ measure over the different output values (i.e., $\reader(\retrieveoutput{\defstate})$) our underlying abstract semantics will be a \emph{backward} (co-)reachability semantics starting from \emph{disjoint} abstract post-conditions, over-approximating the (concrete) output values of the dependency semantics.
Specifically, we abstract the concrete output values with an indexed set $\buckets\in\vectorbuckets$ of $n$ disjoint \textit{output buckets}, where $\abstractdomainlattice$ is an abstract state domain with concretization function  $\abstractdomainconcretization\in\abstractdomain\to\setof\stateandbottom$. The choice of these output buckets is essential for obtaining a precise and meaningful analysis result.

For each output bucket $\bucket\in\abstractdomain$, our analysis computes an over-approximation of the dependency semantics restricted to the input configurations leading to $\abstractdomainconcretization(\bucket)$.
More formally, let $\reduce[\dependencysemanticsnoparam]{X} \defeq \setdef{\inputoutputtuple{\defstate}\in\dependencysemanticsnoparam}{\retrieveoutput{\defstate}\in X}$ be the reduction of the dependency semantics $\dependencysemanticsnoparam$ to the dependencies with final states in $X$.
%
Our static analysis is parametrized by an underlying backward abstract family\sidenote{A family of semantics is a set of program semantics parametrized by an initialization.}
of semantics $\backwardsemantics\in\backwardtype$ which computes the backward semantics $\backwardsemantics\bucket$ from a given output bucket $\bucket\in\abstractdomain$.
The concretization function $\backwardconcretization\in(\backwardtype)\to\abstractdomain\to\setof\pairofstates$ employs %the abstract concretization
$\abstractdomainconcretization$ to restore all possible input-output dependencies, \ie, $\backwardconcretization(\backwardsemantics)\bucket \defeq \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization(\backwardsemantics\bucket)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}$.
We can thus define the soundness condition for the backward semantics with respect to the reduction of the dependency semantics.

\begin{definition}[Sound Over-Approximation for \texorpdfstring{$\backwardsemanticsnoparam$}{the backward semantics}]\label{def:sound-over-approximation}
  For all programs $\defprogram$, and output bucket $\bucket\in\abstractdomain$, the family of semantics $\backwardsemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ reduced with  $\abstractdomainconcretization(\bucket)$, when it holds that:
  \[\reduceddependencysemantics \SubseteQ \backwardconcretization(\backwardsemantics)\bucket\]
\end{definition}

We define
$\multisemanticsnoparam\in\multitype$ as the backward semantics repeated on a set of output buckets $\buckets\in\vectorbuckets$, that is, $\multisemantics\buckets \defeq (\backwardsemantics\bucket)_{j\le n}$.
Again, the concretization function $\multiconcretization\in(\multitype)\to\vectorbuckets\to\setof\pairofstates$ employs the abstract concretization $\abstractdomainconcretization$ to restore all possible input-output dependencies over all the output buckets, \ie,
$\multiconcretization(\multisemantics)\buckets \defeq \bigsetjoin_{j\le n} \setdef{\inputoutputtuple{\defstate}}{\retrieveinput{\defstate}\in\abstractdomainconcretization((\multisemantics\buckets)_j)\land\retrieveoutput{\defstate}\in\abstractdomainconcretization(\bucket)}$.

\begin{lemma}[Sound Over-Approximation for \texorpdfstring{$\multisemanticsnoparam$}{the multi-bucket semantics}]\label{lm:sound-over-approximation-multi-bucket}
  For all programs $\defprogram$, output buckets $\buckets\in\vectorbuckets$, and a family of semantics $\backwardsemanticsnoparam$, the %multi-bucket family of
  semantics $\multisemanticsnoparam$ is a \textup{sound over-approximation} of the dependency semantics $\dependencysemanticsnoparam$ when reduced to $\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$:
  \[\reduce{\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)} \SubseteQ \multiconcretization(\multisemantics)\buckets\]
\end{lemma}

Whenever the output buckets \textit{cover} the whole output space, $\multisemanticsnoparam$ is a sound over-approximation of $\dependencysemanticsnoparam$.
The concept of covering for output buckets ensures that no final states of the dependency semantics, \ie{} $\finalstatesdependency\defeq\setdef{\retrieveoutput{\defstate}}{\inputoutputtuple\defstate\in\dependencysemanticsnoparam}$, are missed from the analysis.

\begin{definition}[Covering]\label{def:covering}
  We say that the output buckets $\buckets\in\vectorbuckets$ \textit{cover} the whole output space whenever $\finalstatesdependency\subseteq\bigsetjoin_{j\le n}\abstractdomainconcretization(\bucket)$.
\end{definition}

% \newcommand{\resultofbucketj}{\hiX_{j}}
% \newcommand{\resultofbucketjk}{\hiX_{j,k}}
% \newcommand{\resultofbucket}{\hiX}

Next, we expect a sound implementation $\impactinstance\in\pair\vectorbuckets\vectorbuckets\to\valuesinf$ to return a bound on the impact which is always higher than the concrete counterpart $\impactwrapper$.

\begin{definition}[Sound Implementation]\label{def:sound-implementation}
  For all output buckets $\buckets$ and family of semantics $\backwardsemanticsnoparam$, $\impactinstance$ is a \textup{sound implementation} of $\impactwrappername$, whenever
  \[
    \impactwrapper(
      \multiconcretization(\multisemantics)\buckets
    ) \LE \impactinstance(\multisemantics\buckets, \buckets)
  \]
\end{definition}

% \newcommand{\resultofproject}{\higher{Y}}
% \newcommand{\resultofprojectj}{\higher{Y}_{j}}
% \newcommand{\resultofprojectjk}{\higher{Y}_{j,k}}


The next result shows that our static analysis is sound when employed to verify the property of interest $\bounded$ for the program $\defprogram$.
That is, if %the computation of
$\impactinstance$ returns the bound $\defbound'$, and $\defbound'\le\defbound$, then the program $\defprogram$ satisfies the property $\bounded$, \cf{} $\defprogram \satisfies \bounded$.


\begin{theorem}[Soundness] \label{th:soundness}
  Let $\bounded$ be the property of interest we want to verify for the program $\defprogram$ and the input variable $\definputvariable\in\inputvariables$.
  Whenever,
  \begin{enumerate}[label=(\roman*)]
    \item $\backwardsemanticsnoparam$ is sound with respect to $\dependencysemanticsnoparam$, \cf{} \refdef{sound-over-approximation}, and
    \item $\buckets$ covers the whole output space, \cf{} \refdef{covering}, and
    \item $\impactinstance$ is a sound implementation of $\impactwrapper$, \cf{} \refdef{sound-implementation},
  \end{enumerate}
  the following implication holds:
  \begin{align}
    \impactinstance(\multisemantics\buckets, \buckets) = \defbound' \LanD \defbound' \le \defbound \ImplieS \defprogram \satisfies \bounded
  \end{align}
\end{theorem}

Finally,
we define $\abstractrange$ and $\abstractoutcomes$
as possible implementations for $\range$ and $\outcomes$, respectively.
%
We assume the underlying abstract state domain $\abstractdomain$ is equipped with an
operator $\abstractdomainproject\in\abstractdomain\to\abstractdomain$
to project away the input variable $\definputvariable$.
For example, in the context of the interval domain, where each input variable is related to a possibly unbounded lower and upper bound, $\abstractdomainproject(\langle\definputvariable \mapsto [1, 3], j \mapsto [2, 4]\rangle) = \langle \definputvariable \mapsto [-\infty, \infty], j \mapsto [2, 4] \rangle$
removes the constraints related to $\definputvariable$.

The definition of $\abstractoutcomes$ first projects away the input variable $\definputvariable$ from all the given abstract values, then it collects all intersecting abstract values via the meet operator $\abstractdomainmeet$.
These intersections represent potential concrete input configurations where variations on the value of $\definputvariable$ lead to changes of program outcome, from a bucket to another.
We return the maximum number of abstract values that intersects after projections:
\begin{equation}\label{eq:abstract-outcomes}
  \abstractoutcomes(X^\natural, \buckets) \defeq \max~\setdef{\cardinalitynospaces{J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
\end{equation}
Note the use of $\max$ instead of $\sup$ as in the concrete counterpart (\refeq{outcomes}) since the number of intersecting abstract values is bounded by $n$, i.e., the number of output buckets.
The function $\intersectallfunction$ takes as input an indexed set of abstract values and returns the set of indices of abstract values that intersect together, defined as follows:
\begin{equation*}
  \intersectallfunction(X^\natural\in\vectorbuckets) \defeq \setdef{J}{J \subseteq \N \land \forall j\le n, p\le n.~ j\in J \land p\in J \LanD X^\natural_j \abstractdomainmeet X^\natural_{p}}
\end{equation*}
Finding all the indices of intersecting abstract values is equivalent to find cliques in a graph, where each node represents an abstract value and an edge exists between two nodes if and only if the corresponding abstract values intersect.
Therefore, $\intersectallfunction$ can be efficiently implemented based on the graph algorithm by~\sidecite{Bron1973}.

Similarly, we define $\abstractrange$ as the maximum length of the range of the extreme values of the buckets represented by intersecting abstract values after projections.
In such case, we assume $\abstractdomain$ is equipped with an additional abstract operator $\abstractdomainlength\in\abstractdomain\to\valuesposplus$, which returns the length of the given abstract element, otherwise $+\infty$ if the abstract element is unbounded or represents multiple variables.
\begin{align}\label{eq:abstract-range}
  \abstractrange(X^\natural, \buckets) \DefeQ& \max~\seTDef{\abstractdomainlength(K)}{K \in I} \\
  \text{where}~
    I ~=~& \seTDef{\abstractdomainjoin\seTDef{\bucket}{j\in J}}{J \in \intersectallfunction((\abstractdomainproject(X^\natural_j))_{j\le\numberofbuckets})}
\end{align}
