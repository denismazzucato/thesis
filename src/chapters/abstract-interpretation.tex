
\pagelayout{wide} % No margins
\addpart{Background}
\labpart{background}
\pagelayout{margin} % Restore margins


\setchapterpreamble[u]{\margintoc}


\chapter{Abstract Interpretation}
\labch{abstract-interpretation}


\marginemptybox{11.4cm}

In this chapter, we introduce the concepts that are the foundation of this work.
We assume basic knowledge of mathematics, we summarize the necessary background in set theory and logic.
We present an overview of Abstract Interpretation and define the notations and concepts that will be used in the rest of the thesis.

\emph{Dans ce chapitre, nous introduisons les concepts qui constituent la base de ce travail. Nous supposons une connaissance de base en mathématiques, nous résumons les éléments nécessaires en théorie des ensembles et en logique. Nous présentons un aperçu de l'interprétation abstraite et définissons les notations et concepts qui seront utilisés dans le reste de la thèse.}

\section{Set Theory}

Here, we briefly revisit well-known concepts to establish the logical and mathematical notation.

\subsection{Logic Notation}

We write $p \defeq P$ to define the mathematical object $p$ to be equal to the object $P$.
Let $\B \defeq \{\true, \false\}$ be the set of Boolean values, where $\true$ represents true and $\false$ represents false.
We can state properties by logical predicates,\sidenote{For instance, $x \le x + 1$ is a basic logical predicate} where a predicate is a function that returns a Boolean value.
Often, we say that the predicate $P$ holds whenever $P = \true$.
We combine predicates using logical connectives: $\land$ for conjunction, $\lor$ for disjunction, $\neg$ for negation, $\implies$ for implication (respectively, $\Leftarrow$ for reverse implication), and $\iff$ for if and only if, as well as $\forall$ for universal and $\exists$ for existential quantification.
In the logical predicate $P \implies Q$, $P$ is called the premise and $Q$ the conclusion.
We call $P$ the \emph{sufficient} condition for $Q$ to hold and, conversely, $Q$ the \emph{necessary} condition for $P$ to hold.
In $P \iff Q$, $P$ is a necessary and sufficient condition for $Q$ to hold, and vice versa.
$P \implies Q$ holds \emph{vacuously} when $P$ is false or when $Q$ is true.
We write $P \defiff Q$ to denote that $P$ is defined to hold whenever $Q$ holds.

\subsection{Sets}


A set $X$ is an unordered collection of distinct elements. We use $x \in X$ (respectively, $x \notin X$) to indicate that $x$ is (respectively, is not) an element of the set $X$. A set is expressed in extension when it is uniquely determined by its elements: \eg, $\{x, y\}$ represents the set containing elements $x$ and $y$. The empty set is denoted by $\emptyset$ and no element belong to it, \ie, $\foralldef{x}{x \notin \emptyset}$.
A singleton $\{x\}$ is a set containing only one element $x$.
A set is defined in comprehension\sidenote{Set comprehension notation will be, in particular, pervasively used in the rest of this thesis.} when its elements are characterized by a common property: $\setdef{x \in X}{P(x)}$ denotes the set of elements $x\in X$ for which $P(x)$ holds.
% In particular, $P$ is a logical predicate that either holds or does not.
% Let $\B \defeq \{\true, \false\}$ be the set of Boolean values, where $\true$ represents true ($P = \true$ means that $P$ holds) and $\false$ represents false ($P = \false$ means that $P$ does not hold).
% We combine predicates using logical connectives: $\land$ for conjunction, $\lor$ for disjunction, $\neg$ for negation, $\implies$ for implication (respectively, $\Leftarrow$ for reverse implication), and $\iff$ for if and only if, as well as $\forall$ for universal and $\exists$ for existential quantification.
% In the logical predicate $P \implies Q$, $P$ is called the premise and $Q$ the conclusion.
% We call $P$ the \emph{sufficient} condition for $Q$ to hold and, conversely, $Q$ the \emph{necessary} condition for $P$ to hold.
% In $P \iff Q$, $P$ is a necessary and sufficient condition for $Q$ to hold, and vice versa.
% $P \implies Q$ holds \emph{vacuously} when $P$ is false or when $Q$ is true.
Contradictions such as circular definitions, \eg, $X \defeq \setdef{x}{x \notin X}$, are avoided in this thesis.
The cardinality of a set $X$ is represented by $\cardinalitynospaces{X}$, \eg, $\cardinalitynospaces{\emptyset} = 0$ and $\cardinalitynospaces{\{x, y\}} = 2$.

A set $X$ is a subset of another set $X'$, denoted $X \subseteq X'$, if every element of $X$ is also an element of $X'$. The empty set $\emptyset$ is subset of any set. The power set $\setof{X}$ of a set $X$ is defined as the set of all the subsets of $X$, \ie, $\setof{X} \defeq \setdef{X'}{X' \subseteq X}$. The union of two sets $X$ and $Y$, denoted $X \setjoin Y$, is the set containing all elements of $X$ and all elements of $Y$, \ie, $X \setjoin Y \defeq \setdef{x}{x \in X \lor x \in Y}$. More generally, the union of a set of sets $X$ is denoted by $\bigsetjoin X$, \ie, $\bigsetjoin X \defeq \bigsetjoin_{X' \in X} X' = \setdef{x}{\existsdef{X' \in X}{x \in X'}}$. The intersection $X \setmeet Y$ of two sets $X$ and $Y$ is the set of all elements that are common to both $X$ and $Y$, \ie, $X \setmeet Y \defeq \setdef{x}{x \in X \land x \in Y}$.
Similarly to the set union, we generalize the intersection to a set of sets $X$ by defining $\bigsetmeet X$ as $\bigsetmeet X \defeq \bigsetmeet_{X' \in X} X' = \setdef{x}{\foralldef{X' \in X}{x \in X'}}$. The relative complement of a set $Y$ in a set $X$, denoted $X \setminus Y$, is the set of all elements of $X$ that are not elements of $Y$, \ie, $X \setminus Y \defeq \setdef{x}{x \in X \land x \notin Y}$. When $Y \subseteq X$ and the set $X$ is clear from the context, we simply write $\neg Y$ for $X \setminus Y$ and we call it the complement of $Y$.
A tuple is an ordered list of elements, \eg, $\langle x_1, \dots, x_n \rangle$ is a tuple of $n$ elements, also called $n$-tuple. Differently from sets, the order of elements in a tuple is significant, \eg, $\langle x, y \rangle \neq \langle y, x \rangle$.
A pair\sidenote{
  Formally, a pair $\tuple{x}{y}$ can be defined as the set $\{\{x\}, \{x, y\}\}$ \cite{Kuratowski1921}.
  Thus, the first coordinate $\tuple{x}{y}_1$ is $z$ such that $\forall X \in \tuple{x}{y}$ it holds that $z \in X$.
  The second coordinate $\tuple{x}{y}_2$ is $z$ such that $\exists X \in \tuple{x}{y}$ such that $z \in X$ and that $\forall X, X' \in \tuple{x}{y}$ it holds that if $X \neq X'$ then $z \notin X$ or $z \notin X'$.
  We have that, $\tuple{x}{y}_1 = x$ and $\tuple{x}{y}_2 = y$.
}\phantomcite{Kuratowski1921} is a tuple of two elements, \eg, $\langle x, y \rangle$ is a pair where the first element is $x$ and the second $y$.
The Cartesian product of two sets $X$ and $Y$, denoted $X \times Y$, is the set of all pairs where the first component is an element of $X$ and the second component is an element of $Y$, \ie, $X \times Y \defeq \setdef{(x, y)}{x \in X \land y \in Y}$.
More generally, $X_1 \times \cdots \times X_n \defeq \setdef{(x_1, \ldots, x_n)}{x_1 \in X_1 \land \cdots \land x_n \in X_n}$ denotes the set of all $n$-tuples from elements of $X_1, \dots, X_n$, and $X^n$ when $X_1 = \cdots = X_n = X$.
The selection of the
$i$-th element of a tuple
$\langle{x_1, \dots, x_n}\rangle$ is denoted by the subscript notation, \ie,
${\langle{x_1, \dots, x_n}\rangle}_i = x_i$ for
$1 \le i \le n$.

A covering of a set $X$ is a set $Z$ of non-empty subsets of $X$ such that every element $x \in X$ belongs to a set in $Z$, \ie, $X = \bigsetjoin Z$. A partition of a set $X$ is a covering $Z$ such that any two sets in $Z$ are disjoint, \ie, every element $x \in X$ belongs to a unique set in $Z$, \ie, $\forall X, Y \in Z : X \neq Y \implies X \setmeet Y = \emptyset$.


\subsection{Numbers}

Let $\N$, $\Z$, and $\R$ be the set of all naturals, integers, and reals, respectively.
In general, whenever the precise numerical type is not known or required, we write $\values\in\{\N, \Z, \R\}$ denoting any possible set of numbers.
We write $\valuesinf$ to denote $\values$ extended with the symbols $-\infty$ and $+\infty$.
The set $\values_{\ge 0}$ denotes the set of non-negative numbers, \ie, $\values_{\ge 0} \defeq \setdef{n \in \values}{n \geq 0}$.
Similarly, we can use this notation with other predicates, for instance, $\values_{\le m} \defeq \setdef{n \in \values}{n \le m}$ denotes the set of numbers less than or equal to $m$.
As we did not specify whether natural numbers include zero, this notation comes in handy as it permits us to be explicit about the inclusion of zero.
For example, $\N_{\ge 0}^{+\infty}$ denotes the set of natural numbers including zero and $+\infty$, on the other hand, $\N_{> 0}$ denotes the set of strictly positive natural numbers.

Given two bounds $l, u \in \values$, we define the interval $[l, u]$ as the set of numbers between $l$ and $u$, \ie, $[l, u] \defeq \setdef{n \in \values}{l \le n \le u}$. Hence, $[l, u] = \emptyset$ when $l > u$.
For the sake of compactness, we may write both the logical predicate and the numerical type in the same notation, \eg, to define two natural numbers $x, y$ that are not equal, we could write $x \neq y \in \N$ instead of $x, y \in \N \land x \neq y$.


\subsection{Relations}
A binary relation $R$ between two sets $X$ and $Y$ is a subset of the cartesian product $X \times Y$.
The following are some important properties which may hold for a binary relation $R$ over a set $S$:
\begin{description}
    \item[Reflexivity]: $\forall x \in S : \tuple{x}{x} \in R$
    \item[Irreflexivity]: $\forall x \in S : \tuple{x}{x} \notin R$
    \item[Symmetry]: $\forall x, y \in S : \tuple{x}{y} \in R \implies \tuple{x}{y} \in R$
    \item[Antisymmetry]: $\forall x, y \in S : \tuple{x}{y} \in R \wedge \tuple{x}{y} \in R \implies x = y$
    \item[Transitivity]: $\forall x, y, z \in S : \tuple{x}{y} \in R \wedge \tuple{y}{z} \in R \implies \tuple{x}{z} \in R$
    \item[Totality]: $\forall x, y \in S : \tuple{x}{y} \in R \vee \tuple{x}{y} \in R$
\end{description}

An \emph{equivalence} relation is a binary relation which is reflexive, symmetric, and transitive. A binary relation which is reflexive (resp. irreflexive), antisymmetric, and transitive is called a \emph{partial order} (resp. \emph{strict partial order}). A \emph{preorder} is reflexive and transitive, but not necessarily antisymmetric. A \emph{total order} is a (strict) partial order which is total, \ie, any two elements of the given set are comparable (\cf{} totality).




\subsection{Ordered Sets}
\labsec{ordered-sets}

A partially ordered set (poset in short) is defined as sets equipped with a partial order relation.

\begin{definition}[Partially Ordered Set]\labdef{poset}
  A \emph{partially ordered set} (poset) $\langle X, \sqsubseteq \rangle$ is a set $X$ equipped with a partial order relation $\sqsubseteq\in\setof{X\times X}$, that is reflexive ($\forall x \in X.\spacer x \sqsubseteq x$), transitive ($\forall x, y, z \in X.\spacer x \sqsubseteq y \land y \sqsubseteq z \implies x \sqsubseteq z$), and antisymmetric ($\forall x, y \in X.\spacer x \sqsubseteq y \land y \sqsubseteq x \implies x = y$).
\end{definition}

\begin{marginfigure}
  \centering
  \begin{tikzpicture}[scale=0.8]
    \node (a) at (0,0) {$\emptyset$};
    \node (b) at (-2,2) {$\{a\}$};
    \node (c) at (0,2) {$\{b\}$};
    \node (d) at (2,2) {$\{c\}$};
    \node (e) at (-2,4) {$\{a,b\}$};
    \node (f) at (0,4) {$\{a,c\}$};
    \node (g) at (2,4) {$\{b,c\}$};
    \node (h) at (0,6) {$\{a,b,c\}$};

    \draw (a) -- (b);
    \draw (a) -- (c);
    \draw (a) -- (d);
    \draw (b) -- (e);
    \draw (b) -- (f);
    \draw (c) -- (e);
    \draw (c) -- (g);
    \draw (d) -- (f);
    \draw (d) -- (g);
    \draw (e) -- (h);
    \draw (f) -- (h);
    \draw (g) -- (h);
  \end{tikzpicture}
  \caption{Hasse diagram for the partially ordered set $\langle \setof{\{a, b, c\}}, \subseteq \rangle$.}
  \labfig{hasse_diagram}
  \end{marginfigure}

A finite partially ordered set $\langle D, \sqsubseteq \rangle$ can be represented by a Hasse diagram such as the one in~\reffig{hasse_diagram}: each element $x \in X$ is uniquely represented by a node of the diagram, and there is an edge from a node $x \in X$ to a node $y \in X$ if $y$ covers $x$, that is, $x \sqsubseteq y$ and there exists no $z \in X$ such that $x \sqsubseteq z \sqsubseteq y$. Hasse diagrams are usually drawn placing the elements higher than the elements they cover.

\begin{remark}
  Note that, for \emph{any} set of elements $X$, $\langle X, \subseteq \rangle$ is a poset ordered by set inclusion $\subseteq$.
\end{remark}

\begin{marginfigure}
  \centering
  \begin{tikzpicture}
    \node (a) at (-1,0) {$a$};
    \node (b) at (-2,2) {$b$};
    \node (c) at (0,2) {$c$};

    \draw (a) -- (b);
    \draw (a) -- (c);
  \end{tikzpicture}
  \caption{Hasse diagram for the poset $\langle \setof{a, b, c}, \{(a, b), (a, c)\}\rangle$.}
  \labfig{posetA}
  \end{marginfigure}

\begin{marginfigure}
  \centering
  \begin{tikzpicture}
    \node (a) at (0,0) {$a$};
    \node (b) at (0,2) {$b$};
    \node (c) at (2,0) {$c$};
    \node (d) at (2,2) {$d$};

    \draw (a) -- (b);
    \draw (c) -- (d);
  \end{tikzpicture}
  \caption{Hasse diagram for the poset $\langle \setof{a, b, c, d}, \{(a, b), (c, d)\}\rangle$.}
  \labfig{posetB}
  \end{marginfigure}

\begin{example}
  To draw a few examples: \reffig{posetA} represents the poset $\langle \setof{a, b, c}, \{(a, b), (a, c)\}\rangle$; and \reffig{posetB} represents the poset $\langle \setof{a, b, c, d}, \{(a, b), (c, d)\}\rangle$.
\end{example}

Next we introduce some important concepts related to partially ordered sets.
Let $\langle X, \sqsubseteq \rangle$ be a partially ordered set and $X'$ be a subset of $X$.
\begin{description}
  \item[Greatest Element] When it exists, the greatest element of $X$ (or top) is denoted by $\top$: $\forall x \in X.\spacer x \sqsubseteq \top$.
  \marginnote{Note that, any partially ordered set can always be equipped with a least (resp. greatest) element by adding a new element that is smaller (resp. greater) than every other element.}
  \item[Least Element] When it exists, the least element of $X$ (or bottom) is denoted by $\bot$: $\forall x \in X.\spacer \bot \sqsubseteq x$.
  \item[Maximal Element] An element $x \in X$ is maximal in $X$ if, $\forall y \in X.\spacer x \sqsubseteq y$ implies $x = y$.
  \item[Maximum] A maximal element $x \in X$ is a maximum of $X$ if it is unique.
  \item[Minimal Element] Dually, an element $x \in X$ is minimal in $X$ if, $\forall y \in X.\spacer y \sqsubseteq x$ implies $x = y$.
  \item[Minimum] A minimal element $x \in X$ is a minimum of $X$ if it is unique.
  \item[Upper Bound] An element $x \in X$ is an upper bound of $X'$ if, $\forall y \in X'.\spacer y \sqsubseteq x$.
  \item[Lower Bound] Dually, an element $x \in X$ is a lower bound of $X'$ if, $\forall y \in X'.\spacer x \sqsubseteq y$.
  \item[Least Upper Bound] When it exists, the least upper bound (lub) of $X'$ is denoted by $\join X'$: it is an upper bound $x \in X$ of $X'$ such that, for every upper bound $x' \in X$ of $X'$, $x \sqsubseteq x'$.
  \item[Greatest Lower Bound] When it exists, the greatest lower bound (glb) of $X'$ is denoted by $\meet X'$: it is a lower bound $x \in X$ of $X'$ such that, for every lower bound $x' \in X$ of $X'$, $x' \sqsubseteq x$.
\end{description}

% Let $\langle D, \le \rangle$ be a partially ordered set. The least element of the poset, when it exists, is denoted by $\bot$: $\forall d \in D : \bot \le d$. Similarly, the greatest element of the poset, when it exists, is denoted by $\top$: $\forall d \in D : d \le \top$. Note that any partially ordered set can always be equipped with a least (resp. greatest) element by adding a new element that is smaller (resp. greater) than every other element. Let $X \subseteq D$. A maximal element of $X$ is an element $d \in X$ such that, for each $x \in X$, $x \le d$. When $X$ has a unique maximal element, it is called maximum and it is denoted by $\max X$. Dually, a minimal element of $X$ is an element $d \in X$ such that, for each $x \in X$, $d \le x$. When $X$ has a unique minimal element, it is called minimum and it is denoted by $\min X$. An upper bound of $X$ is an element $d \in D$ (not necessarily belonging to $X$) such that, for each $x \in X$, $x \le d$. The least upper bound (or lub, or supremum) of $X$ is an upper bound $d \in D$ of $X$ and such that, for every upper bound $d' \in D$ of $X$, $d \le d'$. When it exists, it is unique and denoted by $\bigvee X$ (or $\sup X$). Dually, a lower bound of $X$ is an element $d \in D$ such that, for each $x \in X$, $d \le x$. The greatest lower bound (or glb, or infimum) of $X$ is a lower bound $d \in D$ of $X$ such that, for every lower bound $d' \in D$ of $X$, $d' \le d$. When it exists, it is unique and denoted by $\bigwedge X$ (or $\inf X$). Note that the notion of maximal element, maximum, and least upper bound (resp. minimal element, minimum, and greatest lower bound) are different, as illustrated by the following example.

% \begin{example}
% Let us consider the partially ordered set $\langle \setof(\{a, b, c\}), \subseteq \rangle$ represented in \reffig{hasse_diagram} and the subset $X' \defeq \{\{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}\}$, . The maximal elements of $X$ are $\{a, b\}$, $\{a, c\}$, and $\{b, c\}$. Thus, the maximum $\max X$ of $X$ does not exist, while its least upper bound is $\sup X = \{a, b, c\}$. Similarly, the minimal elements of $X$ are $\{a\}$, $\{b\}$, and $\{c\}$. Thus, the minimum $\min X$ of $X$ does not exist, while its greatest lower bound is $\inf X = \emptyset$.
% \end{example}


\begin{marginfigure}
  \centering
  \begin{tikzpicture}[scale=0.8]
    \node (a) at (0,0) {$\emptyset$};
    \node (b) at (-2,2) {$\{a\}$};
    \node (c) at (0,2) {$\{b\}$};
    \node (d) at (2,2) {$\{c\}$};
    \node (e) at (-2,4) {$\{a,b\}$};
    \node (f) at (0,4) {$\{a,c\}$};
    \node (g) at (2,4) {$\{b,c\}$};
    \node (h) at (0,6) {$\{a,b,c\}$};

    \draw (a) -- (b);
    \draw (a) -- (c);
    \draw (a) -- (d);
    \draw (b) -- (e);
    \draw (b) -- (f);
    \draw (c) -- (e);
    \draw (c) -- (g);
    \draw (d) -- (f);
    \draw (d) -- (g);
    \draw (e) -- (h);
    \draw (f) -- (h);
    \draw (g) -- (h);

    % subset X'
    \draw[seabornBlue, thick, dashed, rounded corners] (-2.9, .7) rectangle (2.9, 5.3);
    \node[seabornBlue] at (3.3, 4.2) {$X'$};

    % maximals of X'
    \draw[seabornGreen, thick, dashed, rounded corners] (-2.7, 3.5) rectangle (2.7, 4.5);
    \node[seabornGreen, fill=white] at (1.8, 4.9) {Maximals};

    % minimals of X'
    \draw[seabornRed, thick, dashed, rounded corners] (-2.7, 1.5) rectangle (2.7, 2.5);
    \node[seabornRed, fill=white] at (-1.8, 1.1) {Minimals};

    % lub of X'
    \draw[seabornYellow, thick, dashed, rounded corners] (-0.4, -0.5) rectangle (0.4, .5);
    \node[seabornYellow, fill=white] at (1, 0) {Lub};

    % glb of X'
    \draw[seabornOrange, thick, dashed, rounded corners] (-0.9, 5.5) rectangle (0.9, 6.5);
    \node[seabornOrange, fill=white] at (1.4, 6) {Glb};
  \end{tikzpicture}
  \caption{Maximal and minimal elements of the subset $X'$, as well as its least upper and greatest lower bounds.}
  \labfig{elements}
  \end{marginfigure}

\begin{example}
  Let us consider the partially ordered set $\langle \setof{\{a, b, c\}}, \subseteq \rangle$ and the subset $X' \defeq \{\{a\}, \{b\}, \{c\}, \{a, b\}, \{a, c\}, \{b, c\}\}$, represented in blue in \reffig{elements}.
  The maximal elements of $X'$ are $\{a, b\}$, $\{a, c\}$, and $\{b, c\}$, labelled ``Maximals'' in green. As we notice, the maximum of $X'$ does not exist, while its least upper bound is $\join X' = \{a, b, c\}$, labelled ``Lub'' in yellow.
  The minimal elements of $X'$ are $\{a\}$, $\{b\}$, and $\{c\}$, labelled ``Minimals'' in red. As we notice, the minimum of $X'$ does not exist, while its greatest lower bound is $\meet X' = \emptyset$, labelled ``Glb'' in orange.
\end{example}



A set equipped with a total order is a \emph{totally ordered set}. A \emph{chain} is a totally ordered subset $Y$ of a poset $\langle X, \sqsubseteq \rangle$. A chain is \emph{ascending} if the sequence of elements is increasing, \ie, $\forall i \in \{1, \ldots, n-1\}.\spacer y_i \sqsubseteq y_{i+1}$, and \emph{descending} if the sequence of elements is decreasing, \ie, $\forall i \in \{1, \ldots, n-1\}.\spacer y_{i+1} \sqsubseteq y_i$. A partially ordered set $\langle X, \sqsubseteq \rangle$ satisfies the \emph{ascending chain condition} if  and only if any infinite ascending chain $y_1 \sqsubseteq y_2 \sqsubseteq \ldots$ has an upper bound in $X$. Dually, it satisfies the \emph{descending chain condition} if and only if any infinite descending chain $y_1 \sqsupseteq y_2 \sqsupseteq \ldots$ has a lower bound in $X$.
A partially ordered set $\langle X, \sqsubseteq \rangle$ is \emph{well-founded} if and only if there are no infinite descending chains without a lower bound in $X$.

\begin{example}
  Let $x!$ be the factorial of $x$, defined as $x! = x \times (x-1) \times \ldots \times 1$ for $x\in\N$.
  The sequence $(x!)_{x\in\N}$ is an infinite ascending chain in the poset $\langle \N, \le \rangle$:
  \[ 1 \le 2 \le 6 \le 24 \le 120 \le \ldots \]
  Hence, the poset $\langle \N, \le \rangle$ does not satisfy the ascending chain condition.
  On the other hand, any possible decreasing chain in $\langle \N, \le \rangle$ has a lower bound, at least $0$, hence it satisfies the descending chain condition and is well-founded.
\end{example}

\marginnote{Note that, since the empty set is a chain, a complete partial order has a least element, \ie, $\bot = \join \emptyset$.}
\begin{definition}[Complete Partial Order]\labdef{cpo}
  A \emph{complete partial order} (CPO) is a partially ordered set $\langle X, \subseteq \rangle$ such that every chain $Y$ has a least upper bound $\join Y$ in $X$.
\end{definition}

As a consequence, any partial ordered set that satisfies the ascending chain condition and is equipped with a least element is a complete partial order.

\subsection{Lattices}
\labsec{lattices}

Lattices are posets that require every nonempty finite subset to have both a least upper bound and a greatest lower bound.

\marginnote{Any totally ordered set is a lattice.}
\begin{definition}[Lattice]\labdef{lattice}
  A \emph{lattice} $\langle X, \sqsubseteq, \join, \meet \rangle$ is a poset where $\forall x, x'\in X$ the least upper bound $\join\{x, x'\}$ and the greatest lower bound $\meet\{x, x'\}$ exist.
\end{definition}

Complete lattices are lattices that additionally require every (possibly infinite) subset to have both a least upper bound and a greatest lower bound.

\begin{definition}[Complete Lattice]\labdef{complete-lattice}
  A \emph{complete lattice} $\langle X, \sqsubseteq, \join, \meet, \bot, \top \rangle$ is a lattice where $\forall X' \subseteq X$ the least upper bound $\join X'$ and the greatest lower bound $\meet X'$ exist.
  Complete lattices have both a least element $\bot \defeq \meet X$ and a greatest element $\top \defeq \join X$.
\end{definition}

\begin{marginfigure}
  \centering
  \begin{tikzpicture}
    \node (0) at (0,0) {$0$};
    \node (1) at (0,1) {$1$};
    \node (2) at (0,2) {$2$};
    \node (rest) at (0,3) {$\vdots$};

    \draw (0) -- (1);
    \draw (1) -- (2);
    \draw (2) -- (rest);
  \end{tikzpicture}
  \caption{Hasse diagram for the lattice $\langle \N, \le, \max, \min \rangle$.}
  \labfig{N}
  \end{marginfigure}

\begin{marginfigure}
  \centering
  \begin{tikzpicture}
    \node (0) at (0,0) {$0$};
    \node (1) at (0,1) {$1$};
    \node (2) at (0,2) {$2$};
    \node (rest) at (0,3) {$\vdots$};
    \node (inf) at (0,4) {$+\infty$};

    \draw (0) -- (1);
    \draw (1) -- (2);
    \draw (2) -- (rest);
    \draw (rest) -- (inf);
  \end{tikzpicture}
  \caption{Hasse diagram for the complete lattice $\langle \Nplus, \le, \max, \min, 0, +\infty \rangle$.}
  \labfig{Nplus}
  \end{marginfigure}


\begin{example}
  The posets of \reffig{posetA} and \reffig{posetB} are not lattices, as they do not have a least upper bound for every pair of elements, \eg, $\join\{a, b\}$ does not exist in \reffig{posetA} and $\join\{a, c\}$ does not exist in \reffig{posetB}.
%
  \reffig{hasse_diagram} represents a complete lattice with a finite number of elements.
  The poset $\langle \N, \le \rangle$ is a lattice, as every pair of natural numbers has a least upper bound and a greatest lower bound, but it is not a complete lattice, as $\join \N$ does not exist.
  Lastly, $\langle \Nplus, \le, \max, \min, 0, +\infty \rangle$ where $+\infty$ is greater than any natural number is indeed a complete lattice.
  \reffig{N} shows the Hasse diagram for $\langle \Nplus, \le \rangle$ and \reffig{Nplus} the one for $\langle \Nplus, \le \rangle$.
\end{example}

\begin{remark}
  Given any set of elements $X$, the power set $\langle \setof{X}, \subseteq, \setjoin, \setmeet, \emptyset, X \rangle$ is a complete lattice.
\end{remark}


\subsection{Functions}
\labsec{functions}

% A partial function $f$ from a set $A$ to a set $B$, written $f : A \rightharpoonup B$, is a binary relation between $A$ and $B$ that pairs each element $x \in A$ with no more than one element $y \in B$. The set of all partial functions from a set $A$ to a set $B$ is denoted by $A \rightharpoonup B$. We write $f(x) = y$ if there exists an element $y$ such that $(x, y) \in f$, and we say that $f(x)$ is defined, otherwise we say that $f(x)$ is undefined. Given a partial function $f : A \rightharpoonup B$, we define its domain as $\text{dom}(f) \triangle \{x \in A \mid \exists y \in B : f(x) = y\}$. The totally undefined function, denoted by $\emptyset$, has the empty set as domain: $\text{dom}(\emptyset) = \emptyset$. The join of two partial functions $f_1 : A \rightharpoonup B$ and $f_2 : A \rightharpoonup B$ with disjoint domains, denoted by $f_1 \cup f_2 : A \rightharpoonup B$, is defined as follows:
% \[
% (f_1 \cup f_2)(x) \triangle
% \begin{cases}
% f_1(x) & x \in \text{dom}(f_1) \\
% f_2(x) & x \in \text{dom}(f_2) \\
% \text{undefined} & \text{otherwise}
% \end{cases}
% \]
% where $\text{dom}(f_1) \cap \text{dom}(f_2) = \emptyset$.

% A (total) function $f$ from a set $A$ to a set $B$, written $f : A \to B$, is a partial function that pairs each $x \in A$ with exactly one element $y \in B$. Equivalently, a (total) function $f : A \to B$ is a partial function such that $\text{dom}(f) = A$. The set of all functions from a set $A$ to a set $B$ is denoted by $A \to B$.

% We sometimes denote functions using the lambda notation $\lambda x \in A. f(x)$, or more concisely $\lambda x. f(x)$.

% The composition of two functions $f : A \to B$ and $g : B \to C$ is another function $g \circ f : A \to C$ such that $\forall x \in A : (g \circ f)(x) = g(f(x))$.

% The following properties may hold for a function $f : A \to B$:
% \begin{itemize}
%     \item Injectivity: $\forall x, y \in A : f(x) = f(y) \implies x = y$
%     \item Surjectivity: $\forall y \in B : \exists x \in A : f(x) = y$
% \end{itemize}

% A bijective function, also called isomorphism, is both injective and surjective. Two sets $A$ and $B$ are isomorphic if there exists a bijective function $f : A \to B$. The inverse of a bijective function $f : A \to B$ is the bijective function $f^{-1} : B \to A$ defined as $f^{-1} \triangle \{(b, a) \mid (a, b) \in f\}$.

% Let $\langle D_1, \le_1 \rangle$ and $\langle D_2, \le_2 \rangle$ be partially ordered sets. A function $f : D_1 \to D_2$ is said to be monotonic when, for each $x, y \in D_1, x \le_1 y \implies f(x) \le_2 f(y)$. It is continuous (or Scott-continuous) when it preserves existing least upper bounds of chains, that is, for each chain $C \subseteq D_1$, if $\bigvee C$ exists then $f(\bigvee C) = \bigvee \{f(x) \mid x \in C\}$. Dually, it is co-continuous when it preserves existing greatest lower bounds of chains, that is, if $\bigwedge C$ exists then $f(\bigwedge C) = \bigwedge \{f(x) \mid x \in C\}$. A complete $\bigvee$-morphism (resp. complete $\bigwedge$-morphism) preserves existing least upper bounds (resp. greatest lower bounds) of arbitrary non-empty sets.

% Given a complete lattice $\langle D, \le, \bigvee, \bigwedge, \bot, \top \rangle$ (resp. a lattice, a cpo, a poset) and a set $S$, the set $S \to D$ of all functions from $S$ to $D$ inherits the complete lattice (resp. lattice, cpo, poset) structure of $D$: $\langle S \to D, \le, \bigvee, \bigwedge, \bot, \top \rangle$ where the dotted operators are defined by pointwise lifting:
% \[
% \begin{aligned}
% f \le g & \triangle \forall s \in S : f(s) \le g(s) \\
% \bigvee X & \triangle \lambda s. \bigvee \{f(s) \mid f \in X\} \\
% \bigwedge X & \triangle \lambda s. \bigwedge \{f(s) \mid f \in X\} \\
% \bot & \triangle \lambda s. \bot \\
% \top & \triangle \lambda s. \top
% \end{aligned}
% \]

A \emph{function} is a relation $f\in\setof{X \times Y}$ between two sets $X$ and $Y$ such that each element $x \in X$ is in relation with at most one element $y \in Y$, \ie, $\forall x \in X.\spacer \exists! y \in Y.\spacer (x, y) \in f$. We write $f \in X \to Y$ to denote that $f$ is a function from $X$ to $Y$, and $f(x) = y$ if and only if $\langle x, y \rangle \in f$.
We sometimes denote functions using the \emph{lambda notation} $\lambda x \in X.\spacer f(x)$, or more concisely $\lambda x.\spacer f(x)$ when the domain is clear from the context.
The \emph{domain} of a function $f$ is the set of elements $x \in X$ such that $f(x)$ is defined, \ie, $\dom(f) \defeq \setof{x \in X \mid \exists y \in Y.\spacer f(x) = y}$. Dually, the \emph{codomain} of a function $f$ is the set of elements $y \in Y$ such that there exists $x \in X$ such that $f(x) = y$, \ie, $\codom(f) \defeq \setof{y \in Y \mid \exists x \in X.\spacer f(x) = y}$. A function $f$ is \emph{total} when $\dom(f) = X$, otherwise \emph{partial} when $\dom(f) \subseteq X$.
A function $f\in X \to X$ is called an \emph{operator} when the domain and codomain coincide.

The {composition} of two functions $f \in X \to Y$ and $g \in Y \to Z$ is the function $g \circ f \in X \to Z \defeq \lambda x.\spacer g(f(x))$.
The {iterates} of an operator $f \in X \to X$ are defined as $f^0 \defeq \identity$ and $f^{n+1} \defeq f \circ f^n$ for $n \in \N$.
We define the {identity} function $\identity\in X \to X$ as $\identity \defeq \lambda x.\spacer x$.
Let $f \in X \to Y$ be a function, the following properties may hold for $f$:
\begin{description}
  \item[Injectivity] $\forall x, y \in X.\spacer f(x) = f(y) \implies x = y$.
  \item[Surjectivity] $\forall y \in Y.\spacer \exists x \in X.\spacer f(x) = y$.
  \item[Bijectivity] A function that is both injective and surjective is called bijective, or isomorphism.
\end{description}
Two sets $X$ and $Y$ are \emph{isomorphic} if there exists a bijective function $f \in X \to Y$.
%
Next, we introduce some properties of functions that are relevant in the context of partially ordered sets.

\begin{definition}[Monotonicity]\labdef{monotonicity}
  Let $f\in X \to Y$ be a function, $\langle X, \sqsubseteq_X \rangle$ and $\langle Y, \sqsubseteq_Y \rangle$ be two partially ordered sets.
  The function $f$ is \emph{monotonic} whenever, for all $x, x' \in X$, it holds that $x \sqsubseteq_X x' \implies f(x) \sqsubseteq_Y f(x')$.
\end{definition}

Sometimes we refer to a function as \emph{increasing} monotone when it is monotonic and \emph{decreasing} monotone when it is monotonic and the inequality is reversed, \ie, $x \sqsubseteq_X x' \implies f(x') \sqsupseteq_Y f(x)$. Note that, a decreasing monotone function is (increasing) monotone over $\langle X, \sqsubseteq_Y \rangle$ and $\langle Y, \sqsupseteq_Y \rangle$.

\begin{definition}[Continuity]\labdef{continuity}
  Let $f\in X \to Y$ be a function, $\langle X, \sqsubseteq_X, \join_X, \meet_X \rangle$ and $\langle Y, \sqsubseteq_Y, \join_Y, \meet_Y \rangle$ be two partially ordered sets.
  The function $f$ is \emph{continuous} (or \emph{Scot-continuous}) whenever, for all chains $C \subseteq X$, if $\join_X C$ exists then the limit coincide, \ie, $f(\join_X C) = \join_Y \setof{f(x) \mid x \in C}$.
\end{definition}

Dually, a function is \emph{co-continuous} whenever, for all chains $C \subseteq X$, if $\meet_X C$ exists then the limit coincide, \ie, $f(\meet_X C) = \meet_Y \setof{f(x) \mid x \in C}$. A \emph{complete $\join$-morphism} (resp. \emph{complete $\meet$-morphism}) preserves existing least upper bounds (resp. greatest lower bounds) of arbitrary non-empty sets.

% The upper closure of a subset $Y\subseteq X$ in a poset $\langle X, \sqsubseteq\rangle$ is the set of all elements in $X$ that are greater than or equal to some element of $Y$.
% We write $\uparrow Y \defeq \setdef{x \in X}{\exists y \in Y.\spacer y \sqsubseteq x}$ for the upper closure of $Y$. Dually, the lower closure of a subset $Y\subseteq X$ in a poset $\langle X, \sqsubseteq\rangle$ is the set of all elements in $X$ that are smaller than or equal to some element of $Y$, and is denoted by $\downarrow Y \defeq \setdef{x \in X}{\exists y \in Y.\spacer x \sqsubseteq y}$.

An operator is \emph{idempotent} when $f(f(x)) = f(x)$ for all $x \in X$, and \emph{extensive} when $x \sqsubseteq f(x)$ for all $x \in X$.

\marginnote{Dually, the \emph{lower closure operator} is monotone, idempotent, and \emph{reductive}, \ie, $f(x) \sqsubseteq x$ for all $x \in X$.}
\begin{definition}[Upper Closure Operator]\labdef{upper-closure-operator}
  An \emph{upper closure operator} on a partially ordered set $\langle X, \subseteq \rangle$ is an operator $\rho\in X \to X$ which is monotone, idempotent, and extensive.
\end{definition}

A \emph{family} $F \in \Delta \to X$ of elements of $X$ indexed by a set $\Delta$ (called the \emph{domain} or \emph{indexed set} of $F$, which may be infinite) is a function from $\Delta$ to $X$. Such family defines a set $\setdef{F(i)}{i \in \Delta}$ (where $F(i)$ is often denoted as $F_i$ with an index $i\in\Delta$) of elements of $X$ indexed by $\Delta$.
It also defines the sequence $(F_i)_{i\in\Delta}$ of elements of $X$ indexed by $\Delta$.

\begin{marginfigure}
  % simple plot x-y axis for the fibonacci function
  % grid system showing the fixpoints
  \begin{tikzpicture}[scale=0.65]
    \begin{axis}[
      grid=both,
      major grid style = {dashed, lightgray},  % Style for major grid lines
      minor grid style = {dashed, gray!25},    % Style for minor grid lines
      xtick = {0, 1, 2, 3, 4, 5, 6},% x-axis ticks
      ytick = {0, 1, 2, 3, 5, 8},  % y-axis ticks (Fibonacci numbers)
      xmin = 0, xmax = 6.5,
      ymin = 0, ymax = 8.5]
      \addplot[samples at={0,1,5},only marks, seabornBlue] { x };
      \addplot[samples at={2,3,4},only marks, seabornBlue] { x - 1 };
      \addplot[samples at={6},only marks, seabornBlue] { x +2 };
    \end{axis}

  \end{tikzpicture}
  \caption{The fibonacci function.}
  \labfig{fibonacci}
  \end{marginfigure}

\begin{example}
  Let $\textsc{fib}(n)$ be the $n$-th Fibonacci number, defined as:
  \begin{align*}
    \textsc{fib}(n) \defeq \begin{cases}
      n & \text{if } n \le 1 \\
      \textsc{fib}(n-1) + \textsc{fib}(n-2) & \text{otherwise}
    \end{cases}
  \end{align*}
  The sequence $(\textsc{fib}(n))_{n\in\N}$ is a family of elements of $\N$ indexed by $\N$:
  \[ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \ldots \]
  \reffig{fibonacci} depicts the first 6 elements of the Fibonacci sequence over the natural numbers.
\end{example}

Next, we show how to lift an ordered set via \emph{pointwise lifting} to define a new ordered set.

\begin{definition}[Pointwise Lifting]\labdef{pointwise-lifting}
  Given a complete lattice $\langle X, \sqsubseteq, \join, \meet, \bot, \top \rangle$ (respectively a lattice, a cpo, a poset) and a set $Y$, the set $Y \to X$ of all functions from $Y$ to $X$ forms a complete lattice $\langle Y \to X, \liftedsubseteq, \liftedjoin, \liftedmeet, \liftedbottom, \liftedtop \rangle$ (respectively a lattice, a cpo, a poset) where the operators are defined by \emph{pointwise lifting}:
\begin{align*}
  f \liftedsubseteq g & \triangleq \forall y \in Y.\spacer f(y) \sqsubseteq g(y) \\
  \liftedjoin X & \triangleq \lambda y.\spacer \join \setdef{f(y)}{f \in X} \\
  \liftedmeet X & \triangleq \lambda y.\spacer \meet \setdef{f(y)}{f \in X} \\
  \liftedbottom & \triangleq \lambda y.\spacer \bottom \\
  \liftedtop & \triangleq \lambda y.\spacer \top
\end{align*}
\end{definition}


\subsection{Properties}
\labsec{properties}

Properties (\eg, ``to be an even natural number'' or ``to be a number of the sequence of Fibonacci'') by extension are the sets of elements that satisfy the property (\eg, $2\N \defeq \setdef{x \in \N}{\exists k \in \N.\spacer x = 2k}$ or $B \defeq \setdef{\textsc{fib}(n)}{n\in\N}$). Therefore, if $Q$ is a property, then $x \in Q$ means that $x$ satisfies the property $Q$ (\eg, $2 \in 2\N$ or $12 \notin B$).

By considering properties as sets, we have that logical implication is subset inclusion. For instance, the property ``to be an even natural number'' implies ``to be a multiple of $4$,'' that is $2\N \subseteq 4\N$, where $4\N \defeq \setdef{x \in \N}{\exists k \in \N.\spacer x = 4k}$.
Whenever $P$ implies $Q$ ($P \subseteq Q$), we say that $P$ is \emph{stronger} than $Q$ and $Q$ is \emph{weaker} than $P$.
Stronger properties are satisfied by less elements, whether weaker properties are satisfied by more.
The strongest property is $\emptyset$ satisfied by no element, and the weakest property is the set containing all elements, \eg, $\N$ is the weakest property of natural numbers.


\subsection{Fixpoints}
\labsec{fixpoints}

Fixpoints are elements of a poset that are invariant under a function.
As of fundamental importance to formally reason about program behaviors, we introduce the concept of fixpoints in partially ordered sets.
In the following, let $\langle X, \subseteq \rangle$ be a partially ordered set and $f : X \to X$ be an operator on $X$.

\begin{description}
  \item[Fixpoint] An element $x \in X$ is a \emph{fixpoint} of $f$ whenever $f(x) = x$.
  \item[Prefixpoint] An element $x \in X$ is a \emph{prefixpoint} of $f$ whenever $x \sqsubseteq f(x)$.
  \item[Postfixpoint] An element $x \in X$ is a \emph{postfixpoint} of $f$ whenever $f(x) \sqsubseteq x$.
  \item[Set of Fixpoints] The set of fixpoints of $f$ is denoted by $\fixpoints(f) \defeq \setdef{x \in X}{f(x) = x}$.
  \item[Least Fixpoint] The \emph{least fixpoint} of $f$ is a fixpoint of $f$ such that, for every fixpoint $x \in X$ of $f$, $\lfp f \sqsubseteq x$. We write $\lfp_{x_0} f$ for the least fixpoint of $f$ which is greater than or equal to $x_0 \in X$.
  \item[Greatest Fixpoint] The \emph{greatest fixpoint} of $f$ is a fixpoint of $f$ such that, for every fixpoint $x \in X$ of $f$, $x \sqsubseteq \gfp f$. We write $\gfp_{x_0} f$ for the greatest fixpoint of $f$ which is smaller than or equal to $x_0 \in X$.
\end{description}

When the order $\sqsubseteq$ is not clear from the context, we explicitly write $\lfp^{\sqsubseteq} f$ and $\gfp^{\sqsubseteq} f$. Note that, in general, a function may have no fixpoint at all or multiple ones.

\begin{marginfigure}
% simple plot x-y axis for the fibonacci function
% grid system showing the fixpoints
\begin{tikzpicture}[scale=0.65]
  \begin{axis}[
    grid=both,
    major grid style = {dashed, lightgray},  % Style for major grid lines
    minor grid style = {dashed, gray!25},    % Style for minor grid lines
    xtick = {0, 1, 2, 3, 4, 5, 6},% x-axis ticks
    ytick = {0, 1, 2, 3, 5, 8},  % y-axis ticks (Fibonacci numbers)
    xmin = 0, xmax = 6.5,
    ymin = 0, ymax = 8.5]
    \addplot[samples at={0,1,5},only marks, seabornBlue] { x };
    \addplot[samples at={2,3,4},only marks, seabornRed] { x - 1 };
    \addplot[samples at={6},only marks, seabornGreen] { x +2 };
    \addplot[domain=0:6.5, lightgray, thick, dotted] {x};
  \end{axis}

  \draw[seabornBlue, rounded corners, thick, dashed, rotate=32.4]
      (-0.3,-0.3) rectangle (6.5,0.4);
  \node[seabornBlue, fill=white, rounded corners=10pt] at (1.9, 2.5) {Fixpoints};
  \draw[seabornRed, rounded corners, thick, dashed, rotate=32.4]
      (1.8,-0.9) rectangle (5, -0.35);
  \node[seabornRed, fill=white] at (3.9, 0.5) {Postfixpoints};
  \draw[seabornGreen, rounded corners, thick, dashed]
      (5,5.9) -- (5,4) -- (7.2,5.2);
  \node[seabornGreen, fill=white,rounded corners=10pt] at (3.69, 4.7) {Prefixpoints};
  % \node[seabornYellow, fill=white] at (1, 0) {Lub};
\end{tikzpicture}
\caption{Prefixpoint, fixpoints, and postfixpoints of the fibonacci function.}
\labfig{fixpoints}
\end{marginfigure}

\begin{marginfigure}
  % simple plot x-y axis for the fibonacci function
  % grid system showing the fixpoints
  \begin{tikzpicture}[scale=0.65]
    \begin{axis}[
      grid=both,
      major grid style = {dashed, lightgray},  % Style for major grid lines
      minor grid style = {dashed, gray!25},    % Style for minor grid lines
      xtick = {0, 1, 2, 3, 4, 5, 6},% x-axis ticks
      ytick = {0, 1, 2, 3, 4, 5, 6},  % y-axis ticks (Fibonacci numbers)
      xmin = 0, xmax = 6.5,
      ymin = 0, ymax = 6.5]
      \addplot[samples at={0,...,6},only marks, seabornGreen] { x + 1 };
      \addplot[domain=0:6.5, lightgray, thick, dotted] {x};
    \end{axis}
    \draw[seabornGreen, rounded corners=15pt, thick, dashed]
        (-0.4,5.7) -- (-0.4,0.1) -- (6.2,5.7);
    \node[seabornGreen] at (2.7, 4.7) {Prefixpoints};
    % \node[seabornYellow, fill=white] at (1, 0) {Lub};
  \end{tikzpicture}
  \caption{Prefixpoints of the construct function, \ie, $\textsc{cons}(x) \defeq x + 1$.}
  \labfig{prefixpoints}
  \end{marginfigure}

\begin{example}
  Let us consider again the fibonacci function $\textsc{fib} \in \N \to \N$. The fixpoints are shown in \reffig{fixpoints}, the set of fixpoints is $\fixpoints(\textsc{fib}) = \{0, 1, 5\}$, the elements $2$, $3$, and $4$ are prefixpoints are their values are smaller than the values of their images, and the elements greater than or equal to $6$ are postfixpoints.
  The least fixpoint of $\textsc{fib}$ is $\lfp \textsc{fib} = 0$, as $0$ is the smallest element of $\fixpoints(\textsc{fib})$.
  On the other hand, the greatest fixpoint of $\textsc{fib}$ is $\gfp \textsc{fib} = 5$.

  Instead, if we consider another operator, for example the $\textsc{cons}(x) \defeq x + 1$ operator, then there is no fixpoint, as $\textsc{cons}(x) \neq x$ for all $x \in \N$. instead, all the domain is composed of prefixpoints, as $x \le \textsc{cons}(x) = x + 1$ for all $x \in \N$. \reffig{prefixpoints} shows graphically this example.
\end{example}

Next, we recall a fundamental theorem of Alfred Tarski \sidecite{Tarski1955} that characterizes fixpoints of monotonic functions over complete lattices.

\begin{theorem}[Tarski's Fixpoint Theorem]\labthm{tarski}
  Let $\langle X, \sqsubseteq, \join, \meet, \bot, \top \rangle$ be a complete lattice and $f \in X \to X$ be a monotonic function. The set of fixpoints $\fixpoints(f)$ is a non-empty complete lattice.
\end{theorem}
\begin{proof}
  See \textcite{Tarski1955}.
\end{proof}
\refthm{tarski} guarantees that $f$ has a least fixpoint $\lfp f = \meet \setdef{x \in X}{f(x) \sqsubseteq x}$ and a greatest fixpoint $\gfp f = \join \setdef{x \in X}{x \sqsubseteq f(x)}$ as $fixpoints(f)$ is a non-empty complete lattice.

However, such characterization is not constructive, an alternative that expresses the least fixpoint of a function as the limit of iterates is Kleene's Fixpoint Theorem \sidecite{Kleene1952}.


\marginnote{
  In case of monotonic but not continuous functions, a theorem by Patrick and Radhia Cousot \cite{Cousot1979b} expresses fixpoints as the limit of possibly transfinite iterations.
}\phantomcite{Cousot1979b}
\begin{theorem}[Kleene's Fixpoint Theorem]\labthm{kleene}
  Let $\langle X, \sqsubseteq \rangle$ be a complete partial order and $f \in X \to X$ be a Scott-continuous function. The least fixpoint $\lfp f$ exists and is the least upper bound of the iterates $f^n$ starting from $\bot$:
  \[ \lfp f = \join \setdef{f^n(\bot)}{n \in \N} \]
\end{theorem}

In the following, the partial order between the fixpoint iterates is called the \emph{computational order}, in order to distinguish it from the \emph{approximation order} defined in the next section.


\section{Notations of Abstract Interpretation}
\labsec{notations-of-abstract-interpretation}

\emph{Abstract Interpretation} \sidecite{Cousot1977,Cousot1978} is a general theory for approximating the semantics of programs as a unifying framework for static program analysis, co-invented in the late 1970s by Patrick and Radhia Cousot.
Various books are available for an in-depth study of the topic \sidecite{Cousot2021,Rival2020}.
In the following, we introduce the notations, main definitions, and results that will be used throughout the rest of this thesis.

\subsection{Transition System}
\labsec{transition-system}

The \emph{semantics} of a program is a mathematical characterization of its behavior for all possible input data.
In order to be independent of a particular choice of programming language, we consider programs as transition systems, where the behavior of a program is described by a set of states and a set of transitions between states.
In the next section, we instantiate the transition system model for a small imperative language.

\begin{definition}[Transition System]\labdef{transition-system}
  A \emph{transition system} is a pair $\transitionsystem$ where $\state$ is a (potentially infinite) set of states and $\transitionrelation \in \transitionrelationtype$ is the transition relation.
\end{definition}

This model allows expressing programs with (possibly unbounded) non-determinism.
In the following, we write $\defstate \rightarrow \defstate'$ to denote that there is a transition from state $\defstate$ to state $\defstate'$, \ie, $\tuple{\defstate}{\defstate'} \in \transitionrelation$.
The set $\finalstates \defeq \setdef{\defstate \in \state}{\forall \defstate' \in \state.\spacer \tuple{\defstate}{\defstate'} \notin \transitionrelation}$ represents the \emph{final states} (or blocking states) of the transition system.


\subsection{Maximal Trace Semantics}
\labsec{maximal-trace-semantics}

The \emph{semantics} of a program is a mathematical characterization of its behavior for all possible input data. We formally define this notion for a transition system below.

\paragraph{Sequences.}
Given a set of elements $X$, the set of all sequences of exactly $n$ elements of $X$ is denoted by $X^n\defeq\setdef{\defstate_0 \dots \defstate_{n-1}}{\forall i < n.\spacer s_i \in X}$.
The symbol $\emptysequence$ denotes the empty sequence, hence $X^0 = \{\emptysequence\}$.

We define:
\begin{description}
  \item[Finite Sequences $\retrievefiniteoremptytraces{X}$:] The set of all finite sequences of elements of $X$ is defined as $\retrievefiniteoremptytraces{X} \defeq \bigsetjoin_{n \in \N} X^n$.
  \item[Non-Empty Finite Sequences $\retrievefinitetraces{X}$:] The set of all non-empty finite sequences of elements of $X$ is $\retrievefinitetraces{X} \defeq \retrievefiniteoremptytraces{X} \setminus X^0 = \bigsetjoin_{n \in \Nposstrict} X^n$.
  \item[Infinite Sequences $\retrieveinfinitetraces{X}$:] The set of all infinite sequences of elements of $X$ is defined as  $\retrieveinfinitetraces{X} \defeq \setdef{\defstate_0 \dots}{\forall i \in \N.\spacer \defstate_i \in X}$.
  \item[Non-Empty Finite or Infinite Sequences $\retrievefiniteinfinitetraces{X}$:] The set of all non-empty finite or infinite sequences of elements of $X$ is $\retrievefiniteinfinitetraces{X} \defeq \retrievefinitetraces{X} \cup \retrieveinfinitetraces{X}$.
  \item[Finite or Infinite Sequences $\retrievefiniteoremptyinfinitetraces{X}$:] The set of all finite or infinite sequences of elements of $X$ is $\retrievefiniteoremptyinfinitetraces{X} \defeq \retrievefiniteoremptytraces{X} \cup \retrieveinfinitetraces{X}$.
\end{description}

Let $\defstate\in X$ be an element, we often refer to just $\defstate$ as the sequence of length $1$ containing only $\defstate$, \ie, $\{\defstate\} \in X^1$.
To \emph{concatenate} two sequences $\defseq, \defseq' \in \retrievefiniteinfinitetraces{X}$, we write $\concat{\defseq}{\defseq'}$ for the sequence obtained by appending $\defseq'$ to $\defseq$. It holds that $\concat{\defseq}{\emptysequence} = \concat{\emptysequence}{\defseq} = \defseq$ and $\concat{\defseq}{\defseq'} = \defseq$ whenever $\defseq \in \retrieveinfinitetraces{X}$. To \emph{merge} two set of sequences $Y \subseteq \retrievefinitetraces{X}$ and $Y' \subseteq \retrievefiniteinfinitetraces{X}$, we write $\mergesequences{Y}{Y'} \defeq \setdef{\concat{\defseq}{\concat{\defstate}{\defseq'}}}{\defstate \in X \land \concat{\defseq}{\defstate} \in Y \land \concat{\defstate}{\defseq'} \in Y'}$ when a finite sequence in $Y$ ends with the initial state of a sequence in $Y'$.

\paragraph{Traces.}

Given a transition system $\transitionsystem$, a \emph{trace} is a non-empty sequence of program states $\state$ that respects the transition relation $\transitionrelation$. That is, for every pair of consecutive states $\defstate, \defstate' \in \state$, it holds that $\tuple{\defstate}{\defstate'} \in \transitionrelation$.

\paragraph{Maximal Trace Semantics}

The \emph{maximal trace semantics} $\tracesemanticsnoparam\in\tracetype$ of a transition system $\transitionsystem$ is the set of all traces that are terminating in the final states $\finalstates$ (\ie, of finite length) and all non-terminating traces (\ie, of infinite length) generated by $\transitionsystem$.


\begin{definition}[Maximal Trace Semantics]\labdef{maximal-trace-semantics}
  Let $\transitionsystem$ be a transition system. The \emph{maximal trace semantics} $\tracesemanticsnoparam\in\tracetype$ generated by $\transitionsystem$ is defined as:
  \begin{align*}
    \tracesemanticsnoparam \DefeQ &\bigsetjoin_{n\in\Nposstrict} \setdef{s_0\dots s_{n-1}\in\finitetontraces}{\foralldef{i < n-1}{\tuple{s_i}{s_{i+1}}\in\transitionrelation \land s_{n-1}\in \finalstates}} \\
    &\setjoin \setdef{s_0\dots{}\in\infinitesequences}{\foralldef{i\in\N}{\tuple{s_i}{s_{i+1}}\in\transitionrelation}}
  \end{align*}
\end{definition}

\begin{marginfigure}
  \centering
\begin{tikzpicture}
    % Nodes
    \node[state] (q0)   {$x$};
    \node[state, accepting, right=of q0] (q1) {$y$};
    \node[above=0.2cm of q1] {$\finalstates$};

    % Edges
    \path[->] (q0) edge[loop above] node {$(i)$} ()
              (q0) edge node[above] {$(ii)$} (q1);
\end{tikzpicture}
\resizebox{\textwidth}{!}{
  \begin{minipage}{\textwidth}
\begin{align*}
  \tracesemanticsnoparam =
  \left\{\quad\begin{aligned}
  y,& \\
  x \xrightarrow{(ii)} y,& \\
  x \xrightarrow{(i)} x \xrightarrow{(ii)} y,& \\
  x \xrightarrow{(i)} \dots \xrightarrow{(ii)} y,& \\
  x \xrightarrow{(i)} \dots \xrightarrow{(i)} x& \xrightarrow{(i)} \dots
\end{aligned}\quad\right\}
\end{align*}
\end{minipage}
}
\caption{Maximal trace semantics of the transition system presented in \refexample{transition-system}.}
\labfig{transition-system}
\end{marginfigure}

\begin{example}\labexample{transition-system}
  Let us consider the transition system $\transitionsystem$ with states $\state = \{x, y\}$, transitions $\transitionrelation = \{x \xrightarrow{(i)}, x \xrightarrow{(ii)} y\}$ with final states $\finalstates = \{y\}$. The maximal trace semantics $\tracesemanticsnoparam$ is the set of all traces that are terminating in the final state $y$ and all non-terminating traces from the transition $\tuple{x}{x}$.
  \reffig{transition-system} depicts graphically the transition system and the traces generated by the maximal trace semantics.
  Note that, the maximal trace semantics does not represent partial computations that are not terminating in the final states, such as the trace $x \xrightarrow{(i)} x \xrightarrow{(i)} x$.
\end{example}

\begin{remark}
  Observe that not all program semantics can be generated by a transition system.
  For instance, in case the program semantics is the set of traces starting with an arbitrary finite number of $x$ where $y$ is eventually reached, the transition relation $\transitionrelation = \{\tuple{x}{x}, \tuple{x}{y}\}$ generates also infinite sequences of $x$ that are not part of the semantics.
\end{remark}

% The following result provides a (least) fixpoint characterization of the maximal trace semantics over the complete lattice $\tracecompletelattice$.
% The \emph{computation order} of the maximal trace semantics is defined as $\defsetoftraces \tracesubseteq \defsetoftraces' \defiff \retrievefinitetraces{\defsetoftraces} \subseteq \retrievefinitetraces{\defsetoftraces'} \land \retrieveinfinitetraces{\defsetoftraces} \supseteq \retrieveinfinitetraces{\defsetoftraces'}$.

% \begin{theorem}[Maximal Trace Semantics]\labthm{maximal-trace-semantics}
%   The \emph{maximal trace semantics} $\tracesemanticsnoparam\in\tracetype$ generated by the transition system $\transitionsystem$ can be expressed as a least fixpoint in the complete lattice $\tracecompletelattice$ as follows:
%   \begin{align*}
%     \tracesemanticsnoparam &\spacearound{=} \lfp^{\tracesubseteq} \tracetransformer \\
%     \tracetransformer(\defsetoftraces) &\spacearound{=} \finalstates \setjoin (\mergesequences{\transitionrelation}{\defsetoftraces})
%   \end{align*}
% \end{theorem}
% \begin{proof}
%   See \sidetextcite{Cousot2002}.
% \end{proof}

% \begin{marginfigure}
%   \begin{tikzpicture}
%     % Draw the opening curly bracket {
%     \draw[decorate,decoration={brace,amplitude=5pt,mirror}] (0, 0.5) -- (0, -0.5);

%     % Draw the curly line with a label X on top
%     \draw[decorate,decoration={coil,amplitude=1mm,segment length=2mm}] (0.5,0) -- (2.5,0) node[midway, above=2mm] {$\infinitesequences$};

%     % Draw the closing curly bracket }
%     \draw[decorate,decoration={brace,amplitude=5pt}] (3, -0.5) -- (3, 0.5);
% \end{tikzpicture}
% \caption{Fixpoint iterates of the maximal trace semantics.}
% \labfig{iterates}
% \end{marginfigure}

% Intuitively, the iterates of the transformer $\tracetransformer$ starting from the set containing all infinite traces $\retrieveinfinitetraces{\state}$ are generated backwards by prepending transitions to them. In \reffig{iterates}, we illustrate the first few iterates of the transformer $\tracetransformer$.
% Specifically, the finite traces are composed by extending finite traces from the final states $\finalstates$, one transition at a time, and the infinite traces are obtained by selecting infinite sequences with increasingly longer prefixes of transitions.
% The $i$-th iterate of the transformer $\tracetransformer$ contains all finite traces of length at most $i$ that are terminating in the final states $\finalstates$, and all infinite sequences whose prefixes of length $i$ are generated by the transition relation $\transitionrelation$.
% At the limit, we obtain the maximal trace semantics.

The maximal trace semantics is the most precise semantics and fully describes the behavior of programs. However, reasoning about a particular property of a program is often facilitated by the design of a semantics that abstracts away from irrelevant details about program computations.
In the following, to facilitate reading, we call the maximal trace semantics simply the \emph{trace semantics}.

\begin{remark}[Non-determinism]
  We say that a transition system $\transitionsystem$ is \emph{non-deterministic} whenever the maximal trace semantics generates (at least) two different traces that share the same prefix. Formally:
  \begin{gather*}
    \transitionsystem \text{ is non-deterministic} \\ \IfF \\ \exists \deftrace \in \finitesequences, \deftrace', \deftrace'' \in \finiteinfinitesequences.\spacer \deftrace' \neq \deftrace'' \land \concat{\deftrace}{\deftrace'} \in \tracesemanticsnoparam \land \concat{\deftrace}{\deftrace''} \in \tracesemanticsnoparam
  \end{gather*}
  In fact, the transition system of \refexample{transition-system} is non-deterministic, as these two traces belongs to the maximal trace semantics:
  \begin{align*}
    x \xrightarrow{(i)} x &\xrightarrow{(ii)} y\\
    x \xrightarrow{(i)} x &\xrightarrow{(i)} x \xrightarrow{(ii)} y
  \end{align*}
  Both traces share the same prefix, \ie, $x \xrightarrow{(i)} x$.
\end{remark}

\subsection{Collecting Semantics}
\labsec{collecting-semantics}

\marginnote{Program proerties are also reffered to as \emph{hyperproperties} \cite{Clarkson2010}. In this thesis, we prefer the term \emph{program properties} to emphasize that we consider properties of the semantics of programs.}
\phantomcite{Clarkson2010}
As seen in \refsec{properties}, a \emph{property} is specified by its extension, that is, the set of elements that manifest such property.
In this thesis, we consider \emph{program properties} with respect to their trace semantics.
By program property we mean properties of the semantics of programs.
In our settings, since the program semantics is the trace semantics in $\tracetype$, then a program property is a set of sets of traces in $\collectingtype$.
The strongest property of the trace semantics is the set containing the trace semantics and nothing else, this property is called the \emph{collecting semantics}.

\begin{definition}[Collecting Semantics]\labdef{collecting-semantics}
  Let $\tracesemanticsnoparam\in\tracetype$ be the trace semantics of a transition system $\transitionsystem$. The \emph{collecting semantics} $\collectingsemanticsnoparam\in\collectingtype$ is defined as:
  \begin{align*}
    \collectingsemanticsnoparam &\DefeQ \{\spacearound{\tracesemanticsnoparam}\}
  \end{align*}
\end{definition}

The collecting semantics $\collectingsemanticsnoparam$ is satisfied only and exactly by the trace semantics $\tracesemanticsnoparam$.
We write $\tracesemantics$ to denote the trace semantics of a particular program $\defprogram$, that is, the maximal trace semantics generated by the transition system induced by the program $\defprogram$, see later in \refsec{a-small-imperative-language}.
The same applies notation applies to all the semantics we study in this thesis. Hence, the collecting semantics of a program $\defprogram$ is denoted by $\collectingsemantics$.

\paragraph{Property Validation.}

A program $\defprogram$ with semantics $\tracesemantics$ satisfies a property $\defproperty \in \collectingtype$ if and only if the property $\defproperty$ is implied by the collecting semantics $\collectingsemantics\in\collectingtype$.


\begin{definition}[Validation of Program Properties]\labdef{validation}
  Let $\defprogram$ be a program and $\defproperty$ be a property of programs. We say that $\defprogram$ \emph{satisfies} $\defproperty$ whenever:
  \begin{align*}
    \defprogram \satisfies \defproperty \IfF \collectingsemantics \subseteq \defproperty
  \end{align*}
\end{definition}

Traditional properties are often trace properties, and thus can be expressed as sets of traces in $\tracetype$. In this case, it is often used a weaker form of property validation. A program $\defprogram$ satisfies a trace property $\defproperty\in\tracetype$ whenever the trace semantics $\tracesemantics$ implies the property $\defproperty$, not the collecting semantics. Note that, not all program properties can be expressed as trace properties. As an example, the unused property \sidecite{Urban2018} (\cf{} \refch{input-data-usage}) is not a trace property, because whether a program utilizes a variable or not depends on the whole set of traces generated by the program.


\paragraph{Hierarchy of Semantics}

To reason about a particular program property, it is not necessary to consider all the details of the trace semantics.
In fact, reasoning is facilitated by the design of an abstract semantics that forgets irrelevant details about program computations.
Therefore, there is no general purpose program semantics that is suitable for reasoning about all program properties.
Instead, there exist a wide range of program semantics dedicated to a specific class of program properties, each of them abstracting away from the computational details differently.

Abstract interpretation provides a systematic and uniform way to relate semantics described as fixpoints of monotonic functions over ordered structures.
These semantics are organized in a hierarchy, where the collecting semantics is the most precise semantics and all other semantics interrelate at different levels \sidecite{Cousot2002,Cousot2024b}.



\subsection{Galois Connection}
\labsec{galois-connection}

Galois connections\sidecite{Schmidt1953} are a fundamental concept in abstract interpretation that relate two partially ordered sets.
They formalize the correspondence between concrete and abstract properties, and provide a systematic way to derive abstract semantics from concrete semantics.

\begin{definition}[Galois Connection]\labdef{galois-connection}
  Let $\tuple{X}{\sqsubseteq_X}$ and $\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ be two partially ordered sets.
  The pair $\tuple\abstraction\concretization$ of functions $\abstraction\in X \to {X^\natural}$ and $\concretization\in {X^\natural} \to X$ is a \emph{Galois connection} if and only if, for all $x\in X$ and ${x^\natural}\in {X^\natural}$, it holds that:
  \begin{align*}
    x \sqsubseteq_X \concretization({x^\natural}) &\IfF \abstraction(x) \sqsubseteq_{X^\natural} {x^\natural}
  \end{align*}
  which we write as $\tuple{X}{\sqsubseteq_X}\galois{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$.
\end{definition}
\marginnote{The definition of Galois connection can also be defined for preorders, most of the results presented hold for preorders as well.}

The poset $\tuple{X}{\sqsubseteq_X}$ is called the \emph{concrete domain}, and $\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ is called the \emph{abstract domain}. The function $\abstraction$ is called the \emph{abstraction} and $\concretization$ is called the \emph{concretization} function, or together called right-left adjoints.
The intuition behind Galois connections is that properties in a concrete domain $X$ are approximated by abstract properties in ${X^\natural}$.
The concretization function $\concretization$ provides the concrete meaning $\concretization({x^\natural})$ of an abstract property ${x^\natural}\in {X^\natural}$, that is, $\concretization({x^\natural})$ is the least precise element of $X$ that is overapproximated by the abstract property ${x^\natural}$. As a consequence, any concrete property $x\in X$ below $\concretization({x^\natural})$, \ie, $x \sqsubseteq_X \concretization({x^\natural})$, is approximated by ${x^\natural}$.
Whenever $x \sqsubseteq_X \concretization({x^\natural})$, we say that the abstract property ${x^\natural}$ is a \emph{sound} overapproximation of the concrete property $x$. That is, $x$ is a stronger property than $\concretization({x^\natural})$, the stronger the abstract property, the more precise is the abstraction.

The implication $\abstraction(x) \sqsubseteq_{X^\natural} {x^\natural} \implies x \sqsubseteq_X \concretization({x^\natural})$ holds when ${x^\natural} = \abstraction(x)$ so that $x \sqsubseteq_X \concretization(\abstraction(x))$, meaning that $\abstraction(x)$ is a sound overapproximation of $x$.
The other implication $x \sqsubseteq_X \concretization({x^\natural}) \implies \abstraction(x) \sqsubseteq_{X^\natural} {x^\natural}$ means that for any sound overapproximation ${x^\natural}$ of $x$, $\abstraction(x)$ is more precise than ${x^\natural}$. It follows that $\abstraction(x)$ is the most precise sound overapproximation of $x$. We say that the abstraction of a concrete property is \emph{exact} whenever $\concretization(\abstraction(x)) = {x^\natural}$. In such case, the abstraction loses no information about the concrete property.

We write $\tuple{X}{\sqsubseteq_X}\galoiS{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ when $\abstraction$ is surjective (called a \emph{Galois insertion}), $\tuple{X}{\sqsubseteq_X}\Galois{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ when $\concretization$ is surjective (called a \emph{Galois retraction}), and $\tuple{X}{\sqsubseteq_X}\GaloiS{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ for a bijection (called a \emph{Galois correspondence}).

In Galois connections, the abstraction $\abstraction$ and concretization $\concretization$ are monotonic functions, that is, for all $x, x' \in X$ and ${x^\natural}_1, {x^\natural}_2 \in {X^\natural}$, it holds that $x \sqsubseteq_X x' \implies \abstraction(x) \sqsubseteq_{X^\natural} \abstraction(x')$ and ${x^\natural}_1 \sqsubseteq_{X^\natural} {x^\natural}_2 \implies \concretization({x^\natural}_1) \sqsubseteq_X \concretization({x^\natural}_2)$. The composition $\concretization \circ \abstraction \in X \to X$ is extensive, \ie, $x \sqsubseteq_X \concretization(\abstraction(x))$ for all $x \in X$, meaning that the loss of information in the abstraction is sound. The composition $\abstraction \circ \concretization\in {X^\natural} \to {X^\natural}$ is reductive, \ie, ${x^\natural} \sqsubseteq_{X^\natural} \abstraction(\concretization({x^\natural}))$ for all ${x^\natural} \in {X^\natural}$, meaning that the concretization introduces no loss of information. The abstraction $\abstraction$ preservers existing lubs, and the concretization $\concretization$ preservers existing glbs.

\begin{remark}
  In a Galois Connection, one adjoint uniquely determines the other:
  \begin{align*}
    \abstraction(x) &\DefeQ \bigjoin \setdef{{x^\natural} \in {X^\natural}}{x \sqsubseteq_X \concretization({x^\natural})} \\
    \concretization({x^\natural}) &\DefeQ \bigmeet \setdef{x \in X}{\abstraction(x) \sqsubseteq_{X^\natural} {x^\natural}}
  \end{align*}
\end{remark}


It follows that if $\tuple{X}{\sqsubseteq_X}\galois{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ and $\tuple{X}{\sqsubseteq_X}\galois{\abstraction}{\concretization'}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ are two Galois connections, then $\concretization = \concretization'$. If $\tuple{X}{\sqsubseteq_X}\galois{\abstraction}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ and $\tuple{X}{\sqsubseteq_X}\galois{\abstraction'}{\concretization}\tuple{{X^\natural}}{\sqsubseteq_{X^\natural}}$ are two Galois connections, then $\abstraction = \abstraction'$.\sidenote{It is important to note that the two Galois connections must have the same concrete and abstract partial orders $\sqsubseteq_X$ and $\sqsubseteq_{X^\natural}$, otherwise the abstractions or concretizations may no longer be equal.}

Galois connections are also important because they compose, that is, given two Galois connections $\tuple{X}{\sqsubseteq_X}\galois{\abstraction}{\concretization}\tuple{Y}{\sqsubseteq_Y}$ and $\tuple{Y}{\sqsubseteq_Y}\galois{\abstraction'}{\concretization'}\tuple{Z}{\sqsubseteq_Z}$, then $\tuple{X}{\sqsubseteq_X}\galois{\abstraction' \circ \abstraction}{\concretization \circ \concretization'}\tuple{Z}{\sqsubseteq_Z}$ is a Galois connection.

Based on Galois connections, abstract interpretation provides a \emph{constructive} way to derive program semantics by successive abstractions of the trace semantics.

\begin{example}[Forward Reachability State Semantics]\labexample{forward-reachability-state-semantics}
  The \emph{forward reachability state semantics} $\forwardreachabilitytracesemanticsnoparam\in\forwardreachabilitytracetype$ collects the states that are reachable from a given set of initial states $\initialstates\in\setof\state$ by abstraction of the maximal trace semantics $\tracesemanticsnoparam\in\tracetype$. The two form a Galois connection:
  \begin{align*}
    \tuple{\tracetype}{\tracesubseteq}\galois{\forwardreachabilitytraceabstraction}{\forwardreachabilitytraceconcretization}\tuple{\forwardreachabilitytracetype}{\forwardreachabilitytracesubseteq}
  \end{align*}
  where the abstraction $\forwardreachabilitytraceabstraction$ collects all the states that are reachable from the initial states:
  \begin{align*}
    \forwardreachabilitytraceabstraction(\defsetoftraces) &\DefeQ \setdef{\defstate\in\state}{ \defstate'\in\initialstates \land \deftrace\in\finitesequences \land \concat{\concat{\defstate'}{\deftrace}}{\defstate} \in \defsetoftraces}
  \end{align*}
Thus, we obtain the following definition for the forward reachability state semantics:
\[ \forwardreachabilitytracesemanticsnoparam \DefeQ \forwardreachabilitytraceabstraction(\tracesemanticsnoparam) \]
Note that, the reachability semantics presented in this example is strictly less expressive than the maximal trace semantics. For instance, the reachability semantics does not capture non-terminating traces.
\end{example}

\begin{example}[Backward Co-Reachability State Semantics]\labexample{backward-co-reachability-state-semantics}
  Dually, the \emph{backward co-reachability state semantics} $\backwardreachabilitytracesemanticsnoparam\in\backwardreachabilitytracetype$ collects the states that can reach a given set of final states $\finalstates\in\setof\state$ by abstraction of the maximal trace semantics $\tracesemanticsnoparam\in\tracetype$. The two form a Galois connection:
  \begin{align*}
    \tuple{\tracetype}{\tracesubseteq}\galois{\backwardreachabilitytraceabstraction}{\backwardreachabilitytraceconcretization}\tuple{\backwardreachabilitytracetype}{\backwardreachabilitytracesubseteq}
  \end{align*}
  where the abstraction $\backwardreachabilitytraceabstraction$ collects all the states that can reach the final states:
  \begin{align*}
    \backwardreachabilitytraceabstraction(\defsetoftraces) &\DefeQ \setdef{\defstate\in\state}{ \defstate'\in\finalstates \land \deftrace\in\finitesequences \land \concat{\defstate}{\deftrace}{{\defstate'}} \in \defsetoftraces}
  \end{align*}
Thus, we obtain the following definition for the backward co-reachability state semantics:
\[ \backwardreachabilitytracesemanticsnoparam \DefeQ \backwardreachabilitytraceabstraction(\tracesemanticsnoparam) \]

\end{example}

\begin{remark}[Absence of Galois Connection]\labremark{without-galois}
  The use of Galois connections is not necessary to define program semantics. Instead, it represents an ideal situation where there exists the best way to approximate concrete properties. \sidetextcite{Cousot1992a} illustrates how to relax the Galois connection requirement in order only to work with concretization functions (or dually, with abstraction functions). In practice, concretization-based abstractions are much more common.
\end{remark}


\section{A Small Imperative Language}
\labsec{a-small-imperative-language}

The formal treatment introduced in the previous section is language independent.
Here, we consider a simple imperative programming language to instantiate the transition system model and define the semantics of programs.

\subsection{Syntax}
\labsec{syntax}

Our programming language features the classic iterative constructs such as while loops and assignments, and the basic control flow constructs such as conditionals and compositions.
To keep the language simple, we do not consider function calls, recursion, or pointers.
The set $\variables$ is the finite set of (statically allocated) program variables, the data type is $\values \in \{\N, \Z, \R\}$ for arithmetic and $\B$\marginnote{the set of boolean values is $\B \defeq \{\true,\false\}$ where $\true$ is true and $\false$ is false.} for boolean expressions.
The set $\inputvariables \subseteq \variables$ contains the input variables.
\reffig{syntax} shows the syntax of our small imperative language, where $\defvariable\in\variables$ is a variable, $defvalue\in\values$ is a constant value, $\defaexp$ is an arithmetic expression, $\defbexp$ is a boolean expression, and $\defstmt$ is a program statement.

\begin{marginfigure}
  \begin{align*}
    \defaexp \grammardef \defvalue \\
      \linesep \defvariable \\
      \linesep \defaexp + \defaexp \\
      \linesep \defaexp - \defaexp \\
      \linesep \randval(l, u) \tag{$l\in\Zinf \land l < u$} \\
    \defbexp \grammardef \defaexp \le \defvalue \\
      \linesep \defaexp = \defvalue \\
      \linesep \defbexp \land \defbexp \\
      \linesep \lnot \defbexp \\
    \defstmt \grammardef \lskipstmt\\
      \linesep \lassignstmt\\
      \linesep \lifstmt \\
      \linesep \lwhilestmt \\
      \linesep \lcompstmt \\
    \defprogram \grammardef \lprogstmt \tag{$\bigloc \in \locs$}
  \end{align*}
\caption{Syntax of the small imperative language.}
\labfig{syntax}
\end{marginfigure}

The entry point of a program $\defprogram$ is a statement $\defstmt$, denoted by $\progstmt$, followed by a unique program location $\bigloc\in\locs$.
Another unique program location appears within each statement.
Since we rarely need to explicitly specify program locations, most of the time we do not report them to improve clarity.
A statement $\defstmt$ is either a skip statement $\skipstmt$, an assignment statement $\assignstmt$, a conditional statement $\pifstmt$, a while statement $\pwhilestmt$, or a composition statement $\pcompstmt$.

Arithmetic expressions $\defaexp$ are either a variable $\defvariable\in\variables$, an addition $\defaexp + \defaexp$, a subtraction $\defaexp - \defaexp$, or a non-deterministic choice $\randval(l, u)$ that returns a random integer between $l\in\Zinf$ and $u\in\Zinf$.\sidenote{Note that, the non-deterministic choice cannot be instantiated as $\randval(+\infty,+\infty)$ as we require the two bounds to be not equal.} The non-deterministic choice is useful to model user input, to approximate function calls, arithmetic expressions that cannot be represented exactly in our language, or--generally--uncertainty in the program.
%
Boolean expressions $\defbexp$ are either a comparison between arithmetic values $\defaexp \le \defvalue$ and $\defaexp = \defvalue$, a conjunction $\defbexp \land \defbexp$, or a negation $\lnot \defbexp$.

\begin{remark}[{Syntactic Sugar}]
  The syntax depicted in \reffig{syntax} is minimalistic. Through \emph{syntactic sugar}, we can extend the language with additional constructs that are not part of the core language but can be expressed in terms of the core constructs. For instance, we can define a shorthand version of the conditional statement as just $\shortifstmt$ without the else branch. Such syntactic sugar expands to $\ifstmt[\defstmt][\skipstmt]$.

  Similarly, we can reconstruct boolean expressions as well: $\defbexp \lor \defbexp'$ is expanded to $\lnot(\lnot\defbexp \land \lnot\defbexp')$ by De Morgan's laws.
\end{remark}

We could have been ever more minimalistic, \eg, all arithmetic expressions could have been defined from $1$, $-$, and iteration, or all boolean expressions with $<$ and $\texttt{nand}$. The syntax in \reffig{syntax} is a trade-off between minimalism, simplicity, and expressiveness.

\subsection{Maximal Trace Semantics}
\labsec{maximal-trace-semantics}


\begin{marginfigure}
  \begin{align*}
    &\aexpsemantics \IN \env \to \setof\values \\
    &\aexpsemanticsnoparam \semanticsof{\defvalue} \defenv \DefeQ \{\defvalue\} \\
    &\aexpsemanticsnoparam \semanticsof{\defvariable} \defenv \DefeQ \{\defenv(\defvariable)\} \\
    &\aexpsemanticsnoparam \semanticsof{\defaexp + \defaexp'} \defenv \DefeQ \\
      & \quad \setdef*{\defvalue + \defvalue'}{\defvalue \in \aexpsemanticsnoparam \semanticsof{\defaexp}\defenv \land {} \\ \defvalue' \in \aexpsemanticsnoparam \semanticsof{\defaexp'}\defenv} \\
    &\aexpsemanticsnoparam \semanticsof{\defaexp - \defaexp'} \defenv \DefeQ \\
      & \quad \setdef*{\defvalue - \defvalue'}{\defvalue \in \aexpsemanticsnoparam \semanticsof{\defaexp}\defenv \land {} \\ \defvalue' \in \aexpsemanticsnoparam \semanticsof{\defaexp'}\defenv} \\
    &\aexpsemanticsnoparam \semanticsof{\randval(l, u)} \defenv \DefeQ \\
    & \quad \setdef{\defvalue\in\values}{l \le \defvalue \le u}
  \end{align*}
\caption{Semantics of arithmetic expressions.}
\labfig{aexp-semantics}
\end{marginfigure}

\begin{marginfigure}
  \begin{align*}
    &\bexpsemantics \IN \env \to \B \\
    &\bexpsemanticsnoparam \semanticsof{\defaexp \le \defvalue} \defenv \DefifF \defenv(\defaexp) \le \defvalue \\
    &\bexpsemanticsnoparam \semanticsof{\defaexp = \defvalue} \defenv \DefifF \defenv(\defaexp) = \defvalue \\
    &\bexpsemanticsnoparam \semanticsof{\defbexp \land \defbexp'} \defenv \DefifF \\
      & \quad\bexpsemanticsnoparam \semanticsof{\defbexp}\defenv \land \bexpsemanticsnoparam \semanticsof{\defbexp'}\defenv \\
    &\bexpsemanticsnoparam \semanticsof{\lnot \defbexp} \defenv \DefifF \neg \bexpsemanticsnoparam \semanticsof{\defbexp}\defenv
  \end{align*}
\caption{Semantics of boolean expressions.}
\labfig{bexp-semantics}
\end{marginfigure}



Here, we instantiate the general definition of transition system and maximal trace semantics, \cf{} \refdef{maximal-trace-semantics}, for our small imperative language.

\paragraph{Expression Semantics}


An \emph{environment} $\defenv\in\env\defeq\variables \to \values$ is a mapping from a variable $\defvariable\in\variables$ to its value in memory $\defenv(\defvariable)\in\values$.
The semantics of an arithmetic expression $\defaexp$ is defined as the function $\aexpsemantics\in\setof\env\to\setof\values$ that maps a set of environments $\defsetofenvs$ to the set of values $\aexpsemantics\defsetofenvs$ that the expression $\defaexp$ can evaluate to under the environments in $\defsetofenvs$.
\reffig{aexp-semantics} shows the definition of $\aexpsemanticsnoparam$.

Similarly, we define the semantics of boolean expressions $\defbexp$ as the function $\bexpsemantics\in\setof\env\to\setof\env$ that filters a set of environments $\defsetofenvs$ to those in which the expression $\defbexp$ holds. The semantics of boolean expressions is defined in \reffig{bexp-semantics}. In the following, we write $\texttt{true}$ and $\texttt{false}$ for the boolean expression that always evaluates to true and false, respectively.







The update of an environment $\defenv$ with a variable $\defvariable$ to a value $\defvalue$ is denoted by $\updatemem{\defenv}{\defvariable}{\defvalue} \defeq \lambda \defvariable'.\defenv(\defvariable')$ if $\defvariable \neq \defvariable'$ and $\defvalue$ otherwise. The environment update is pointwise lifted to sets of environments, \ie, $\updatemem{\defsetofenvs}{\defvariable}{\defvalue} \defeq \setdef{\updatemem{\defenv}{\defvariable}{\defvalue}}{\defenv\in\defsetofenvs}$.


\begin{marginfigure}
  \begin{align*}
    &\initialloc[\plskipstmt] \DefeQ \bigloc \\
    &\initialloc[\plassignstmt] \DefeQ \bigloc \\
    &\initialloc[\plifstmt] \DefeQ \bigloc \\
    &\initialloc[\plwhilestmt] \DefeQ \bigloc \\
    &\initialloc[\plcompstmt] \DefeQ \initialloc[\defstmt] \\
    &\initialloc[\plprogstmt] \DefeQ \initialloc[\defstmt]
  \end{align*}
\caption{Initial control points.}
\labfig{initial}
\end{marginfigure}

\begin{figure}[t]
  \centering
  \begin{subfigure}{.45\textwidth}
  \begin{align*}
    &(\defstmt = \skipstmt)\\
    &\quad\finalloc[\plskipstmt] \DefeQ \finalloc[\defstmt]
    \\[0.2cm]
    &(\defstmt = \assignstmt)\\
    &\quad\finalloc[\plassignstmt] \DefeQ \finalloc[\defstmt]
    \\[0.2cm]
    &(\defstmt = \ifstmt[\defstmt'][\defstmt''][\defbexp])\\
    &\quad\finalloc[{\plifstmt[\defstmt'][\defstmt''][\defbexp]}] \\
    &\qquad\DefeQ \finalloc[\defstmt] \\
    &\quad\finalloc[\defstmt'] \DefeQ \finalloc[\defstmt] \\
    &\quad\finalloc[\defstmt''] \DefeQ \finalloc[\defstmt]
  \end{align*}
\end{subfigure}
\hfill
\begin{subfigure}{.45\textwidth}
  \begin{align*}
    &(\defstmt = \whilestmt[\defstmt'])\\
    &\quad\finalloc[\whilestmt[\defstmt']] \DefeQ \\
    &\qquad\finalloc[\defstmt] \\
    &\quad\finalloc[\defstmt'] \DefeQ \bigloc
    \\[0.2cm]
    &(\defstmt = \compstmt[\defstmt'][\defstmt''])\\
    &\quad\finalloc[\plcompstmt] \DefeQ \finalloc[\defstmt'']\\
    &\quad\finalloc[\defstmt'] \DefeQ \initialloc[\defstmt'']\\
    &\quad\finalloc[\defstmt''] \DefeQ \finalloc[\defstmt]
    \\[0.2cm]
    &(\defstmt = \progstmt[\defstmt])\\
    &\quad\finalloc[\plprogstmt] \DefeQ \bigloc
  \end{align*}
\end{subfigure}
\caption{Final control points.}
\labfig{final}
\end{figure}

\paragraph{Transition System}



Program states are tuples of program locations and environments, $\defstate\in\state\defeq\pair\locs\env$.
The initial control point of a program (or a statement) defines where the execution of the program (statement) starts, namely $\initialloc$ and $\initialloc[\defstmt]$ respectively.
Similarly, the final control point of a program (or a statement) defines where the execution of the program (statement) ends, namely $\finalloc$ and $\finalloc[\defstmt]$ respectively. The formal definitions of initial and final control points are given in \reffig{initial} and \reffig{final}.


A program $\defprogram$ starts the execution at its initial program location $\initialloc[\defprogram]$ with any value for the program variables. The set of initial states of a program $\defprogram$ is $\initialstates \defeq \setdef{\tuple{\initialloc[\defprogram]}{\defenv\in\env}}{\defenv\in\env}$.

In the following, we lift to set of states and environment the arithmetic expression, boolean expression, and environment updates.
Formally, for $\defsetofstates\in\setof\state$ and $\defsetofenvs\in\setof\env$, we define:
\begin{align*}
  \aexpsemantics\defsetofenvs &\DefeQ \setdef{\defvalue\in\values}{\defvalue\in\aexpsemanticsnoparam\semanticsof{\defaexp}\defenv \land \defenv\in\defsetofenvs} \\
  \bexpsemantics \defsetofstates &\DefeQ \setdef{\tracetuple{\bigloc}{\defenv}\in\defsetofstates}{\bexpsemantics\defenv} \\
  \bexpsemantics \defsetofenvs &\DefeQ \setdef{\defenv\in\defsetofenvs}{\bexpsemantics\defenv} \\
  \updatemem{\defsetofenvs}{\defvariable}{\defvalue} &\DefeQ \setdef{\updatemem{\defenv}{\defvariable}{\defvalue}}{\defenv\in\defsetofenvs}
\end{align*}

The transition relation $\transitionrelation\in\pair\state\state$ applied to a program $\defprogram$ is defined as the transition semantics $\transitionrelation\semanticsof{\defprogram}\in\pair\state\state$.
Next, we define $\transitionrelation$ for each program construct.

\begin{description}
  \marginnote{
    \begin{align*}
      &\transitionrelation \semanticsof{\plskipstmt} \DefeQ \\
      & \quad \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}}{\defenv\in\env}
    \end{align*}
  }

  \item[\normalfont ($\plskipstmt$)] The skip statement does not modify the environment, and control moves from the initial location $\bigloc$ to the final location $\finalloc[\plskipstmt]$.

  \marginnote{
    \begin{align*}
      &\transitionrelation \semanticsof{\plassignstmt} \DefeQ \\
      &\quad\setdef@{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}}{\defenv\in\env \land \defvalue\in\aexpsemanticsnoparam \semanticsof{\defaexp}\defenv}
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] The assignment statement updates the value of the variable $\defvariable$ to any possible value\sidenote{
    The expression $\aexpsemantics\defenv$ may generate multiple values due to the non-deterministic choice $\randval(l, u)$.} of the arithmetic expression $\defaexp$, and control moves from the initial location $\bigloc$ to the final location $\finalloc[\plassignstmt]$.
  \marginnote{
    \begin{align*}
      &\transitionrelation \semanticsof{\plifstmt} \DefeQ \\
      &\quad \setdef@{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt]}{\defenv}}}{\defenv\in\env \land \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt} \SetjoiN {} \\
      &\quad \setdef@{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt']}{\defenv}}}{\defenv\in\env \land \neg \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt'}
    \end{align*}
  }
  \item[\normalfont ($\plifstmt$)] The conditional statement moves control from the initial location $\bigloc$ to the first statement $\defstmt$ for environments that satisfy the boolean expression $\defbexp$, and to the beginning of the second statement $\defstmt'$ for environments that do not satisfy the boolean expression; then, $\defstmt$ and $\defstmt'$ are executed independently.
  \item[\normalfont ($\plwhilestmt$)]
  The while statement moves control from the initial location $\bigloc$ \marginnote{
    \begin{align*}
      &\transitionrelation \semanticsof{\plwhilestmt} \DefeQ \\
      & \setdef@{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt]}{\defenv}}}{\defenv\in\env \land \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt} \SetjoiN {} \\
      & \setdef@{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}}{\defenv\in\env \land \neg \bexpsemantics \defenv}
    \end{align*}
  }to the beginning of the statement $\defstmt$ for environments that satisfy the boolean expression $\defbexp$, and to the final location $\finalloc[\plwhilestmt]$ for environments that do not satisfy the boolean expression; then, $\defstmt$ is executed.
  \marginnote{
    \begin{align*}
      &\transitionrelation \semanticsof{\plcompstmt} \DefeQ \transitionrelation \semanticsof{\defstmt} \SetjoiN \transitionrelation \semanticsof{\defstmt'}
    \end{align*}
  }
  \item[\normalfont ($\plcompstmt$)] The composition statement executes the first and second statements, and join the transitions. Note that, control moves from the end of $\defstmt$ to the beginning of $\defstmt'$ because the final label of $\defstmt$ is the initial label of $\defstmt'$, \cf{} \reffig{initial} and \reffig{final}.
  \item[\normalfont ($\plprogstmt$)] The transition relation of a program is the transition relation of its statement.
  \begin{definition}[{Transition Semantics}]
    The transition semantics of a program $\defprogram$ is the set of all possible transitions that the program can generate:
    \begin{align*}
      \transitionrelation\semanticsof{\defprogram} \DefeQ \transitionrelation\semanticsof{\progstmt} \DefeQ \transitionrelation\semanticsof{\defstmt}
    \end{align*}
  \end{definition}
\end{description}


% \begin{figure}[t]
%   \begin{align*}
%     &\transitionrelation \semanticsof{\plskipstmt} \DefeQ \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}}{\defenv\in\env} \\
%     &\transitionrelation \semanticsof{\plassignstmt} \DefeQ \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}}{\defenv\in\env \land \defvalue\in\aexpsemanticsnoparam \semanticsof{\defaexp}\defenv} \\
%     &\transitionrelation \semanticsof{\plifstmt} \DefeQ \\
%       &\quad \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt]}{\defenv}}}{\defenv\in\env \land \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt} \SetjoiN {} \\
%       &\quad \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt']}{\defenv}}}{\defenv\in\env \land \neg \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt'} \\
%     &\transitionrelation \semanticsof{\plwhilestmt} \DefeQ \\
%       &\quad \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\initialloc[\defstmt]}{\defenv}}}{\defenv\in\env \land \bexpsemantics \defenv} \SetjoiN \transitionrelation \semanticsof{\defstmt} \SetjoiN {} \\
%       &\quad \setdef{\tracestep{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}}{\defenv\in\env \land \neg \bexpsemantics \defenv} \\
%     &\transitionrelation \semanticsof{\plcompstmt} \DefeQ \transitionrelation \semanticsof{\defstmt} \SetjoiN \transitionrelation \semanticsof{\defstmt'}
%     % \\
%     % &\transitionrelation \semanticsof{\plprogstmt} \DefeQ \transitionrelation \semanticsof{\defstmt}
%   \end{align*}
% \caption{Transition semantics for programs $\defprogram$.}
% \labfig{transition-semantics}
% \end{figure}

\paragraph{Maximal Trace Semantics}

\marginnote{The initial states of a program $\defprogram$ are defined as $\initialstates \defeq \setdef{\tuple{\initialloc[\defprogram]}{\defenv\in\env}}{\defenv\in\env}$. The final states are states where the program execution ends without any further transition possible, \ie, $\finalstates \defeq \setdef{\tuple{\finalloc[\defprogram]}{\defenv}}{\defenv\in\env}$.}

In this section, we provide the \emph{structural} definition of the maximal trace semantics by induction on the structure of the program. We recall that the maximal trace semantics is the set of all possible traces that a program can generate, a program trace is a non-empty sequence of program states determined by the transition relation. We only consider maximal \emph{well-formed} traces, that is, traces that start from initial states $\initialstates$ of a program $\defprogram$, and either end in a final state $\finalstates$ or never end.
Accordingly, we define the maximal trace semantics $\tracesemantics\in\tracetype$ for programs (and $\tracesemanticsnoparam\semanticsof{\defstmt}\in\tracetype \to \tracetype$ for statements). Note that, the function $\tracesemanticsnoparam\semanticsof{\defstmt}$ takes as input a set of traces starting with the final location of the statement $\defstmt$ and returns a set of traces starting with the initial location of the statement $\defstmt$. Specifically, according to the transition relation semantics, \cf{} \refdef{transition-semantics}, given a set of traces $\defsetoftraces\in\tracetype$ starting with the final location of the statement under evaluation:


\begin{description}
  \marginnote{
    \begin{align*}
      &\tracesemanticsnoparam \semanticsof{\plskipstmt}\defsetoftraces \DefeQ\\
      &\quad\setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \deftrace\in\finiteinfinitesequences\land {} \\ \concat{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\deftrace}\in\defsetoftraces}
    \end{align*}}
  \item[\normalfont ($\plskipstmt$)] The trace semantics of a skip statement  prepends to the traces of $\defsetoftraces$ that starts from the final location of the statement $\finalloc[\plskipstmt]$, \ie, the traces $\concat{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\deftrace}\in\defsetoftraces$,
   a single program state with the same environment $\defenv$ paired with the initial location $\bigloc$.
  \marginnote{
    \begin{align*}
      &\tracesemanticsnoparam \semanticsof{\plassignstmt}\defsetoftraces \DefeQ \\
      &\quad
       \setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\deftrace}}{\defenv\in\env \land \defvalue \in \aexpsemantics\defenv \land {} \\  \deftrace\in\finiteinfinitesequences \land {} \\ \concat{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\deftrace}\in\defsetoftraces}
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] For an assignment statement, to the traces of $\defsetoftraces$ that starts from the final location $\finalloc[\plassignstmt]$ and an updated environment $\updatemem{\defenv}{\defvariable}{\defvalue}$ with the effect of the assignment statement (where $\defvalue$ is a\sidenote{
    As noted before, the expression $\aexpsemantics\defenv$ may generate multiple values due to the non-deterministic choice $\randval(l, u)$.}
  value of the arithmetic expression $\defaexp$ under the environment $\defenv$), the trace semantics prepends a program state with the initial location $\bigloc$ and the environment $\defenv$ \emph{before} update. Note that, traces in maximal trace semantics $\tracesemanticsnoparam$ are built backwards, thus the environment $\defenv$ is prepended to the beginning of the trace, which is required starting from the updated environment $\updatemem{\defenv}{\defvariable}{\defvalue}$ at the final location $\finalloc[\plassignstmt]$.
  \marginnote{
    \begin{align*}
      &\tracesemanticsnoparam \semanticsof{\plifstmt}\defsetoftraces \DefeQ \\
      &\quad \setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemantics\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt}\defsetoftraces} \setjoin {} \\
      &\quad \setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt']}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\initialloc[\defstmt']}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt'}\defsetoftraces}
    \end{align*}
  }
  \item[\normalfont ($\plifstmt$)]
    The trace semantics of a conditional statement is the union of the traces from the then and the else branch. For the then branch, the trace semantics prepends a program state with the initial location $\bigloc$ and the environment $\defenv$ to the traces of $\tracesemanticsnoparam\semanticsof{\defstmt}$ that start from the initial location of the then branch, \ie, $\initialloc[\defstmt]$, and satisfies the boolean expression $\defbexp$.
    Similarly, for the else branch, the trace semantics prepends a program state with the initial location $\bigloc$ and the environment $\defenv$ to the traces of $\tracesemanticsnoparam\semanticsof{\defstmt'}$ that start from the initial location of the else branch, \ie, $\initialloc[\defstmt']$, and do not satisfy the boolean expression $\defbexp$.

  \marginnote{
    \begin{align*}
      &\tracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetoftraces \DefeQ \lfp^{\tracesubseteq} \tracetransformer \\
      &\quad \tracetransformer(X) \DefeQ \setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemantics\defenv \land {} \\ \deftrace\in\finiteinfinitesequences \land {} \\ \concat{\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt}X} \SetjoiN {} \\
        & \setdef@{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defenv \land {} \\ \deftrace\in\finiteinfinitesequences \land {} \\ \concat{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\deftrace}\in\defsetoftraces}
    \end{align*}
  }
  \item[\normalfont ($\plwhilestmt$)]
    The trace semantics of a while statement is the least fixpoint of a transformer $\tracetransformer$ over the complete lattice $\tracecompletelattice$
   that iteratively prepends the initial location $\bigloc$ and the environment $\defenv$ to the traces provided as argument that start from the initial location of the loop statement and satisfies the boolean expression $\defbexp$.
In particular, the transformer $\tracetransformer$ takes as input a set $X\in\tracetype$ of traces.
Initially, $X$ is the set of all infinite sequences $\tracebottom$ (\ie, bottom element of the complete lattice of traces).
At each iteration, the transformer joins $\ref{a-max}$ the traces from an iteration of traces in $X$ with $\ref{b-max}$ the traces in $\defsetoftraces$ that do not satisfy the boolean expression $\defbexp$, that is, the postcondition of the loop body that is able to enter backward the loop.
\begin{itemize}
  \item \label{a-max} $\tracetransformer$ prepends the initial location $\bigloc$ and the environment $\defenv$ to the traces of the loop body $\defstmt$, \ie,  $\tracesemanticsnoparam\semanticsof{\defstmt}$, that start from the initial location $\initialloc[\defstmt]$ and satisfy the boolean expression $\defbexp$.
  \item \label{b-max} $\tracetransformer$ prepends the initial location $\bigloc$ and the environment $\defenv$ to the traces in $\defsetoftraces$ that start from the final location of the loop statement $\finalloc[\plwhilestmt]$ and do not satisfy the boolean expression $\defbexp$.
\end{itemize}
The invariant after the $i$-th iteration contains the program \emph{traces} starting at the initial location of the loop statement whose prefix consist of 0 up to $i-1$ iterations of the loop and whose suffix is a trace in $\defsetoftraces$, and the \emph{sequences}\sidenote{Note the difference between traces and sequences: a program \emph{trace} is a \emph{sequence} of program states that respects the transition relation.} whose prefix are program traces which consist of $i-1$ iterations.
At the limit, the set of traces generated by the transformer $\tracetransformer$ corresponds to executing the loop an arbitrary number of times, until the boolean expression $\defbexp$ is false, and then exiting the loop.
\marginnote{
  \begin{align*}
    \tracesemanticsnoparam \semanticsof{\compstmt}\defsetoftraces \DefeQ \tracesemanticsnoparam\semanticsof{\defstmt}(\tracesemanticsnoparam\semanticsof{\defstmt'}\defsetoftraces)
  \end{align*}
}
\item[\normalfont ($\plcompstmt$)] The trace semantics of a composition of two statements is the (function) composition of the trace semantics of the two statements, backwards starting from $\defstmt'$ to $\defstmt$.
\item[\normalfont ($\plprogstmt$)] Finally, the trace semantics $\tracesemantics\in\tracetype$ of a program $\defprogram$ is the trace semantics of the entry statement restricted to the traces starting from the program initial states $\initialstates$, defined from the set of program final states $\finalstates$.
\marginnote{The initial states of a program $\defprogram$ are defined as: \[\initialstates \defeq \setdef{\tuple{\initialloc[\defprogram]}{\defenv\in\env}}{\defenv\in\env}
\]
The final states are states where the program execution ends without any further transition possible, \ie, \[\finalstates \defeq \setdef{\tuple{\finalloc[\defprogram]}{\defenv}}{\defenv\in\env}\]
}
\begin{definition}[Maximal Trace Semantics of Programs]\labdef{maximal-trace-semantics-of-programs}
  The \emph{maximal trace semantics} $\tracesemantics\in\tracetype$ of a program $\defprogram$ is defined as:
  \begin{align*}
    &\tracesemantics \DefeQ \\
    &\tracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \setdef*{
      \concat{\tracetuple{\bigloc}{\defenv}}{\deftrace}
    }{\defenv\in\initialstates \land \deftrace\in\finiteinfinitesequences \land {} \\ \concat{\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt}\finalstates}
  \end{align*}
\end{definition}
\end{description}

Next, we present the forward and backward reachability semantics of programs.
These two semantics will be used to define the abstract semantics and to introduce the abstract domains.

% \begin{figure*}[t]
%   \begin{align*}
%     &\tracesemanticsnoparam \semanticsof{\plskipstmt}\defsetoftraces \DefeQ \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \deftrace\in\finiteinfinitesequences\land\concat{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\deftrace}\in\defsetoftraces} \\
%     &\tracesemanticsnoparam \semanticsof{\plassignstmt}\defsetoftraces \DefeQ
%        \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\deftrace}}{\defenv\in\env \land \defvalue \in \aexpsemantics\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\deftrace}\in\defsetoftraces} \\
%     &\tracesemanticsnoparam \semanticsof{\plifstmt}\defsetoftraces \DefeQ \\
%       &\quad \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemantics\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt}\defsetoftraces} \SetjoiN {} \\
%       &\quad \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt']}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\initialloc[\defstmt']}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt'}\defsetoftraces} \\
%     &\tracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetoftraces \DefeQ \lfp^{\tracesubseteq} \tracetransformer \\
%       &\quad \tracetransformer(X) \DefeQ \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemantics\defenv \land \deftrace\in\finiteinfinitesequences \\ {} \land \concat{\tracetuple{\initialloc[\defstmt]}{\defenv}}{\deftrace}\in\tracesemanticsnoparam\semanticsof{\defstmt}X} \SetjoiN {} \\
%         &\qquad \setdef*{\concat{\tracetuple{\bigloc}{\defenv}\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\deftrace}}{\defenv\in\env \land \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defenv \\ {} \land \concat{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\deftrace}\in\defsetoftraces} \\
%     &\tracesemanticsnoparam \semanticsof{\compstmt}\defsetoftraces \DefeQ \tracesemanticsnoparam\semanticsof{\defstmt}(\tracesemanticsnoparam\semanticsof{\defstmt'}\defsetoftraces)
%     \\
%     &\tracesemanticsnoparam \semanticsof{\progstmt}\defsetoftraces \DefeQ \tracesemanticsnoparam\semanticsof{\defstmt}\defsetoftraces
%   \end{align*}
% \caption{Maximal trace semantics for programs $\defprogram$.}
% \labfig{maximal-trace-semantics}
% \end{figure*}

\subsection{Forward Reachability State Semantics}
\labsec{forward-reachability-state-semantics}


% The forward reachability state semantics $\forwardreachabilitysemanticsnoparam\in\forwardreachabilitytype$ introduced in \refexample{forward-reachability-state-semantics} abstracts the maximal trace semantics $\tracesemanticsnoparam\in\tracetype$ (\cf{} \refdef{maximal-trace-semantics}) by collecting all the possible reachability environments at each program location. In this section, we present the \emph{structural} definition of the forward reachability state semantics by induction on the structure of the program.

% Note that, the complete lattice of the reachability semantics $\forwardreachabilitycompletelattice$ is isomorphic to the complete lattice $\forwardliftedcompletelattice$ of functions from program locations to the set of reachability environments by pointwise lifting, \cf{} \refdef{pointwise-lifting}.
% We formalize it as a Galois connection, specifically a Galois isomorphism:
% \[\tuple{\forwardreachabilitytype}{\forwardreachabilitysubseteq} \GaloiS{\forwardliftedabstraction}{\forwardliftedconcretization} \tuple{\forwardliftedtype}{\forwardliftedsubseteq}\]
% where the abstraction $\forwardliftedabstraction$ and the concretization $\forwardliftedconcretization$ are defined as:
% \begin{align*}
%   \forwardliftedabstraction &\IN \forwardreachabilitytype \to \forwardliftedtype \\
%   \forwardliftedabstraction(\defsetofstates) &\DefeQ \lambda \bigloc.\setdef{\defenv \in \env}{\tuple{\bigloc}{\defenv}\in\defsetofstates} \\
%   \forwardliftedconcretization &\IN \forwardliftedtype \to \forwardreachabilitytype \\
%   \forwardliftedconcretization(f) &\DefeQ \setdef{\tuple{\bigloc}{\defenv}\in\state}{\defenv\in f(\bigloc)}
% \end{align*}

% We call this abstract semantics the \emph{invariance semantics} as it captures the invariance of the program states at each program location.

The forward reachability state semantics $\forwardreachabilitytracesemanticsnoparam\in\forwardreachabilitytracetype$ introduced in \refexample{forward-reachability-state-semantics} abstracts the maximal trace semantics $\tracesemanticsnoparam\in\tracetype$ by collecting reachable states from a given set of initial states.
Here, we present the \emph{structural} definition of the forward reachability state semantics by induction on the structure of the program.
Given a set of states $\defsetofstates\in\setof{\state}$, for each program statement $\defstmt$, the forward reachability state semantics $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ is defined as:

\begin{description}
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plskipstmt}\defsetofstates \DefeQ \\
      &\quad\setdef{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\tracetuple{\bigloc}{\defenv} \in \defsetofstates}
    \end{align*}
  }
  \item[\normalfont ($\plskipstmt$)] The reachability semantics of a skip statement maintains the set of environments of $\defsetofstates$ that are paired to program locations starting at the initial location $\bigloc = \initialloc[\plskipstmt]$.Program locations are updated to the final location $\finalloc[\plskipstmt]$.
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ \\
      &\quad
       \setdef@{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\tracetuple{\bigloc}{\defenv}\in\defsetofstates \land {} \\ \defvalue \in \aexpsemantics\defenv}
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] The reachability semantics of an assignment statement updates the environments in $\defsetofstates$ with any value from the arithmetic expression $\defaexp$. Program locations are updated to the final location $\finalloc[\plassignstmt]$.
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plifstmt}\defsetofstates \DefeQ \\
      &\quad \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics\defsetofstates) \setjoin \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} (\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defsetofstates)
    \end{align*}
  }
  \item[\normalfont ($\plifstmt$)] The reachability semantics of a conditional statement is the union of the reachability semantics of the then and the else branch. For the then branch, $\bexpsemantics \defsetofstates$ filters out the environments that do not satisfy the boolean expression $\defbexp$ (without moving control of these states), then the reachability semantics of the then branch $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ is computed. Note that, the reachability semantics of the then branch expects control locations at the final location of the then branch, \ie{} $\finalloc[\defstmt]$, which is also the final location of the conditional statement, \cf{} \reffig{final}, hence the program locations are not updated before the branch evaluation. Similarly, for the else branch, the reachability semantics of the else branch $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}$ is computed for the environments that do not satisfy the boolean expression $\defbexp$.
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetofstates \DefeQ
    \\
    &\quad\setdef@{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\tracetuple{\bigloc}{\defenv} \in \bexpsemanticsnoparam \semanticsof{\neg\defbexp}(\lfp^{\forwardreachabilitytracesubseteq} \forwardreachabilitytracetransformer)}
    \\
    &\qquad \forwardreachabilitytracetransformer(X) \DefeQ \defsetofstates \setjoin \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics X)
    \end{align*}
  }
  \item[\normalfont ($\plwhilestmt$)] The reachability semantics of a while statement is the set of states with program locations updated to the final location $\finalloc[\plwhilestmt]$ that do not satisfy the boolean expression $\defbexp$ from the least fixpoint of a transformer $\forwardreachabilitytracetransformer$.
  Program locations are updated to the final location $\finalloc[\plwhilestmt]$ because the final location of the loop statement is $\bigloc$, not the final location of the loop body $\finalloc[\defstmt]$, \cf{} \reffig{final}.
  The transformer $\forwardreachabilitytracetransformer$ takes as input a set $X\in\setof{\state}$ of states.
  Initially, $X$ is the empty set $\emptyset$.
  At each iteration, the transformer joins $\defsetofstates$ with the reachability semantics of the loop body $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ for the environments in $X$ that satisfy the boolean expression $\defbexp$.
  At each iteration, program locations are correctly updated from $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ to $\bigloc$, ready for another iteration or the exit of the loop.
  The least fixpoint of the transformer $\forwardreachabilitytracetransformer$ collects all the states that can reach the final location of the loop statement $\finalloc[\plwhilestmt]$ (outside the loop) in an arbitrary number of iterations.
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plcompstmt}\defsetofstates \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}(\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\defsetofstates)
    \end{align*}
  }
  \item[\normalfont ($\plcompstmt$)] The reachability semantics of a composition of two statements is the (function) composition of the reachability semantics of the two statements, forward starting from $\defstmt$ to $\defstmt'$.
  Program locations are updated correctly from $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ and $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}$.
  % \marginnote{
  %   \begin{align*}
  %     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\initialstates
  %   \end{align*}
  % }
  \item[\normalfont ($\plprogstmt$)] Finally, the reachability semantics $\forwardreachabilitytracesemanticsnoparam\semanticsof{\defprogram}$ of a program $\defprogram$ is the reachability semantics from the set of initial states $\initialstates$.
  \marginnote{
    The initial states of a program $\defprogram$ are defined as: \[\initialstates \defeq \setdef{\tuple{\initialloc[\defprogram]}{\defenv\in\env}}{\defenv\in\env}\]
  }
  \begin{definition}[Forward Reachability State Semantics of Programs]\labdef{forward-reachability-state-semantics}
    The \emph{forward reachability state semantics} $\forwardreachabilitytracesemantics\in\forwardreachabilitytracetype$ of a program $\defprogram$ is defined as:
    \begin{align*}
      &\forwardreachabilitytracesemantics \DefeQ
      \forwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\initialstates
    \end{align*}
  \end{definition}
\end{description}

Note that, the reachability semantics presented in this section is strictly less expressive than the maximal trace semantics. For instance, it does not capture non-terminating traces.

% \begin{figure}[t]
%   \begin{align*}
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plskipstmt}\defsetofstates \DefeQ \setdef{\tracetuple{\finalloc[\plskipstmt]}{\defenv}}{\tracetuple{\otherloc}{\defenv} \in \defsetofstates}
%     \\
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ
%        \setdef{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\tracetuple{\otherloc}{\defenv}\in\defsetofstates \land \defvalue \in \aexpsemantics\defenv }
%        \\
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plifstmt}\defsetofstates \DefeQ
%     \\
%     &\quad \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics\defsetofstates) \SetjoiN \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} (\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defsetofstates)
%     \\
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetofstates \DefeQ
%     \\
%     &\quad\setdef{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}}{\tracetuple{\otherloc}{\defenv} \in \bexpsemanticsnoparam \semanticsof{\neg\defbexp}(\lfp^{\forwardreachabilitytracesubseteq} \forwardreachabilitytracetransformer)}
%     \\
%     &\qquad \forwardreachabilitytracetransformer(X) \DefeQ \defsetofstates \setjoin \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics X)
%     \\
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\compstmt}\defsetofstates \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}(\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\defsetofstates)
%     \\
%     &\forwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\initialstates
%   \end{align*}
% \caption{Forward reachability state semantics for programs $\defprogram$.}
% \labfig{forward-reachability-state-semantics}
% \end{figure}

As a simplification, \reffig{forward-reachability-state-semantics-without-location} shows the forward reachability state semantics without explicitly handling program locations, in such case, the program states are just the environments, \ie, $\state = \env$.



\begin{figure}[h]
  \begin{align*}
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\pskipstmt}\defsetofenvs \DefeQ \defsetofenvs
    \\
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\passignstmt}\defsetofenvs \DefeQ \setdef{\updatemem{\defsetofenvs}{\defvariable}{\defvalue}}{\defvalue \in \aexpsemantics\defsetofenvs}
       \\
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\pifstmt}\defsetofenvs \DefeQ
    \\
    &\quad \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics\defsetofenvs) \SetjoiN \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} (\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defsetofenvs)
    \\
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\pwhilestmt}\defsetofenvs \DefeQ
    \bexpsemanticsnoparam \semanticsof{\neg\defbexp}(\lfp^{\forwardreachabilitytracesubseteq} \forwardreachabilitytracetransformer)
    \\
    &\qquad \forwardreachabilitytracetransformer(X) \DefeQ \defsetofenvs \setjoin \forwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} (\bexpsemantics X)
    \\
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\pcompstmt}\defsetofenvs \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}(\forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\defsetofenvs)
    \\
    &\forwardreachabilitytracesemanticsnoparam \semanticsof{\pprogstmt} \DefeQ \forwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\setdef{\defenv\in\env}{\bigloc\in\locs\land\tracetuple{\bigloc}{\defenv}\in\initialstates}
  \end{align*}
\caption{Forward reachability state semantics without program locations.}
\labfig{forward-reachability-state-semantics-without-location}
\end{figure}

\subsection{Backward Co-Reachability State Semantics}
\labsec{backward-reachability-state-semantics}

The backward co-reachability state semantics $\backwardreachabilitytracesemanticsnoparam\in\backwardreachabilitytracetype$ introduced in \refexample{backward-reachability-state-semantics} abstracts the maximal trace semantics $\tracesemanticsnoparam\in\tracetype$ by collecting the program states that can reach a given set of final states. In this section, we present the \emph{structural} definition of the backward co-reachability state semantics by induction on the structure of the program:

\begin{description}
  \marginnote{
    \begin{align*}
      &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plskipstmt}\defsetofstates \DefeQ \\
      &\setdef*{\tracetuple{\bigloc}{\defenv}}{\defenv\in\env\land {} \\ \tracetuple{\finalloc[\plskipstmt]}{\defenv} \in \defsetofstates}
    \end{align*}
  }
  \item[\normalfont ($\plskipstmt$)] The backward co-reachability semantics of a skip statement maintains the set of environments of $\defsetofstates$ with program locations updated to the initial location of the skip statement, \ie, the program location $\bigloc$.
  \marginnote{
    \begin{align*}
      &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ \\
      &\quad\setdef@{\tracetuple{\bigloc}{\defenv}}{\defenv\in\env \land \defvalue \in \aexpsemantics\defenv \land {} \\ \tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}\in\defsetofstates}
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] The backward co-reachability semantics of an assignment statement is the set of states $\tracetuple{\bigloc}{\defenv}$ such that the updated environment $\updatemem{\defenv}{\defvariable}{\defvalue}$ is in $\defsetofstates$ with program location $\finalloc[\plassignstmt]$. The value $\defvalue$ is evaluated from the arithmetic expression $\defaexp$ under the environment $\defenv$, before the assignment.
  \marginnote{
    \begin{align*}
      &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plifstmt}\defsetofstates \DefeQ \\
      &\quad \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} \defsetofstates) \setjoin \bexpsemanticsnoparam\semanticsof{\neg\defbexp}(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} \defsetofstates)
    \end{align*}
  }
  \item[\normalfont ($\plifstmt$)] Similarly to the forward reachability semantics for the conditional statement, the backward co-reachability semantics is the union of the semantics applied to the branches. Slightly differently, the boolean condition is evaluated \emph{after} the branch evaluation. As the initial location of both branches is $\bigloc$, there is no need to further update the program locations.
  \marginnote{
    \begin{align*}
      &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetofstates \DefeQ \lfp^{\backwardreachabilitytracesubseteq} \backwardreachabilitytracetransformer \\
      & \backwardreachabilitytracetransformer(X) \DefeQ \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} X)\SetjoiN {} \\
      &\bexpsemanticsnoparam\semanticsof{\neg\defbexp}\setdef@{\tracetuple{\bigloc}{\defenv}}{\tracetuple{\finalloc[\plwhilestmt]}{\defenv}\in\defsetofstates}
    \end{align*}
  }
  \item[\normalfont ($\plwhilestmt$)] The backward co-reachability semantics of a while statement is the least fixpoint of the transformer $\backwardreachabilitytracetransformer$. The transformer joins the state that--instead--satisfy the boolean expression $\defbexp$ from the backward co-reachability semantics of the loop body $\backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}$ applied to the input of the transformer $X$, with the set of states $\defsetofstates$ that do not satisfy the boolean expression $\defbexp$.
  Note that, we update the program locations of the states in $\defsetofstates$ as otherwise when input of the next transformer iterate they would not be considered correct for the loop body as $\finalloc[\plwhilestmt] \neq \finalloc[\defstmt]$.
  \marginnote{
    \begin{align*}
      &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plcompstmt}\defsetofstates \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}(\backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}\defsetofstates)
    \end{align*}
  }
  \item[\normalfont ($\plcompstmt$)] Similarly to the previous semantics, the backward co-reachability semantics of a composition of two statements is their (backwards) composition.
  % \marginnote{
  %   \begin{align*}
  %     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\finalstates
  %   \end{align*}
  % }
  \item[\normalfont ($\plprogstmt$)] Finally, the backward co-reachability semantics $\backwardreachabilitytracesemanticsnoparam\semanticsof{\defprogram}$ of a program $\defprogram$ is the reachability semantics from the set of final states $\finalstates$.
  \marginnote{
    The final states of a program $\defprogram$ are defined as: \[\finalstates \defeq \setdef{\tuple{\finalloc[\defprogram]}{\defenv\in\env}}{\defenv\in\env}\]
  }
  \begin{definition}[Backward Co-Reachability State Semantics of Programs]\labdef{backward-reachability-state-semantics}
    The \emph{backward co-reachability state semantics} $\backwardreachabilitytracesemantics\in\backwardreachabilitytracetype$ of a program $\defprogram$ is defined as:
    \begin{align*}
      &\backwardreachabilitytracesemantics \DefeQ
      \backwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\finalstates
    \end{align*}
  \end{definition}
\end{description}

As done for the forward reachability semantics, \reffig{backward-reachability-state-semantics-without-location} shows the backward reachability state semantics without explicitly handling program locations, in such case, the program states are just the environments, \ie, $\state = \env$.


% \begin{figure}[h]
%   \begin{align*}
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plskipstmt}\defsetofstates \DefeQ \setdef{\tracetuple{\initialloc[\plskipstmt]}{\defenv}}{\tracetuple{\otherloc}{\defenv} \in \defsetofstates}
%     \\
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ
%        \setdef{\tracetuple{\initialloc[\plassignstmt]}{\defenv}}{\tracetuple{\otherloc}{\updatemem{\defenv}{\defvariable}{\defvalue}}\in\defsetofstates \land \defvalue \in \aexpsemantics\defenv }
%     \\
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plifstmt}\defsetofstates \DefeQ \\
%     &\quad \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} \defsetofstates) \SetjoiN \bexpsemanticsnoparam\semanticsof{\neg\defbexp}(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} \defsetofstates)
%     \\
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plwhilestmt}\defsetofstates \DefeQ \lfp^{\backwardreachabilitytracesubseteq} \backwardreachabilitytracetransformer \\
%     &\qquad \backwardreachabilitytracetransformer(X) \DefeQ \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defsetofstates \SetjoiN \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} X)
%     \\
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\compstmt}\defsetofstates \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}(\backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}\defsetofstates)
%     \\
%     &\backwardreachabilitytracesemanticsnoparam \semanticsof{\progstmt} \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\finalstates
%   \end{align*}
% \caption{Backward reachability state semantics for programs $\defprogram$.}
% \labfig{backward-reachability-state-semantics}
% \end{figure}


\begin{figure}[h]
  \begin{align*}
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\pskipstmt}\defsetofenvs \DefeQ \defsetofenvs
    \\
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\passignstmt}\defsetofenvs \DefeQ \setdef{\defenv\in\env}{\defvalue \in \aexpsemantics\defenv \land \updatemem{\defenv}{\defvariable}{\defvalue}\in\defsetofenvs}
       \\
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\pifstmt}\defsetofenvs \DefeQ
    \\
    &\quad \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} \defsetofenvs) \SetjoiN \bexpsemanticsnoparam\semanticsof{\neg\defbexp}(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt'} \defsetofenvs)
    \\
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\pwhilestmt}\defsetofenvs \DefeQ
    \lfp^{\backwardreachabilitytracesubseteq} \backwardreachabilitytracetransformer
    \\
    &\qquad \backwardreachabilitytracetransformer(X) \DefeQ \bexpsemanticsnoparam\semanticsof{\neg\defbexp}\defsetofenvs \SetjoiN \bexpsemantics(\backwardreachabilitytracesemanticsnoparam \semanticsof{\defstmt} X)
    \\
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\pcompstmt}\defsetofenvs \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}(\backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt'}\defsetofenvs)
    \\
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\pprogstmt} \DefeQ \backwardreachabilitytracesemanticsnoparam\semanticsof{\defstmt}\setdef{\defenv\in\env}{\bigloc\in\locs\land\tracetuple{\bigloc}{\defenv}\in\finalstates}
  \end{align*}
\caption{Backward reachability state semantics without program location.}
\labfig{backward-reachability-state-semantics-without-location}
\end{figure}


\subsection{Numerical Abstract Domains}
\labsec{numerical-abstract-domains}

In this section, we introduce one of the fundamental concepts of static analysis by abstract interpretation: abstract semantics and abstract domain. The abstract semantics are \emph{computable} semantics that overapproximate the concrete semantics defined in the previous section. The abstract semantics yield an effective algorithm to compute an overapproximation of the program fixpoint, and for this reason the terms abstract semantics and analysis are often used interchangeably. The abstract domains are machine-representable structures that capture some detail of the program behavior. They come with computable operations that allow the abstract analysis to be performed efficiently.

We consider concretization-based abstractions of the form:
\begin{align*}
  \tuple{\setof{\env}}{\subseteq} \overset{\abstractdomainconcretization}{\leftarrow} \tuple{\abstractdomain}{\abstractdomainsubseteq}
\end{align*}
which provide a sound and computable over-approximation of the concrete semantics.
  We introduce the concept of abstract domains with a simple example of the integer interval abstract domain \sidecite{Cousot1976,Hickey2001}, called \intervalname, \wrt{} the concrete domain of integers, \ie, $\values = \Z$.
  Hence, concrete environments are mappings from variables to integers, \ie, $\env = \variables \to \Z$.

\begin{marginfigure}
  \centering
  \begin{tikzpicture}[scale=0.355, every node/.style={font=\tiny}]
    % Nodes
    \node (empty) at (0,-0.4) {$\intervalbottom$};
    \node (m2m2) at (-4,2) {$[-2,-2]$};
    \node (m1m1) at (-2,2) {$[-1,-1]$};
    \node (00) at (0,2) {$[0,0]$};
    \node (11) at (2,2) {$[1,1]$};
    \node (22) at (4,2) {$[2,2]$};

    \node (m2m1) at (-3,4) {$[-2,-1]$};
    \node (m10) at (-1,4) {$[-1,0]$};
    \node (01) at (1,4) {$[0,1]$};
    \node (12) at (3,4) {$[1,2]$};

    \node (m20) at (-2,6) {$[-2,0]$};
    \node (m11) at (0,6) {$[-1,1]$};
    \node (02) at (2,6) {$[0,2]$};

    \node (inf) at (0,8.4) {$\intervaltop$};

     % Dots to indicate continuation
    \node (l0) at (-6,2) {$\dots$};
    \node (r0) at (6,2) {$\dots$};
    \node (l1) at (-5,4) {$\dots$};
    \node (r1) at (5,4) {$\dots$};
    \node (l2) at (-4,6) {$\dots$};
    \node (r2) at (4,6) {$\dots$};


    % Edges
    \draw (empty) -- (m2m2);
    \draw (empty) -- (m1m1);
    \draw (empty) -- (00);
    \draw (empty) -- (11);
    \draw (empty) -- (22);
    \draw[dotted] (empty) -- (l0);
    \draw[dotted] (empty) -- (r0);


    \draw (m2m2) -- (m2m1);
    \draw (m1m1) -- (m2m1);
    \draw (m1m1) -- (m10);
    \draw (00) -- (m10);
    \draw (00) -- (01);
    \draw (11) -- (01);
    \draw (11) -- (12);
    \draw (22) -- (12);
    \draw[dotted] (l0) -- (l1);
    \draw[dotted] (m2m2) -- (l1);
    \draw[dotted] (22) -- (r1);
    \draw[dotted] (r0) -- (r1);


    \draw (m2m1) -- (m20);
    \draw (m10) -- (m20);
    \draw (01) -- (02);
    \draw (12) -- (02);
    \draw (m10) -- (m11);
    \draw (01) -- (m11);
    \draw[dotted] (r1) -- (r2);
    \draw[dotted] (m2m1) -- (l2);
    \draw[dotted] (l1) -- (l2);
    \draw[dotted] (12) -- (r2);

    \draw[dotted] (m20) -- (inf);
    \draw[dotted] (m11) -- (inf);
    \draw[dotted] (02) -- (inf);
    \draw[dotted] (l2) -- (inf);
    \draw[dotted] (r2) -- (inf);

\end{tikzpicture}
  \caption{The interval lattice.}
  \labfig{interval-partial-order}
\end{marginfigure}

\paragraph{Integer Interval Abstract Domain}
This domain abstracts the values of each variable with an interval.
First we define interval values and operations on them, then we present the abstract domain. The interval values are defined as:
  \begin{align*}
    \intervaltype \DefeQ \setdef{\interval{l}{u}}{l \in \Zminus \land u \in \Zplus \land l \le u} \setjoin \{\intervalbottom\}
  \end{align*}
Note that, the interval values are either a closed interval $\interval{l}{u}$ with $l$ and $u$ integers such that $l \le u$, or the bottom element $\intervalbottom$ that represents the empty set of integers. Therefore, we can easily store the interval values in a machine, we say that $\intervaltype$ is \emph{machine-representable}.
The partial order $\intervalsubseteq\in\pair{\intervaltype}{\intervaltype}$ checks if an interval is included in another. Formally, for all $x, y \in \intervaltype$:
  \begin{align*}
    x = \intervalbottom \LoR (x = \interval{l}{u} \land y = \interval{l'}{u'} \IfF l' \le l \land u \le u')
  \end{align*}
  \reffig{interval-partial-order} shows the lattice of interval values.
  The concretization function $\intervalconcretization\in\intervaltype\to\setof\Z$ is defined as:
  \begin{align*}
    \intervalconcretization(x) \DefeQ \begin{cases}
      \emptyset & \text{if } x = \intervalbottom \\
      \setdef{v}{l \le v \le u} & \text{if } x = \interval{l}{u}
    \end{cases}
  \end{align*}
  concretizing the set of integers between the two bounds of the interval, or the empty set for the bottom element $\intervalbottom$.
  Note that, while interval values have a machine-representable form and the ordering relation is effectively computable, the concretization function is not.
%
  % The evaluation of arithmetic $\intervalaexp$ and boolean $\intervalbexp$ expressions for interval values are handled as one expects:
  % \begin{align*}
  %   \intervalaexp \semanticsof{\defvalue} &\DefeQ \interval{\defvalue}{\defvalue} \\
  %   \intervalaexp \semanticsof{\intervalbottom \oplus^{\intervalabstractdomaintype} \defabstractvalue} &\DefeQ \intervalbottom \\
  %   \intervalaexp \semanticsof{\defabstractvalue \oplus^{\intervalabstractdomaintype} \intervalbottom} &\DefeQ \intervalbottom \\
  %   \intervalaexp \semanticsof{\interval{l}{u} \oplus^{\intervalabstractdomaintype} \interval{l'}{u'}} &\DefeQ
  %   \interval{l \oplus l'}{u \oplus u'} \tag*{for $\oplus\in\{+, -\}$} \\
  %   \intervalaexp \semanticsof{\randval(l, u)} &\DefeQ \interval{l}{u} \\[1em]
  %   \intervalbexp \semanticsof{\intervalbottom \le \defvalue} &\DefifF \false \\
  %   \intervalbexp\semanticsof{\interval{l}{u} \le \defvalue} &\DefifF l \le \defvalue \\
  %   \intervalbexp\semanticsof{\intervalbottom = \defvalue} &\DefifF \false\\
  %   \intervalbexp\semanticsof{\interval{l}{u} = \defvalue} &\DefifF l \le \defvalue \le u\\
  %   \intervalbexp\semanticsof{\interval
  % \end{align*}
  % where $\defvalue\in\Z$ is an integer constant.
  %
  Next, we proceed with the description of the interval abstract domain.

  \begin{description}
    \item[Abstract Elements] The abstract elements of the interval abstract domain are mappings from variables $\variables$ to intervals $\intervaltype$:
    \marginnote{The finite set $\variables$ contains the program variables.}
    \begin{align*}
      \intervalabstractdomaintype \DefeQ \variables \to (\intervaltype \setminus \{\intervalbottom\}) \setjoin \{\intervalbottom\}
    \end{align*}
    where we enforce a single representation for the bottom element $\intervalbottom$, that is, if the interval associated to a variable is empty, then abstract domain contains no value for all the variables.
    As the amount of variables is finite, and the interval values are machine-representable, in turns, the elements of the interval abstract domain are machine-representable.
    \item[Partial Order] The partial order $\intervalabstractdomainsubseteq$ is defined as follows, for all $\defabstractvalue_1, \defabstractvalue_2 \in \intervalabstractdomaintype$:
    \begin{align*}
      \defabstractvalue_1 = \intervalabstractdomainbottom \lor (\defabstractvalue_1 \neq \intervalabstractdomainbottom \land \defabstractvalue_2 \neq \intervalabstractdomainbottom \land \forall \defvariable \in \variables.\spacer \defabstractvalue_1(\defvariable) \intervalsubseteq \defabstractvalue_2(\defvariable))
    \end{align*}
    An effective algorithm can check the ordering relation between two abstract elements just by comparing the intervals associated to each variable.
    \item[Concretization Function] The concretization function $\intervalabstractdomainconcretization\in\intervalabstractdomaintype\to\setof\env$ is defined as all the environments that satisfy the interval constraints:
    \begin{align*}
      \intervalabstractdomainconcretization(\defabstractvalue) \DefeQ \begin{cases}
        \emptyset & \text{if } \defabstractvalue = \intervalabstractdomainbottom \\
        \setdef{\defenv\in\env}{\forall \defvariable \in \variables.\spacer \defenv(\defvariable) \in \intervalconcretization(\defabstractvalue(\defvariable))} & \text{otherwise}
      \end{cases}
    \end{align*}
    As seen in \refsec{galois-connection}, \emph{soundness} is the foundation of abstract interpretation. An abstract element $\defabstractvalue$ is a sound abstraction of the set of environments $\defsetofenvs$ when the concretization of $\defabstractvalue$ contains all the environments in $\defsetofenvs$. Intuitively, the abstract element carries all the information of the concrete states it abstracts.
    \begin{definition}[Sound Abstraction]
      Given a concrete domain $\tuple{X}{\sqsubseteq_X}$ and an abstract domain $\tuple{X^\natural}{\sqsubseteq_{X^\natural}}$, then $x\in X$ is a \emph{sound abstraction} of $x^\natural\in X^\natural$, if and only if:
    \begin{align*}
      x \sqsubseteq_X \abstractdomainconcretization(x^\natural)
    \end{align*}
    \end{definition}
    For instance, let the program variables be $\defvariable, \texttt{y} \in \variables$, the concrete domain be $\tuple{\env}{\subseteq}$, and the abstract domain be $\tuple{\intervalabstractdomaintype}{\intervalabstractdomainsubseteq}$.
    Then, the interval $\defabstractvalue = \tuple{\defvariable \mapsto \interval{1}{2}}{\texttt{y} \mapsto \interval{0}{3}}$ is a sound abstraction of the set of environments $\{\tuple{\defvariable\mapsto 1}{\texttt{y}\mapsto 2}, \tuple{\defvariable\mapsto 1}{\texttt{y}\mapsto 3}\}$ as the concretization of the interval contains both environments. Instead, $\defabstractvalue$ is not a sound abstraction for the environment $\tuple{\defvariable\mapsto 1}{\texttt{y}\mapsto 4}$ as the value for the variable \texttt{y} is not in the interval $[0, 3]$.

    The notion of soundness extend to operators as well.
    \begin{definition}[Sound Operator]
      Given a concrete domain $\tuple{X}{\sqsubseteq_X}$ and an abstract domain $\tuple{X^\natural}{\sqsubseteq_{X^\natural}}$, then an abstract operator $f^\natural\in X^\natural \to X^\natural$ is a \emph{sound abstraction} of a concrete operator $f\in X \to X$, if and only if:
    \begin{align*}
      \forall x^\natural \in X^\natural.\spacer f(\abstractdomainconcretization(x^\natural)) \sqsubseteq_X \abstractdomainconcretization(f^\natural(x^\natural))
    \end{align*}
    \end{definition}
    \item[Abstraction Function]
    Fortunately, the integer\sidenote{For instance, the rational intervals abstract domain does not enjoy a Galois connection when the underlying concrete domain are real numbers, as the concrete interval $\interval{0}{\sqrt{2}}$ does not have a best approximation in the rational numbers.} interval domain enjoys a Galois connection with the following abstraction function $\intervalabstractdomainabstraction\in\setof\env\to\intervalabstractdomaintype$:
    \begin{align*}
      \intervalabstractdomainabstraction(\defsetofenvs) \DefeQ \begin{cases}
        \intervalabstractdomainbottom & \text{if } \defsetofenvs = \emptyset \\
        \lambda \defvariable.\interval{\min X}{\max X} & \text{otherwise} \\
        \quad \text{where } X = \setdef{\defenv(\defvariable)}{\defenv\in\defsetofenvs}
      \end{cases}
    \end{align*}
    It holds that:
  \begin{align*}
    \tuple{\setof{\env}}{\subseteq} \galois{\intervalabstractdomainabstraction}{\intervalabstractdomainconcretization}\tuple{\intervalabstractdomaintype}{\intervalabstractdomainsubseteq}
  \end{align*}
  Galois connections are useful because they give a way to express the most precise abstraction of concrete values.
  \begin{remark}
    Let $\tuple{X}{\sqsubseteq_X} \galois{\abstraction}{\concretization}\tuple{X^\natural}{\sqsubseteq_{X^
    natural}}$ be a Galois connection. Then, for any $x \in X$, $\abstraction(x)$ is the most precise abstraction of $x$ in $X^\natural$, \ie, the $\sqsubseteq_{X^\natural}$-smallest sound abstraction of $x$.
  \end{remark}
  This best abstraction also extends to operators.
  \begin{definition}[Best Operator Abstraction]\labdef{best-operator-abstraction}
    Let $\tuple{X}{\sqsubseteq_X} \galois{\abstraction}{\concretization}\tuple{X^\natural}{\sqsubseteq_{X^\natural}}$ be a Galois connection, and let $f\in X\to X$ be a concrete operator. Then, the best abstraction of $f$ is $\abstraction \circ f \circ \concretization$.
  \end{definition}
  Interestingly, \refdef{best-operator-abstraction} above provides a constructive way to define the best abstraction of concrete operators, without requiring a priori definitions and soundness proofs.
  For instance, the successor operator on environments of integer variables:
  \begin{align*}
    \textsc{Succ} &\IN \setof\env \to \setof\env \\
    \textsc{Succ}(\defsetofenvs) &\DefeQ \setdef{\updatemem{\defenv}{\defvariable}{\defenv(\defvariable) + 1}}{\defvariable\in\variables \land \defenv\in\defsetofenvs}
  \end{align*}
  enjoys the following best abstraction:
  \begin{align*}
    \texttt{Succ}^\natural &\IN \intervalabstractdomaintype \to \intervalabstractdomaintype \\
    \texttt{Succ}^\natural(\defabstractvalue) &\DefeQ \intervalabstractdomainabstraction(\textsc{Succ}(\intervalabstractdomainconcretization(\defabstractvalue))) \\
    &\spacearound{=} \begin{cases}
      \intervalabstractdomainabstraction(\textsc{Succ}(\emptyset)) &\text{if $\defabstractvalue = \intervalabstractdomainbottom$} \\
      \intervalabstractdomainabstraction\left(\setdef@{\updatemem{\defenv}{\defvariable}{\defenv(\defvariable) + 1}}{\defvariable\in\variables \land \defenv\in\intervalabstractdomainconcretization(\defabstractvalue)}\right) &\text{otherwise}
    \end{cases} \\
    &\spacearound{=} \begin{cases}
      \intervalabstractdomainbottom & \text{if } \defabstractvalue = \intervalabstractdomainbottom \\
      \lambda \defvariable.\interval{\min_{{l\in\defabstractvalue(\defvariable)}} l + 1}{\max_{u\in\defabstractvalue(\defvariable)} {u + 1}} & \text{otherwise}
    \end{cases} \\
    &\spacearound{=} \begin{cases}
      \intervalabstractdomainbottom & \text{if } \defabstractvalue = \intervalabstractdomainbottom \\
      \lambda \defvariable.\interval{l + 1}{u + 1} & \text{where } \interval{l}{u} = \defabstractvalue(\defvariable)
    \end{cases}
 \end{align*}
  Unfortunately, often the Galois connection is not available, thus we consider the most general case and do not require a Galois connection for the abstract domain.
  \item[Bottom and Top Elements]
  The bottom element $\intervalabstractdomainbottom\in\intervalabstractdomaintype$ represents the empty interval for all the variables, and it is concretized to the empty set of environments:
  \begin{align*}
    \intervalabstractdomainconcretization(\intervalabstractdomainbottom) = \emptyset
  \end{align*}
  The top element $\intervalabstractdomaintop\in\intervalabstractdomaintype$ represents the interval $[-\infty, +\infty]$ for all the variables, and it is concretized to the set of all the environments:
  \begin{align*}
    \intervalabstractdomainconcretization(\intervalabstractdomaintop) = \env
  \end{align*}
  \item[Join and Meet Operators]
  We derive the best abstraction for the join $\intervalabstractdomainjoin$ and meet $\intervalabstractdomainmeet$ operators:
  \begin{align*}
    \intervalabstractdomainbottom \intervalabstractdomainjoin \defabstractvalue &\DefeQ \defabstractvalue \\
    \defabstractvalue \intervalabstractdomainjoin \intervalabstractdomainbottom &\DefeQ \defabstractvalue \\
    \defabstractvalue_1 \intervalabstractdomainjoin \defabstractvalue_2 &\DefeQ \lambda \defvariable.\intervalabstractdomainabstraction(\intervalabstractdomainconcretization(\defabstractvalue_1(\defvariable)) \setjoin \intervalabstractdomainconcretization(\defabstractvalue_2(\defvariable))) \\
    &\spacearound{=} \lambda \defvariable.\intervalabstractdomainabstraction\left(\setdef*{x\in\Z}{\interval{l}{u} = \defabstractvalue_1(\defvariable) \land \interval{l'}{u'} = \defabstractvalue_2(\defvariable) \\ {} \land l \le x \le u \lor l' \le x \le u'}\right) \\
    &\spacearound{=} \lambda \defvariable.\interval{\min(l, l')}{\max(u, u')} \tag*{where $\interval{l}{u} = \defabstractvalue_1(\defvariable) \land \interval{l'}{u'} = \defabstractvalue_2(\defvariable)$}
  \end{align*}
  \begin{align*}
    \intervalabstractdomainbottom \intervalabstractdomainmeet \defabstractvalue &\DefeQ \intervalabstractdomainbottom \\
    \defabstractvalue \intervalabstractdomainmeet \intervalabstractdomainbottom &\DefeQ \intervalabstractdomainbottom \\
    \defabstractvalue_1 \intervalabstractdomainmeet \defabstractvalue_2 &\DefeQ \lambda \defvariable.\intervalabstractdomainabstraction(\intervalabstractdomainconcretization(\defabstractvalue_1(\defvariable)) \setmeet \intervalabstractdomainconcretization(\defabstractvalue_2(\defvariable))) \\
    &\spacearound{=} \lambda \defvariable.\intervalabstractdomainabstraction\left(\setdef*{x\in\Z}{\interval{l}{u} = \defabstractvalue_1(\defvariable) \land \interval{l'}{u'} = \defabstractvalue_2(\defvariable) \\ {} \land l \le x \le u \land l' \le x \le u'}\right) \\
    &\spacearound{=} \lambda \defvariable.\begin{cases}
      \interval{\max(l, l')}{\min(u, u')} \\
      \hspace{85px} \text{if } \max(l, l') \le \min(u, u') \\
      \intervalbottom \hspace{138px} \text{otherwise}
    \end{cases}
  \end{align*}
  The join operator computes the interval that contains all the values of the two input intervals, while the meet operator computes the interval that contains only the values that are in both input intervals.
  These are sound operators as the concretization of the result is a sound abstraction of the set of environments that are the join or meet of the concretization of the input abstract elements.
  \begin{definition}[Soundness of Join and Meet Operators]\labdef{soundness-join-meet}
    Given two abstract elements $\defabstractvalue_1, \defabstractvalue_2 \in \abstractdomain$, the join $\abstractdomainjoin \in \pair\abstractdomain\abstractdomain\to\abstractdomain$ and meet $\abstractdomainmeet\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ operators are sound whenever it holds that:
  \begin{align*}
    \concretization(\defabstractvalue_1) \setjoin \concretization(\defabstractvalue_2) &\subseteq \concretization(\defabstractvalue_1 \abstractdomainjoin \defabstractvalue_2) \\
    \concretization(\defabstractvalue_1) \setmeet \concretization(\defabstractvalue_2) &\subseteq \concretization(\defabstractvalue_1 \abstractdomainmeet \defabstractvalue_2)
  \end{align*}
  \end{definition}
  Note that, \refdef{soundness-join-meet} is always satisfied for best abstractions operators, \cf{} \refdef*{best-operator-abstraction}.
  \item[Forward and Backward Assignments]
  The abstract semantics of an assignment statement $\assignstmt$ for the interval abstract domain is defined as:
  \marginnote{To update the value of a variable in the interval abstract domain we use:
  \begin{align*}
  &\updatemem{\defabstractvalue}{\defvariable}{\interval{l}{u}} \DefeQ \\
  &\qquad\lambda \defvariable'.\begin{cases}
    \interval{l}{u} & \text{if } \defvariable' = \defvariable \\
    \defabstractvalue(\defvariable') & \text{otherwise}
  \end{cases}
\end{align*}}
  \begin{align*}
    &\intervalabstractdomainassign \semanticsof{\assignstmt}\intervalabstractdomainbottom \DefeQ \intervalabstractdomainbottom \\
    &\intervalabstractdomainassign \semanticsof{\assignstmt}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\intervalaexp \semanticsof{\defaexp}} \\
  \end{align*}
  where arithmetic expressions are evaluated by $\intervalaexp\in{(\intervalabstractdomaintype \setminus \intervalabstractdomainbottom)}\to\intervaltype$ as follows:
  \marginnote{
    \begin{align*}
      \defaexp \grammardef \defvalue \\
        \linesep \defvariable \\
        \linesep \defaexp + \defaexp \\
        \linesep \defaexp - \defaexp \\
        \linesep \randval(l, u) \tag{$l\in\Zinf \land l < u$} \\
      % \defbexp \grammardef \defaexp \le \defvalue \\
      %   \linesep \defaexp = \defvalue \\
      %   \linesep \defbexp \land \defbexp \\
      %   \linesep \lnot \defbexp \\
      % \defstmt \grammardef \lskipstmt\\
      %   \linesep \lassignstmt\\
      %   \linesep \lifstmt \\
      %   \linesep \lwhilestmt \\
      %   \linesep \lcompstmt \\
      % \defprogram \grammardef \lprogstmt \tag{$\bigloc \in \locs$}
    \end{align*}
  }
  \begin{align*}
    &\intervalaexp \semanticsof{\defvalue}\defabstractvalue \DefeQ \interval{\defvalue}{\defvalue} \\
    &\intervalaexp \semanticsof{\defvariable}\defabstractvalue \DefeQ \defabstractvalue(\defvariable) \\
    % \intervalaexp \semanticsof{\intervalbottom \oplus^{\intervalabstractdomaintype} \defabstractvalue}&\defabstractvalue \DefeQ \intervalbottom \\
    % \intervalaexp \semanticsof{\defabstractvalue \oplus^{\intervalabstractdomaintype} \intervalbottom}&\defabstractvalue \DefeQ \intervalbottom \\
    % \intervalaexp \semanticsof{\interval{l}{u} \oplus^{\intervalabstractdomaintype} \interval{l'}{u'}}&\defabstractvalue \DefeQ
    % \interval{l \oplus l'}{u \oplus u'} \tag*{for $\oplus\in\{+, -\}$} \\
    &\intervalaexp \semanticsof{\defaexp + \defaexp'} \defabstractvalue \DefeQ \interval{l + l'}{u + u'} \tag*{where $\interval{l}{u} = \intervalaexp\semanticsof{\defaexp}\defabstractvalue$ and $ \interval{l'}{u'} = \intervalaexp\semanticsof{\defaexp'}\defabstractvalue$} \\
    &\intervalaexp \semanticsof{\defaexp - \defaexp'} \defabstractvalue \DefeQ \interval{l - u'}{u - l'} \tag*{where $\interval{l}{u} = \intervalaexp\semanticsof{\defaexp}\defabstractvalue$ and $ \interval{l'}{u'} = \intervalaexp\semanticsof{\defaexp'}\defabstractvalue$} \\
    &\intervalaexp \semanticsof{\randval(l, u)}\defabstractvalue \DefeQ \interval{l}{u}
    % \\[1em]
    % \intervalbexp \semanticsof{\intervalbottom \le \defvalue} &\DefifF \false \\
    % \intervalbexp\semanticsof{\interval{l}{u} \le \defvalue} &\DefifF l \le \defvalue \\
    % \intervalbexp\semanticsof{\intervalbottom = \defvalue} &\DefifF \false\\
    % \intervalbexp\semanticsof{\interval{l}{u} = \defvalue} &\DefifF l \le \defvalue \le u\\
    % \intervalbexp\semanticsof{\interval
  \end{align*}
  where $\defvalue\in\Z$ is an integer constant.
  In case of the backward evaluation of an assignment statement, we call substitution the operation of replacing the value of a variable with the value of an arithmetic expression that yields before the execution of the assignment. The substitution needs to be sound, \ie, the interval of an assigned variable should overapproximate the precondition for the assignment to be executed resulting in the given postcondition.
  For instance, the evaluation of a constant assignment $\assignstmt[\defvariable][\defvalue]$ is $\intervaltop$ as any possible value could have been assigned to the variable $\defvariable$ before the execution of the assignment, similarly for the assignment of a non-deterministic choice, or another variable different from the assigned one. A similar reasoning applies to the rest of the cases, for the evaluation of complex expressions we need to \emph{reverse} the assignment \sidecite{Aman2020}, \ie, we need to find the possible values of the variable before the assignment.
  Formally, a possible semantics for the substitution is defined as:
  \begin{align*}
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defaexp}\intervalabstractdomainbottom \DefeQ \intervalabstractdomainbottom \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvalue}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\intervaltop} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\randval(l, u)}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\intervaltop} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvariable'}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\intervaltop} \\ \tag*{where $\defvariable \neq \defvariable'$}\\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvariable}\defabstractvalue \DefeQ \defabstractvalue \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvariable + \defvalue}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\interval{l-\defvalue}{u-\defvalue}} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvalue + \defvariable}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\interval{l-\defvalue}{u-\defvalue}} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvariable - \defvalue}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\interval{l+\defvalue}{u+\defvalue}} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defvalue - \defvariable}\defabstractvalue \DefeQ \updatemem{\defabstractvalue}{\defvariable}{\interval{\defvalue-l}{\defvalue-u}} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$} \\
    &\intervalabstractdomainsubstitute \substitutionof{\defvariable}{\defaexp} \defabstractvalue \DefeQ \intervalabstractdomaintop
  \end{align*}
  Note that, we could even further add semantics rules to improve the precision of the domain, for instance, by considering the case where the arithmetic expression is more complex.

  The soundness condition of an assignment abstractly interpreted either forward or backward is standard, it is based on the overapproximation of pre/postconditions.
  \marginnote{
    \begin{align*}
      &\forwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ \\
      &\quad
       \setdef@{\tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}}{\tracetuple{\bigloc}{\defenv}\in\defsetofstates \land {} \\ \defvalue \in \aexpsemantics\defenv}
    \end{align*}
  }
  \begin{definition}[Soundness of Assignments]\labdef{soundness-assignment}
    Given an assignment statement $\assignstmt$, the forward $\abstractdomainassign \semanticsof{\assignstmt}\in \abstractdomain \to \abstractdomain$ operator is a \emph{sound abstraction} of the forward evaluation of the assignment whenever it holds that:
  \begin{align*}
    \forall \defabstractvalue\in\abstractdomain.\spacer \forwardreachabilitytracesemanticsnoparam\semanticsof{\assignstmt}( \intervalabstractdomainconcretization(\defabstractvalue)) \SubseteQ \intervalabstractdomainconcretization(\abstractdomainassign \semanticsof{\assignstmt}\defabstractvalue)
  \end{align*}
\end{definition}
\marginnote{
  \begin{align*}
    &\backwardreachabilitytracesemanticsnoparam \semanticsof{\plassignstmt}\defsetofstates \DefeQ \\
    &\quad\setdef@{\tracetuple{\bigloc}{\defenv}}{\defenv\in\env \land \defvalue \in \aexpsemantics\defenv \land {} \\ \tracetuple{\finalloc[\plassignstmt]}{\updatemem{\defenv}{\defvariable}{\defvalue}}\in\defsetofstates}
  \end{align*}
}
\begin{definition}[Soundness of Substitution]\labdef{soundness-substitution}
  Given an assignment statement $\assignstmt$, the backward $\abstractdomainsubstitute{\defvariable}{\defaexp} \in \abstractdomain \to \abstractdomain$ operator is a \emph{sound abstraction} of the backward evaluation of the assignment whenever it holds that:
\begin{align*}
  \forall \defabstractvalue\in\abstractdomain.\spacer \backwardreachabilitytracesemanticsnoparam\semanticsof{\assignstmt}( \intervalabstractdomainconcretization(\defabstractvalue)) \SubseteQ \intervalabstractdomainconcretization(\abstractdomainsubstitute{\defvariable}{\defaexp} \defabstractvalue)
\end{align*}
\end{definition}

  \item[Boolean Expressions]
  Boolean expressions do not need special handle for the forward and backward cases separately, as deciding whether a boolean expression holds or not is independent of the direction of the analysis.
  Therefore, the evaluation of boolean expressions in the interval abstract domain is defined as:
  \marginnote{
    \begin{align*}
      % \defaexp \grammardef \defvalue \\
      %   \linesep \defvariable \\
      %   \linesep \defaexp + \defaexp \\
      %   \linesep \defaexp - \defaexp \\
      %   \linesep \randval(l, u) \tag{$l\in\Zinf \land l < u$} \\
      \defbexp \grammardef \defaexp \le \defvalue \\
        \linesep \defaexp = \defvalue \\
        \linesep \defbexp \land \defbexp \\
        \linesep \lnot \defbexp \\
      % \defstmt \grammardef \lskipstmt\\
      %   \linesep \lassignstmt\\
      %   \linesep \lifstmt \\
      %   \linesep \lwhilestmt \\
      %   \linesep \lcompstmt \\
      % \defprogram \grammardef \lprogstmt \tag{$\bigloc \in \locs$}
    \end{align*}
  }
  \begin{align*}
    \intervalabstractdomainfilter \semanticsof{\defbexp} \intervalabstractdomainbottom &\DefeQ \intervalabstractdomainbottom \\
    \intervalabstractdomainfilter \semanticsof{\defaexp \le \defvalue} \defabstractvalue &\DefeQ \begin{cases}
      \intervalabstractdomainbottom & \text{if } l > \defvalue \\
      \interval{l}{\min(u, \defvalue)} & \text{otherwise}
    \end{cases} \tag*{where $\interval{l}{u} = \intervalaexp \semanticsof{\defaexp} \defabstractvalue$} \\
    \intervalabstractdomainfilter \semanticsof{\defaexp = \defvalue} \defabstractvalue &\DefeQ \begin{cases}
      \intervalabstractdomainbottom & \text{if } l > \defvalue \lor u < \defvalue \\
      \interval{\defvalue}{\defvalue} & \text{otherwise}
    \end{cases} \tag*{where $\interval{l}{u} = \intervalaexp \semanticsof{\defaexp} \defabstractvalue$} \\
    \intervalabstractdomainfilter \semanticsof{\defbexp \land \defbexp'} \defabstractvalue &\DefeQ \intervalabstractdomainfilter \semanticsof{\defbexp} \defabstractvalue \intervalabstractdomainmeet \intervalabstractdomainfilter \semanticsof{\defbexp'} \defabstractvalue
  \end{align*}
  We can always solve the negation of boolean expression via De Morgan's laws.
  \marginnote{
    De Morgan's laws:
    \begin{align*}
      \lnot(\defbexp \land \defbexp') &\spacearound{=} \lnot\defbexp \lor \lnot\defbexp' \\
      \lnot(\defbexp \lor \defbexp') &\spacearound{=} \lnot\defbexp \land \lnot\defbexp'
    \end{align*}
  }
  Therefore, we do not handle them explicitly, instead we first simplify the condition to the base cases, then we add specific rules for the negation of the simple cases. The following are the additional rules:
  \begin{align*}
    &\intervalabstractdomainfilter \semanticsof{\neg(\defaexp \le \defvalue)} \defabstractvalue \DefeQ \\
    &\quad\intervalabstractdomainfilter \semanticsof{\defaexp > \defvalue} \defabstractvalue \spacearound{=}\begin{cases}
      \intervalabstractdomainbottom & \text{if } u < \defvalue \\
      \interval{\max(l, \defvalue)}{u} & \text{otherwise}
    \end{cases} \tag*{where $\interval{l}{u} = \intervalaexp \semanticsof{\defaexp} \defabstractvalue$} \\
    &\intervalabstractdomainfilter \semanticsof{\neg(\defaexp = \defvalue)} \defabstractvalue \DefeQ \\
    &\quad\intervalabstractdomainfilter \semanticsof{\defaexp \neq \defvalue} \defabstractvalue \spacearound{=} \defabstractvalue \\
    &\intervalabstractdomainfilter \semanticsof{\defbexp \lor \defbexp'} \defabstractvalue \DefeQ \intervalabstractdomainfilter \semanticsof{\defbexp} \defabstractvalue \intervalabstractdomainjoin \intervalabstractdomainfilter \semanticsof{\defbexp'} \defabstractvalue
  \end{align*}
  The soundness of the boolean expressions is standard, it is defined as the overapproximation of the set of environments that satisfy the boolean expression.
  \begin{definition}[Soundness of Boolean Expressions]\labdef{soundness-boolean}
    Given a boolean expression $\defbexp$, the filter $\abstractdomainfilter \semanticsof{\defbexp}\in\abstractdomain\to\abstractdomain$ operator is a \emph{sound abstraction} of the evaluation of the boolean expression whenever it holds that:
  \begin{align*}
    \forall \defabstractvalue\in\abstractdomain.\spacer
    \bexpsemantics
    (\abstractdomainconcretization(\defabstractvalue))
    \SubseteQ
    \abstractdomainconcretization(\abstractdomainfilter \semanticsof{\defbexp}\defabstractvalue)
  \end{align*}
\end{definition}
  \item[Widening]
  When dealing with loops, the widening operator ensures the termination of the fixpoint computation by over-approximating the result of the iteration.
  This step is recommended even for concrete domains that does not have infinite ascending chains, as the convergence of the fixpoint computation can be slow.
  The main idea is that widening enforce fast termination by pushing unstable sequences of iterations to infinite:
  \begin{align*}
    % \intervalabstractdomainbottom \intervalabstractdomainwidening \defabstractvalue &\DefeQ \defabstractvalue \\
    % \defabstractvalue \intervalabstractdomainwidening \intervalabstractdomainbottom &\DefeQ \defabstractvalue \\
    \defabstractvalue \intervalabstractdomainwidening \defotherabstractvalue &\DefeQ \lambda \defvariable.\begin{cases}
      \interval{l}{u} & \text{if } \defabstractvalue(\defvariable) \intervalsubseteq \defotherabstractvalue(\defvariable) \\
      \interval{-\infty}{u} & \text{if } l' \le l \\
      \interval{l}{+\infty} & \text{if } u \le u' \\
      \intervaltop & \text{otherwise}
    \end{cases} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$ and $\interval{l'}{u'} = \defotherabstractvalue(\defvariable)$}
  \end{align*}
  It holds that the widening domain computes an upper bound of the two input intervals:
  \begin{align*}
    \forall \defabstractvalue, \defotherabstractvalue \in \intervalabstractdomaintype.\spacer \defabstractvalue \intervalabstractdomainsubseteq \defabstractvalue \intervalabstractdomainwidening \defotherabstractvalue \land \defotherabstractvalue \intervalabstractdomainsubseteq \defabstractvalue \intervalabstractdomainwidening \defotherabstractvalue
  \end{align*}
  and it enforces termination: for any infinite sequence of abstract elements $\defabstractvalue_1, \defabstractvalue_2, \dots \in \intervalabstractdomaintype$, the sequence $\defotherabstractvalue_1, \defotherabstractvalue_2, \dots$ computed as $\defotherabstractvalue_1 = \defabstractvalue_1$ and $\defotherabstractvalue_{i+1} = \defotherabstractvalue_i \intervalabstractdomainwidening \defabstractvalue_{i+1}$ stabilizes after a finite number of iterations, \ie, there exists an $n \in \Npos$ such that $\defotherabstractvalue_n = \defotherabstractvalue_{n+1}$.
  \begin{definition}[Widening]\labdef{widening}
    Let $\tuple{\abstractdomain}{\abstractdomainsubseteq}$ be an abstract domain.
    A binary operator $\abstractdomainwidening\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ is a \emph{widening} operator whenever it holds that:
    \begin{itemize}
      \item $\abstractdomainwidening$ computes an upper bound:
      \[\forall \defabstractvalue, \defotherabstractvalue \in \abstractdomain.\spacer \defabstractvalue \abstractdomainsubseteq \defabstractvalue \abstractdomainwidening \defotherabstractvalue \land \defotherabstractvalue \abstractdomainsubseteq \defabstractvalue \abstractdomainwidening \defotherabstractvalue\]
      \item $\abstractdomainwidening$ enforces termination: for any infinite sequence of abstract elements $\defabstractvalue_1, \defabstractvalue_2, \dots \in \abstractdomain$, the sequence $\defotherabstractvalue_1, \defotherabstractvalue_2, \dots$ computed as $\defotherabstractvalue_1 = \defabstractvalue_1$ and $\defotherabstractvalue_{i+1} = \defotherabstractvalue_i \abstractdomainwidening \defabstractvalue_{i+1}$ stabilizes after a finite number of iterations, \ie, there exists an $n \in \Npos$ such that $\defotherabstractvalue_n = \defotherabstractvalue_{n+1}$.
    \end{itemize}
  \end{definition}
  \vspace{5pt}
  It holds that widenings can indeed be used to approximate least fixpoints in the abstract.
  \begin{theorem}
    Let $\tuple{X}{\subseteq}$ be the concrete and $\tuple{\abstractdomain}{\abstractdomainsubseteq}$ be the abstract domain.
    The function $f \in X \to X$ is a monotonic operator and $g \in \abstractdomain \to \abstractdomain$ is a sound abstraction of $f$, the following iteration:
    \begin{align*}
      x^0 &\DefeQ \abstractdomainbottom \\
      x^{i+1} &\DefeQ x^i \abstractdomainwidening g(x^i)
    \end{align*}
    converges in finite time, and its limit $x$ is a sound abstractino of the least fixpoint $\lfp f$, \ie, $\lfp f \subseteq \abstractdomainconcretization(x)$.
  \end{theorem}
\item[Narrowing]
  The narrowing operator is the dual of the widening operator and helps to refine the over-approximation of the fixpoint computation after the application of the widening.
  The narrowing operator for the interval abstract domain is defined as:
  \begin{align*}
    \defabstractvalue \intervalabstractdomainnarrowing \defotherabstractvalue &\DefeQ \lambda \defvariable.\begin{cases}
      \interval{l'}{u'} & \text{if } l = -\infty \land u = +\infty \\
      \interval{l'}{u} & \text{if } l = -\infty \land u' \neq +\infty \\
      \interval{l}{u'} & \text{if } l' \neq -\infty \land u = +\infty \\
      \interval{l}{u} & \text{otherwise}
    \end{cases} \tag*{where $\interval{l}{u} = \defabstractvalue(\defvariable)$ and $\interval{l'}{u'} = \defotherabstractvalue(\defvariable)$}
  \end{align*}
  The following states the conditions for the narrowing operator:
  \begin{definition}[Narrowing]\labdef{narrowing}
    Let $\tuple{\abstractdomain}{\abstractdomainsubseteq}$ be an abstract domain.
    A binary operator $\abstractdomainnarrowing\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ is a \emph{narrowing} operator whenever it holds that:
    \begin{itemize}
      \item $\abstractdomainnarrowing$ computes a lower bound:
      \[\forall \defabstractvalue, \defotherabstractvalue \in \abstractdomain.\spacer \defabstractvalue \abstractdomainnarrowing \defotherabstractvalue \abstractdomainsubseteq \defabstractvalue \land \defabstractvalue \abstractdomainnarrowing \defotherabstractvalue \abstractdomainsubseteq\defotherabstractvalue\]
      \item $\abstractdomainnarrowing$ enforces termination: for any infinite sequence of abstract elements $\defabstractvalue_1, \defabstractvalue_2, \dots \in \abstractdomain$, the sequence $\defotherabstractvalue_1, \defotherabstractvalue_2, \dots$ computed as $\defotherabstractvalue_1 = \defabstractvalue_1$ and $\defotherabstractvalue_{i+1} = \defotherabstractvalue_i \abstractdomainnarrowing \defabstractvalue_{i+1}$ stabilizes after a finite number of iterations, \ie, there exists an $n \in \Npos$ such that $\defotherabstractvalue_n = \defotherabstractvalue_{n+1}$.
    \end{itemize}
  \end{definition}
  The narrowing ensures convergence to a better approximation of the fixpoint than only by using the widening. Generally, the total number of abstract iterations is much smaller than the number of concrete iterations.
  \end{description}

Above we presented all the characteristics of a numerical (non-relational) abstract domain. Formally, we define an abstract domain as follows:

\begin{definition}[Numerical Abstract Domain]\labdef{abstract-domain}
  A \emph{numerical abstract domain} $\tuple{\abstractdomain}{\abstractdomainsubseteq}$ is characterized by:
  \begin{itemize}
    \item elements in the abstract domain $\abstractdomain$ are computable-representable;
    \item a partial order $\abstractdomainsubseteq$ with an effective algorithm to check the ordering;
    \item a concretization function $\abstractdomainconcretization\in\abstractdomain\to\setof{\env}$, or when possible a Galois connection\sidenote{See \refremark{without-galois} for the case where a Galois connection does not exist.}
    $\tuple{\setof\env}{\subseteq}\galois{\abstractdomainabstraction}{\abstractdomainconcretization}\tuple{\abstractdomain}{\abstractdomainsubseteq}$;
    \item a bottom element $\abstractdomainbottom\in\abstractdomain$ such that $\abstractdomainconcretization(\abstractdomainbottom) = \emptyset$;
    \item a top element $\abstractdomaintop\in\abstractdomain$ such that $\abstractdomainconcretization(\abstractdomaintop) = \env$;
    \item a sound join $\abstractdomainjoin\in\abstractdomain\times\abstractdomain\to\abstractdomain$ and meet $\abstractdomainmeet\in\abstractdomain\times\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{soundness-join-meet};
    \item a sound forward assignment $\abstractdomainassign\semanticsof{\assignstmt}\in\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{soundness-assignment};
    \item a sound backward substitution $\abstractdomainsubstitute{\defvariable}{\defaexp}\in\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{soundness-substitution};
    \item a sound filter $\abstractdomainfilter\semanticsof{\defbexp}\in\to\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{soundness-boolean};
    \item a sound widening $\abstractdomainwidening\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{widening}; and
    \item a sound narrowing $\abstractdomainnarrowing\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ operator, \cf{} \refdef{narrowing}.
  \end{itemize}
\end{definition}

\begin{remark}[Relational Abstract Domains]
  It holds that the integer interval abstract domain is a numerical abstract domain.
  Specifically, as it relates each variable singularly to an interval value, we say that such domain is a \emph{non-relational} abstract domain.
  On the other hand, a \emph{relational} abstract domain yields constraints that relate multiple variables together.
\end{remark}


In the following, we report some of the most common numerical abstract domains used in the literature:

\begin{description}
  \item[Signs \cite{Cousot1977}] \phantomcite{Cousot1977} The sign domain infers constraints about the sign of the variables: positive, negative, zero, anything, or nothing. The domain is--potentially--the fastest available as simply associate a sign to each variable. Unfortunately, rarely useful in practice.
  \item[Powerset \cite{Min_e2017}] \phantomcite{Min_e2017} The powerset domain associate each variable with a finite set of possible values. This domain is quite precise but becomes quickly intractable as the number as the number of possible values grows.
  \item[Excluded Powerset \cite{Monat2024}] \phantomcite{Monat2024} The excluded powerset domain is a variant of the powerset domain that keeps track of the values that a variable cannot definitely take. This domain is able to compute disjunctions precisely but suffers from even higher scalability issues than the precedent.
  \item[Intervals \cite{Cousot1976,Hickey2001}] \phantomcite{Cousot1976,Hickey2001} The interval domain has been presented throughly above. It offers a good trade-off between precision and scalability.
  \item[Congruences \cite{Granger1991}] \phantomcite{Granger1991} The congruence domain infers constraints about the remainders of the variables when divided by a constant. This domain is particularly useful when dealing with modular arithmetic and pointer offset.
\end{description}
These domains above are non-relational as they associate an abstract element to each variable singularly. Next, we present some of the most common relational abstract domains:
\begin{description}
  \item[Linear Equalities \cite{Karr1976}] \phantomcite{Karr1976} The linear equalities domain infers constraints about the linear relationships between variables.
  \item[Polyhedra \cite{Cousot1978}] \phantomcite{Cousot1978} The polyhedra domain infers constraints about the linear relationships between variables and the convex combinations of the variables. Thanks to its expressiveness, the polyhedra domain is usually the most precise domain available for numerical analyses.
  \item[Octagons \cite{Min_e2006a}] \phantomcite{Min_e2006a} The octagons domain infers constraints about the relationships between variables of the form $x - y \le c$. Potentially, one of the best trade-offs between precision and scalability among the relational domains.
\end{description}

Different abstract domains represent complementary information about the program variables. Therefore, it is common to combine multiple abstract domains to leverage the strengths of each domain. The combination of abstract domains is known as the \emph{reduced product} domain \sidecite{Cousot1979a}.\sidenote{ Specifically, this domain is called the \emph{partially} reduced product, as the (fully) reduced product is only applicable when the underlying abstract domains feature Galois connections.} The reduced product domain is defined as the Cartesian product of the abstract domains, with the ordering defined as the pointwise ordering of the abstract elements. Each abstract operator is defined to share information from the individual domains and to refine their abstract elements.
The reduced product domain is thus sound by construction and is, at least, always as precise as any of the individual domains. The reduced product domain is particularly useful when the individual domains are complementary, \eg{} when one domain is good at inferring linear relationships and another domain is good at inferring disjunctions.

Specifically, let $\productdomain$ be the reduced product of two abstract domains, a reduction operator $\productdomainreduce\in\productdomain\to\productdomain$ enables information sharing between the two domains.
Importantly, the reduction operator needs to not modify the concretized states of the two abstract domains, but it is permitted to refine each of the two abstract elements in their respective domains.

\begin{definition}[Soundness of the Reduction Operation]\labdef{soundness-reduction}
  The operator $\productdomainreduce\in\productdomain\to\productdomain$ is a \emph{sound reduction} operator between the two domains $\abstractdomain_1$ and $\abstractdomain_2$ whenever it holds that, for any $\tuple{\defabstractvalue_1}{\defabstractvalue_2}, \tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2} \in \productdomain$:
  \begin{align*}
    \tuple{\defabstractvalue_1}{\defabstractvalue_2} = \productdomainreduce(\tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2}) \ImplieS
    &\productdomainconcretization(\tuple{\defabstractvalue_1}{\defabstractvalue_2}) = \productdomainconcretization(\tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2}) \land {} \\
    &\abstractdomainconcretization_1(\defabstractvalue_1) \abstractdomainsubseteq_1 \abstractdomainconcretization_1(\defotherabstractvalue_1) \land {} \\
    &\abstractdomainconcretization_2(\defabstractvalue_2) \abstractdomainsubseteq_2 \abstractdomainconcretization_2(\defotherabstractvalue_2)
  \end{align*}
\end{definition}

The reduced product is defined as:

\begin{definition}[Reduced Product]\labdef{reduced-product}
Let $\tuple{\abstractdomain_1}{\abstractdomainsubseteq_1}$ and $\tuple{\abstractdomain_2}{\abstractdomainsubseteq_2}$ be two abstract domains, and $\productdomainreduce\in\productdomain\to\productdomain$ a sound reduction operator, \cf{} \refdef{soundness-reduction}.
The \emph{reduced product} domain $\productdomain$ is defined as:
\begin{itemize}
  \item $\productdomain = \abstractdomain_1 \times \abstractdomain_2$;
  \item for $\defabstractvalue_1, \defabstractvalue_2 \in \abstractdomain_1$ and $\defotherabstractvalue_1, \defotherabstractvalue_2\in\abstractdomain_2$, the partial order $\tuple{\defabstractvalue_1}{\defotherabstractvalue_1} \productdomainsubseteq \tuple{\defabstractvalue_2}{\defotherabstractvalue_2}$ holds if and only if $\defabstractvalue_1 \abstractdomainsubseteq_1 \defabstractvalue_2$ and $\defotherabstractvalue_1 \abstractdomainsubseteq_2 \defotherabstractvalue_2$;
  \item the concretization function $\productdomainconcretization(\tuple{\defabstractvalue}{\defotherabstractvalue}) \defeq \abstractdomainconcretization_1(\defabstractvalue) \setmeet \abstractdomainconcretization_2(\defotherabstractvalue)$;
  \item if $\abstractdomainabstraction_1$ and $\abstractdomainabstraction_2$ exist, we have an abstraction $\productdomainabstraction\in\pair\abstractdomain\abstractdomain\to\abstractdomain$ that forms a Galois connection $\tuple{\setof\env}{\subseteq}\galois{\productdomainabstraction}{\productdomainconcretization}\tuple{\productdomain}{\productdomainsubseteq}$. The abstraction is defined as follows:
  $ \productdomainabstraction(\defenv) \DefeQ \tuple{\abstractdomainabstraction_1(\defenv)}{\abstractdomainabstraction_2(\defenv)} $;
  \item the bottom element $\productdomainbottom \defeq \tuple{\abstractdomainbottom_1}{\abstractdomainbottom_2}$;
  \item the top element $\productdomaintop \defeq \tuple{\abstractdomaintop_1}{\abstractdomaintop_2}$;
  \item the sound join $\tuple{\defabstractvalue_1}{\defabstractvalue_2} \productdomainjoin \tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2} \defeq \tuple{\defabstractvalue_1 \abstractdomainjoin_1 \defotherabstractvalue_1}{\defabstractvalue_2 \abstractdomainjoin_2 \defotherabstractvalue_2}$;
  \item the sound meet $\tuple{\defabstractvalue_1}{\defabstractvalue_2} \productdomainmeet \tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2} \defeq \tuple{\defabstractvalue_1 \abstractdomainmeet_1 \defotherabstractvalue_1}{\defabstractvalue_2 \abstractdomainmeet_2 \defotherabstractvalue_2}$;
  \item the sound forward assignment:
  \begin{align*}
    &\productdomainassign\semanticsof{\assignstmt}\tuple{\defabstractvalue_1}{\defabstractvalue_2} \DefeQ \\
    &\quad \tuple{\abstractdomainassign\semanticsof{\assignstmt}\defabstractvalue_1}{\abstractdomainassign\semanticsof{\assignstmt}\defabstractvalue_2}
  \end{align*}
  \item the sound backward substitution:
  \begin{align*}
    &\productdomainsubsitute\substitutionof{\defvariable}{\defaexp}(\tuple{\defabstractvalue_1}{\defabstractvalue_2}) \DefeQ \\
    &\quad \tuple{\abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue_1}{\abstractdomainsubstitute{\defvariable}{\defaexp}\defabstractvalue_2}
  \end{align*}
  \item the sound filter:
  \begin{align*}
    &\productdomainfilter\semanticsof{\defbexp}(\tuple{\defabstractvalue_1}{\defabstractvalue_2}) \DefeQ \\
    &\quad \tuple{\abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue_1}{\abstractdomainfilter\semanticsof{\defbexp}\defabstractvalue_2}
  \end{align*}
  \item the widening $\tuple{\defabstractvalue_1}{\defabstractvalue_2} \productdomainwidening \tuple{\defotherabstractvalue_1}{\defotherabstractvalue_2} \DefeQ \tuple{\defabstractvalue_1 \abstractdomainwidening_1 \defotherabstractvalue_1}{\defabstractvalue_2 \abstractdomainwidening_2 \defotherabstractvalue_2}$.
\end{itemize}
\end{definition}

Note that, the reduced product defined above applies the reduction operator $\productdomainreduce$ after joins and meets but refrains from applying it after a widening. The reason is that the widening operator ensures termination on each individual domain, this is not any more guaranteed when applying the reduction operator between widening steps. The problem is that the reduction operator might refine the abstract elements in such a way that the widening operator does not terminate anymore. For instance, if the reduction would provide finite interval bounds, the widening operator of the interval abstract domain may push these bounds to infinity indefinitely, without ever reaching a fixpoint.

Next, we show how the (sound) operators of the numerical abstract domains can be used to define the abstract semantics of programs. We present both the forward and backward reachability state abstract semantics for a generic numerical abstract domain $\tuple{\abstractdomain}{\abstractdomainsubseteq}$, \cf{} \refdef{abstract-domain}.

\paragraph{Forward Reachability State Abstract Semantics}

The forward reachability state abstract semantics $\forwardsemantics\in\forwardtype$ is defined by induction on the structure of the program, as follows:

\begin{description}
  \marginnote{
    \begin{align*}
      &\forwardsemanticsnoparam \semanticsof{\pskipstmt}\defabstractvalue \DefeQ \defabstractvalue
    \end{align*}
  }
  \item[\normalfont ($\pskipstmt$)] The abstract semantics of a skip statement is the identity function on the abstract element.
  \marginnote{
    \begin{align*}
      &\forwardsemanticsnoparam \semanticsof{\passignstmt}\defabstractvalue \DefeQ \abstractdomainassign \semanticsof{\assignstmt}\defabstractvalue
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] The abstract semantics of an assignment statement is the abstract forward assignment.
  \marginnote{
    \begin{align*}
      &\forwardsemanticsnoparam \semanticsof{\pifstmt}\defabstractvalue \DefeQ \\
      &\quad \forwardsemanticsnoparam \semanticsof{\defstmt}(\abstractdomainfilter \semanticsof{\defbexp}\defabstractvalue) \spacearound{\abstractdomainjoin} {} \\
      &\quad\forwardsemanticsnoparam \semanticsof{\defstmt'}(\abstractdomainfilter \semanticsof{\neg\defbexp}\defabstractvalue)
    \end{align*}
  }
  \item[\normalfont ($\pifstmt$)] The abstract semantics of a conditional statement is the join of the abstract semantics applied to the two branches.
  \marginnote{
    \begin{align*}
      &\forwardsemanticsnoparam \semanticsof{\pwhilestmt}\defabstractvalue \DefeQ \\
      &\quad \abstractdomainfilter \semanticsof{\neg\defbexp} (\lim \abstractdomaintransformer) \\[5pt]
      &\quad \abstractdomaintransformer (\defotherabstractvalue) \DefeQ \\
      &\qquad\defabstractvalue \abstractdomainjoin \forwardsemanticsnoparam \semanticsof{\defstmt}(\abstractdomainfilter \semanticsof{\defbexp}\defotherabstractvalue)
    \end{align*}
  }
  \item[\normalfont ($\pwhilestmt$)] The while statement represents the most interesting construct. A na\"ive approach would be to compute an overapproximation of the fixpoint of the loop body, filtered by the loop condition. However, this approach is not guaranteed to terminate in finite time. Instead, thanks to the widening operator, we can compute the abstract iterates least fixpoint in the abstract domain by applying the widening operator to ensure convergence. The least fixpoint computation is then guaranteed to terminate, hopefully in a small number of abstract iterations.
  The abstract iterates are computed by the limit operator of the abstract transformer $\lim \abstractdomaintransformer$, it is defined as follows:
  \begin{align*}
    \lim \abstractdomaintransformer &\DefeQ x^k \text{ such that } k\in\Npos \text{ and } x^k \abstractdomainsubseteq \abstractdomaintransformer(x^k) \\
    \text{where } x^0 &\DefeQ \abstractdomainbottom \\
    x^{i+1} &\DefeQ x^i \spacearound{\abstractdomainwidening} \abstractdomaintransformer(x^i)
  \end{align*}
  \marginnote{
    \begin{align*}
      &\forwardsemanticsnoparam \semanticsof{\pcompstmt}\defabstractvalue \DefeQ \\
      &\quad\forwardsemanticsnoparam \semanticsof{\defstmt'}(\forwardsemanticsnoparam \semanticsof{\defstmt}\defabstractvalue)
    \end{align*}
  }
  \item[\normalfont ($\pcompstmt$)] The abstract semantics of a composition statement is the composition of the abstract semantics of the two statements, from $\defstmt$ to $\defstmt'$.
  \item[\normalfont ($\pprogstmt$)] The abstract semantics of a program is the abstract semantics of the entry statement starting from the abstract element representing all the states, \ie, the top element $\abstractdomaintop$.
    \begin{definition}[Forward Reachability State Abstract Semantics]
      The \emph{forward reachability state abstract semantics} $\forwardsemantics\in\forwardtype$ for a program $\defprogram$ is defined as:
      \begin{align*}
        \forwardsemantics \DefeQ \forwardsemanticsnoparam \semanticsof{\progstmt} \spacearound{=} \forwardsemanticsnoparam \semanticsof{\defstmt}\abstractdomaintop
      \end{align*}
    \end{definition}
\end{description}

The following result provides the soundness of $\forwardsemantics$ with respect to the concrete semantics $\forwardreachabilitytracesemantics$, \cf{} \refdef*{forward-reachability-state-semantics}.

\begin{theorem}
  Given a program $\defprogram$, the forward reachability state abstract semantics $\forwardsemantics$ is sound with respect to the forward reachability state semantics $\forwardreachabilitytracesemantics$ whenever it holds that:
  \begin{align*}
    \forwardreachabilitytracesemantics \subseteq \abstractdomainconcretization(\forwardsemantics)
  \end{align*}
\end{theorem}

\paragraph{Backward Co-Reachability State Abstract Semantics}

The \emph{backward} reachability state abstract semantics $\backwardsemantics\in\backwardtype$ is defined by induction on the structure of the program, as follows:

\begin{description}
  \marginnote{
    \begin{align*}
      &\backwardsemanticsnoparam \semanticsof{\pskipstmt}\defabstractvalue \DefeQ \defabstractvalue
    \end{align*}
  }
  \item[\normalfont ($\pskipstmt$)] The backward semantics of a skip statement is the identity function on the abstract element.
  \marginnote{
    \begin{align*}
      &\backwardsemanticsnoparam \semanticsof{\passignstmt}\defabstractvalue \DefeQ \abstractdomainsubstitute{\defvariable}{\defbexp}\defabstractvalue
    \end{align*}
  }
  \item[\normalfont ($\plassignstmt$)] The backward semantics of an assignment statement is the substitution of the value of an expression $\defaexp$ into the variable $\defvariable$.
  \marginnote{
    \begin{align*}
      &\backwardsemanticsnoparam \semanticsof{\pifstmt}\defabstractvalue \DefeQ \\
      &\quad \abstractdomainfilter \semanticsof{\defbexp}(\backwardsemanticsnoparam \semanticsof{\defstmt} \defabstractvalue) \spacearound{\abstractdomainjoin} \\
      &\quad \abstractdomainfilter \semanticsof{\neg\defbexp}(\backwardsemanticsnoparam \semanticsof{\defstmt'} \defabstractvalue)
    \end{align*}
  }
  \item[\normalfont ($\pifstmt$)] The backward semantics of a conditional statement is the backward semantics of the two branches, then the filter from the condition $\defbexp$ is applied and the results of the two branches are joined.
  \marginnote{
    \begin{align*}
      &\backwardsemanticsnoparam \semanticsof{\pwhilestmt}\defabstractvalue \DefeQ \lim \abstractdomaintransformer \\
      &\quad \abstractdomaintransformer(\defotherabstractvalue) \DefeQ \left(\begin{array}[l]{@{}l@{}}
        \abstractdomainfilter \semanticsof{\neg\defbexp}(\defabstractvalue) \abstractdomainjoin {} \\ \abstractdomainfilter
        \semanticsof{\defbexp}(\backwardsemanticsnoparam \semanticsof{\defstmt}(\defotherabstractvalue))
      \end{array}\right)
    \end{align*}
  }
  \item[\normalfont ($\pwhilestmt$)] The backward semantics of a while statement is the limit of the abstract iterates. The negated condition is applied first as $\defabstractvalue$ is the postcondition outside the loop, then the condition is applied to every iterate of the loop body, and the results are joined. The limit is computed by exploiting the widening operator to ensure convergence.

  Note that, we could further improve precision of the while statement (for both the forward and backward abstract analysis) by considering the narrowing operator as follows:
  \begin{align*}
    \lim \abstractdomaintransformer &\DefeQ y^k \text{ such that } k\in\Npos \text{ and } y^k \abstractdomainsubseteq \abstractdomaintransformer(y^k) \\
    \text{where } y^0 &\DefeQ x \\
    y^{i+1} &\DefeQ y^i \spacearound{\abstractdomainwidening} \abstractdomaintransformer(y^i)
  \end{align*}
  where $x$ is the limit of the abstract iterates using the widening operator.
  Further improvements can be achieved by delaying the application of the widening with the join operator, or by unrolling the loop body.
  \marginnote{
    \begin{align*}
      &\backwardsemanticsnoparam \semanticsof{\pcompstmt}\defabstractvalue \DefeQ \\
      &\quad\backwardsemanticsnoparam \semanticsof{\defstmt}\left(\backwardsemanticsnoparam \semanticsof{\defstmt'}
      \defabstractvalue\right)
    \end{align*}
  }
  \item[\normalfont ($\pcompstmt$)] The backward semantics of a composition statement is the composition of the abstract semantics of the two statements.
  \item[\normalfont ($\pprogstmt$)]
    The backward semantics of a program is the abstract semantics of the exit statement starting from the abstract element representing all the states, \ie, the top element $\abstractdomaintop$.
    \begin{definition}[Backward Co-Reachability State Abstract Semantics]
      The \emph{backward co-reachability state abstract semantics} $\backwardsemantics\in\backwardtype$ for a program $\defprogram$ is defined as:
      \begin{align*}
        \backwardsemantics \DefeQ \backwardsemanticsnoparam \semanticsof{\progstmt} \spacearound{=} \backwardsemanticsnoparam \semanticsof{\defstmt}\abstractdomaintop
      \end{align*}
    \end{definition}
\end{description}


The following result provides the soundness of $\backwardsemantics$ with respect to the concrete semantics $\backwardreachabilitytracesemantics$, \cf{} \refdef*{backward-reachability-state-semantics}.

\begin{theorem}
  Given a program $\defprogram$, the backward reachability state abstract semantics $\backwardsemantics$ is sound with respect to the backward reachability state semantics $\backwardreachabilitytracesemantics$ whenever it holds that:
  \begin{align*}
    \backwardreachabilitytracesemantics \subseteq \abstractdomainconcretization(\backwardsemantics)
  \end{align*}
\end{theorem}
